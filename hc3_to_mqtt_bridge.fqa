{"name":"HC3 <-> MQTT Bridge","type":"com.fibaro.binarySwitch","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_51"},"sections":{"items":[{"components":[{"name":"availableDevices","style":{"weight":"1.2"},"text":"Available devices: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bridgedDevices","style":{"weight":"1.2"},"text":"Bridged devices: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bootTime","style":{"weight":"1.2"},"text":"Boot time: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_51"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"hc3Auth","value":""},{"name":"mqttUrl","value":"mqtt://192.168.1.100:1883"},{"name":"mqttUsername","value":"username"},{"name":"mqttPassword","value":"password"},{"name":"mqttKeepAlive","value":"10"},{"name":"mqttAuth","value":""}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"local fibaroBaseTypeOverride = {\n    [\"com.fibaro.FGR\"] = \"com.fibaro.baseShutter\",\n    [\"com.fibaro.FGMS001\"] = \"com.fibaro.motionSensor\"\n}\n\nlocal fibaroTypeOverride = {\n    [\"com.fibaro.FGKF601\"] = \"com.fibaro.keyFob\",\n    [\"com.fibaro.FGD212\"] = \"com.fibaro.dimmer\",\n    [\"com.fibaro.FGMS001v2\"] = \"com.fibaro.motionSensor\",\n    [\"com.fibaro.FGFS101\"] = \"com.fibaro.floodSensor\"\n} \n\nfunction QuickApp:onInit()\n    self:debug(\"-------------------------\")\n    self:debug(\"HC3 <-> MQTT BRIDGE\")\n    self:debug(\"-------------------------\")\n\n    self:turnOn()\nend\n\nfunction QuickApp:publish(topic, payload)\n    self.mqtt:publish(topic, tostring(payload), {retain = true})\nend\n\nfunction QuickApp:turnOn()\n    self:establishMqttConnection()\nend\n\nfunction QuickApp:turnOff()\n    self:simulatePropertyUpdate(self:getDevice(1), \"dead\", \"true\")\n    self:disconnectFromMqttAndHc3()\n    self:updateProperty(\"value\", false)\nend\n\nfunction QuickApp:establishMqttConnection()\n    self.deviceById = {}\n    self.haDeviceTypeById = {}\n    self.fibaroDeviceBaseTypeById = {}\n    self.fibaroDeviceTypeById = {}\n    self.dimmerBrightnessUpdateTime = {}\n    self.lastMqttCommandTime = {}\n    self.lastHc3CommandTime = {}\n    self.lastHc3CommandSourceType = {}\n\n    self.haDeviceTypeById[1] = \"binary_sensor\"\n    self.hc3Device = self:getDevice(1)\n    self.hc3DeviceDetails = api.get(\"/devices/1\")\n\n    if self.mqtt then\n        --[[ \n        if pcall(self:closeMqttConnection()) then\n            self:debug(\"Old connection closed\")\n        else\n            self:warning(\"Unable to close old connection\")\n        end\n        ]]--\n    end\n\n    self:debug(\"Connecting to \" .. self:getVariable(\"mqttUrl\") ..  \" ...\")\n\n    local mqttConnectionParameters = self:getMqttConnectionParameters()\n\n    self:trace(\"MQTT Connection Parameters: \" .. json.encode(mqttConnectionParameters))\n\n    local mqttClient = mqtt.Client.connect(\n                                    self:getVariable(\"mqttUrl\"), \n                                    mqttConnectionParameters) \n\n    mqttClient:addEventListener('connected', function(event) self:onConnected(event) end)\n    mqttClient:addEventListener('closed', function(event) self:onClosed(event) end)\n    mqttClient:addEventListener('message', function(event) self:onMessage(event) end)\n    mqttClient:addEventListener('error', function(event) self:onError(event) end)    \n    mqttClient:addEventListener('subscribed', function(event) self:onSubscribed(event) end)\n    mqttClient:addEventListener('published', function(event) self:onPublished(event) end) \n\n    self.mqtt = mqttClient\nend\n\nfunction QuickApp:getMqttConnectionParameters()\n    local mqttConnectionParameters = {\n        lastWill = {\n            topic = createPropertyTopicName(self.hc3Device, \"dead\"),\n            payload = \"true\"\n        }\n    }\n\n    -- MQTT CLIENT ID\n    local mqttClientId = self:getVariable(\"mqttClientId\")\n    if (isEmptyString(mqttClientId)) then\n        mqttConnectionParameters.clientId = \"HC3-\" .. plugin.mainDeviceId\n    else\n        mqttConnectionParameters.clientId = mqttClientId\n    end\n\n    -- MQTT KEEP ALIVE PERIOD\n    local mqttKeepAlivePeriod = self:getVariable(\"mqttKeepAlive\")\n    if (mqttKeepAlivePeriod) then\n        mqttConnectionParameters.keepAlivePeriod = tonumber(mqttKeepAlivePeriod)\n    else\n        mqttConnectionParameters.keepAlivePeriod = 30\n    end\n\n    -- MQTT AUTH (USERNAME/PASSWORD)\n    local mqttAuth = self:getVariable(\"mqttAuth\")\n    local mqttUsername\n    local mqttPassword\n    if (isEmptyString(mqttAuth)) then\n        self:debug(\"plain\")\n        mqttUsername = self:getVariable(\"mqttUsername\")\n        mqttPassword = self:getVariable(\"mqttPassword\")\n    else \n        local mqttAuth = self:getVariable(\"mqttAuth\")\n        if (mqttAuth) then\n            mqttUsername, mqttPassword = decodeBase64Auth(mqttAuth)\n        end\n    end\n\n    if (mqttUsername) then\n        mqttConnectionParameters.username = mqttUsername\n    end\n    if (mqttPassword) then\n        mqttConnectionParameters.password = mqttPassword\n    end\n\n    return mqttConnectionParameters\nend\n\nfunction QuickApp:disconnectFromMqttAndHc3()\n    self.hc3ConnectionEnabled = false\n    self:closeMqttConnection()\nend\n\nfunction QuickApp:closeMqttConnection()\n    local options = {}\n    self.mqtt:disconnect(options)\nend\n\nfunction QuickApp:onConnected(event)\n    self:debug(\"MQTT connection established\")\n    self.mqtt:subscribe(\"homeassistant/+/+/commands/+\")\nend\n\nfunction QuickApp:onClosed(event)\n    self:updateProperty(\"value\", false)\nend\n\nfunction QuickApp:onError(event)\n    self:error(\"MQTT ERROR: \" .. json.encode(event))\n    self:turnOff()\n    self:scheduleReconnectToMqtt();\nend\n\nfunction QuickApp:scheduleReconnectToMqtt()\n    self:debug(\"Schedule attempt to reconnect to MQTT...\")\n    fibaro.setTimeout(10000, function() \n        self:establishMqttConnection()\n    end)\nend\n\nfunction QuickApp:onMessage(event)\n    self:debug(\"COMMAND \" .. json.encode(event))\n\n    local deviceId = getDeviceIdFromTopic(event.topic)\n    if not deviceId then\n        self:error(\"No device id could be extracted from topic \" .. event.topic)\n    end\n\n    self:rememberLastMqttCommandTime(deviceId)\n\n    if string.find(event.topic, \"setValue$\") then\n        self:onSetValue(deviceId, event)\n    elseif string.find(event.topic, \"setBrightness$\") then\n        self:onSetBrightness(deviceId, event)\n    elseif string.find(event.topic, \"setPosition$\") then\n        self:onSetPosition(deviceId, event)\n    elseif string.find(event.topic, \"setThermostatMode$\") then\n        self:onSetThermostatMode(deviceId, event)\n    elseif string.find(event.topic, \"setHeatingThermostatSetpoint$\") then\n        self:onSetHeatingThermostatSetpoint(deviceId, event)\n    else\n        self:warning(\"Unknown event \" .. json.encode(event))\n    end\nend \n\nfunction QuickApp:discoverDevicesAndBroadcastToHa()\n    local startTime = os.time()\n\n    self.devices = {}\n    local allDevices = api.get(\"/devices?enabled=true&visible=true\")\n    self:publishDeviceToMqtt(self.hc3DeviceDetails)\n\n\n    local bridgedDevices = 0\n    for i, j in pairs(allDevices) do\n        if (self:publishDeviceToMqtt(j)) then\n            bridgedDevices = bridgedDevices + 1\n        end\n    end\n\n    local endTime = os.time()\n    local diff = endTime - startTime \n\n    self:updateView(\"availableDevices\", \"text\", \"Available devices: \" .. #allDevices)\n    self:updateView(\"bridgedDevices\", \"text\", \"Bridged devices: \" .. bridgedDevices)\n    self:updateView(\"bootTime\" , \"text\", \"Boot time: \" .. diff .. \"s\")\n\n    self:debug(\"Load complete!\")\n\n    return haDevices\nend\n\nfunction QuickApp:publishDeviceToMqtt(j)\n    local deviceId = j.id\n    local fibaroType = j.type\n    local fibaroBaseType = j.baseType\n\n    if (not fibaroType) then\n        self:error(\"No fibaro type indicated for \" .. deviceName .. \" - \" .. deviceId)\n        return\n    end\n\n    if (not fibaroBaseType) then\n        self:error(\"No fibaro base type indicated for \" .. deviceName .. \" - \" .. deviceId)\n        return\n    end\n\n    -- override base type if necessary\n    local overrideBaseType = fibaroBaseTypeOverride[fibaroBaseType]\n    if overrideBaseType then\n        fibaroBaseType = overrideBaseType\n    end\n    self.fibaroDeviceBaseTypeById[deviceId] = fibaroBaseType\n\n    local overrideType = fibaroTypeOverride[fibaroType]\n    if overrideType then\n        fibaroType = overrideType\n    end\n    self.fibaroDeviceTypeById[deviceId] = fibaroType\n\n    local interfaces = j.interfaces\n    local categories = j.properties.categories\n\n    --self:debug(\"DEVICE: \" .. j.name .. \"(\" .. deviceId .. \") \" .. j.baseType .. \" | \" .. j.type .. \" | \" .. json.encode(interfaces) .. \" | \" .. json.encode(categories))\n\n    local haConfig = {\n    }\n\n    local haDeviceType = nil\n    local hasValue = true\n    local hasState = false\n    local hasBrightness = false\n    local hasPosition = false\n    local hasBinaryValue = true\n    local hasMode = false\n    local isEditable = false\n    local isThermostat = false\n    local hasTopicToTriggerEvents = false\n    local supportTextNotifications = false\n    local supportVoiceNotifications = false\n    local decoyDevice = false\n\n    ------------------------------------------------------------------\n    ------- IDENTIFY DEVICE TYPE FOR HOME ASSISTANT\n    ------------------------------------------------------------------\n    if (fibaroBaseType == \"com.fibaro.actor\") then\n        if (fibaroType == \"com.fibaro.binarySwitch\") then\n            isEditable = true\n            if (table_contains_value(interfaces, \"light\")) then\n                haDeviceType = \"light\"\n            else\n                -- climate (fan) is not supported\n                if (table_contains_value(categories, \"climate_does_not_exist\")) then\n                    haDeviceType = \"fan\"\n                    hasValue = false\n                else\n                    haDeviceType = \"switch\"\n                end\n            end\n        end\n\n    elseif (fibaroBaseType == \"com.fibaro.baseShutter\") then \n        haDeviceType = \"cover\"\n        hasPosition = true\n        isEditable = true\n\n    elseif (fibaroBaseType == \"com.fibaro.multilevelSwitch\") then\n        haDeviceType = \"light\"\n        isEditable = true\n        hasBrightness = true\n\n    elseif (fibaroBaseType == \"com.fibaro.sensor\") then \n        if (fibaroType == \"com.fibaro.multilevelSensor\") then\n            haDeviceType = \"sensor\"\n            hasBinaryValue = false\n            haConfig.unit_of_measurement = j.properties.unit\n        else\n            haDeviceType = \"binary_sensor\"\n        end\n\n    elseif (fibaroBaseType == \"com.fibaro.motionSensor\" or fibaroType == \"com.fibaro.motionSensor\") then\n        haDeviceType = \"binary_sensor\"\n        haConfig.device_class = \"motion\"\n\n    elseif (fibaroBaseType == \"com.fibaro.floodSensor\") then\n        haDeviceType = \"binary_sensor\"\n        haConfig.device_class = \"moisture\" \n\n\n    elseif (fibaroBaseType == \"com.fibaro.doorWindowSensor\") then\n        if (fibaroType == \"com.fibaro.doorSensor\") then\n            haDeviceType = \"binary_sensor\"\n            haConfig.device_class = \"door\"\n            --haConfig.off_delay = \"2\"\n        else\n            self:warning(\"UNKNOWN DOOR WINDOW SENSOR \" .. self:getDeviceDescription(deviceId))\n        end\n\n    elseif (fibaroBaseType == \"com.fibaro.smokeSensor\") then\n            haDeviceType = \"binary_sensor\"\n            haConfig.device_class = \"smoke\"\n\n    elseif (fibaroBaseType == \"com.fibaro.lifeDangerSensor\") then\n            haDeviceType = \"binary_sensor\"\n            -- reuse \"smoke\" icon, looks prete decent in home assistant\n            haConfig.device_class = \"smoke\"\n\n    elseif (fibaroBaseType == \"com.fibaro.multilevelSensor\") then\n        haDeviceType = \"sensor\"\n        hasBinaryValue = false\n        if (fibaroType == \"com.fibaro.temperatureSensor\") then\n            haConfig.device_class = \"temperature\" \n            haConfig.unit_of_measurement = \"°\" .. j.properties.unit\n        elseif (fibaroType == \"com.fibaro.lightSensor\") then\n            haConfig.unit_of_measurement = j.properties.unit\n            haConfig.device_class = \"illuminance\"\n        else\n            self:warning(\"UNKNOWN DEVICE TYPE FOR MULTILEVEL SENSOR \" .. self:getDeviceDescription(deviceId))\n        end\n\n    elseif (fibaroType == \"com.fibaro.hvacSystem\") then\n        hasMode = true\n        haDeviceType = \"climate\"\n        hasBinaryValue = false\n        hasValue = false\n        isThermostat = true\n\n    elseif (fibaroBaseType == \"com.fibaro.remoteSceneController\") then\n        if (fibaroType == \"com.fibaro.keyFob\") then\n            -- ToDo: implement keyFob support later\n            --     * 6 buttons\n            --     * click types: \"keyPressed\", \"keyHeldDown\", \"keyReleased\"\n            haDeviceType = \"device_automation\"\n            haConfig.automation_type = \"trigger\"\n            haConfig.type = \"button_short_press\"\n            haConfig.subtype = \"button_1\"\n            hasTopicToTriggerEvents = true\n            hasValue = false\n        end\n\n    elseif (fibaroType == \"com.fibaro.zwavePrimaryController\") then\n        haDeviceType = \"binary_sensor\"\n        haConfig.name = \"Fibaro HC3\"\n        haConfig.device_class = \"plug\"\n        decoyDevice = true\n\n    elseif (fibaroType == \"HC_user\") then\n        --self:debug(\"Ignore HC_user for now\")\n\n        --[[\n        \"properties\": {\n            \"Email\": \"<tbd>@gmail.com\",\n            \"actions\": {\n            \"sendDefinedEmailNotification\": 1,\n            \"sendDefinedSMSNotification\": 2,\n            \"sendEmail\": 2,\n            \"sendGlobalEmailNotifications\": 1,\n            \"sendGlobalPushNotifications\": 1,\n            \"sendGlobalSMSNotifications\": 1,\n            \"sendPush\": 1,\n            \"setSipDisplayName\": 1,\n            \"setSipUserID\": 1,\n            \"setSipUserPassword\": 1\n        }\n        ]]--\n\n    elseif (fibaroType == \"com.fibaro.player\") then\n        -- TODO add proper support for media player / TTL\n        haDeviceType = \"media_player\"\n        haConfig.commands = {\n            turn_on = {\n                service = \"SERVICE\",\n                data = \"SERVICE_DATA\"\n            },\n            turn_off = {\n                service = \"SERVICE\",\n                data = \"SERVICE_DATA\"\n            }\n        }\n\n    else\n        self:warning(\"UNKNOWN DEVICE TYPE \" .. self:getDeviceDescription(deviceId))\n    end\n\n    self.haDeviceTypeById[deviceId] = haDeviceType\n \n\n------------------------------------------------------------------\n------- ANNOUNCE DEVICE CONFIGURATION TO HOME ASSISTANT\n------------------------------------------------------------------\n    --self:debug(\"START PUBLISHING CONFIG TO HA - \" .. tostring(haDeviceType))\n    if haDeviceType then\n        -- refresh with haDeviceType property\n        device = self:getDeviceAndRefreshCache(deviceId)\n\n        haConfig.unique_id = tostring(device.id) \n        \n        if (not haConfig.name) then\n            haConfig.name = device.name\n        end\n        haConfig.name = haConfig.name .. \" (\" .. device.roomName .. \")\"\n        --haConfig.name = haConfig.name .. \" #\" .. device.id .. \" (\" .. device.roomName .. \")\"\n\n        --self:debug(\"REGISTER DEVICE \" .. haConfig.name .. \" | \" .. haDeviceType)\n\n        if (device.id ~= self.hc3Device.id) then\n            haConfig.availability = {\n                {topic = createPropertyTopicName(device, \"dead\"), payload_available = \"false\", payload_not_available = \"true\"},\n                {topic = createPropertyTopicName(self.hc3Device, \"dead\"), payload_available = \"false\", payload_not_available = \"true\"}\n            }\n            --haConfig.availability_topic = createPropertyTopicName(device, \"dead\")\n        else\n            haConfig.availability_topic = createPropertyTopicName(device, \"dead\")\n            haConfig.payload_available = \"false\"\n            haConfig.payload_not_available = \"true\"\n        end\n\n        haConfig.device = {\n            manufacturer = \"Fibaro\",\n            name = \"Home Center 3\",\n            model = self.hc3DeviceDetails.type,\n            sw_version = self.hc3DeviceDetails.properties.zwaveVersion,\n            identifiers = {tostring(self.hc3DeviceDetails.id)}\n        }\n\n        haConfig.json_attributes_topic = createHaJsonAttributesTopicName(device)\n\n        if hasValue then\n            haConfig.state_topic = createPropertyTopicName(device, \"value\")\n            haConfig.value_template = \"{{ value_json.value }}\"\n        end\n        if hasState then\n            haConfig.state_value_template = \"{{ value_json.value }}\"\n        end\n        \n        if hasBinaryValue then\n            haConfig.payload_on = \"true\"\n            haConfig.payload_off = \"false\"\n        end\n        \n        if isEditable then\n            haConfig.command_topic = createCommandTopicName(device, \"value\")\n        end\n\n        if hasBrightness then\n            haConfig.brightness_scale = 99\n            haConfig.brightness_state_topic = createPropertyTopicName(device, \"brightness\")\n            haConfig.brightness_value_template = \"{{ value_json.value }}\"\n            if isEditable then\n                haConfig.brightness_command_topic = createCommandTopicName(device, \"brightness\")\n            end\n        end\n\n        if hasPosition then\n            haConfig.payload_on = nil\n            haConfig.payload_off = nil\n            haConfig.state_topic = nil\n            haConfig.command_topic = nil\n\n            haConfig.position_open = 100\n            haConfig.position_closed = 0\n            haConfig.payload_open = \"100\"\n            haConfig.payload_close = \"0\"\n            haConfig.payload_stop = \"stop\"\n            haConfig.state_open = \"open\"\n            haConfig.state_closed = \"closed\"\n            haConfig.state_opening = \"opening\"\n            haConfig.state_closing = \"closing\"\n            haConfig.position_topic = createPropertyTopicName(device, \"position\")\n            if isEditable then\n                haConfig.set_position_topic = createCommandTopicName(device, \"position\")\n            end\n        end\n\n        if isThermostat then\n            haConfig.mode_state_topic = createPropertyTopicName(device, \"thermostatMode\")\n            haConfig.mode_state_template = \"{{ value_json.value }}\"\n            haConfig.mode_command_topic = createCommandTopicName(device, \"thermostatMode\")\n\n            haConfig.temperature_state_topic = createPropertyTopicName(device, \"heatingThermostatSetpoint\")\n            haConfig.temperature_state_template = \"{{ value_json.value }}\"\n            haConfig.temperature_command_topic = createCommandTopicName(device, \"heatingThermostatSetpoint\")\n\n            -- refactor\n            local currentTemperatureDevice = {\n                id = deviceId + 1,\n                name = \"doesn't matter\", \n                fibaroBaseType = \"doesn't matter\",\n                fibaroType = \"doesn't matter\",\n                haType = \"sensor\",\n                roomName = \"doesn't matter\"\n            }\n\n            haConfig.current_temperature_topic = createPropertyTopicName(currentTemperatureDevice, \"value\")\n            haConfig.current_temperature_template = \"{{ value_json.value }}\"\n\n            local fibaroModes = j.properties.supportedThermostatModes\n            haConfig.modes = {}\n            for i, mode in pairs(fibaroModes) do\n                haConfig.modes[i] = string.lower(mode)\n            end\n\n            haConfig.temp_step = tonumber(j.properties.heatingThermostatSetpointStep[j.properties.unit])\n            haConfig.min_temp = j.properties.heatingThermostatSetpointCapabilitiesMin\n            haConfig.max_temp = j.properties.heatingThermostatSetpointCapabilitiesMax\n\n            haConfig.temperature_unit = j.properties.unit\n        end\n\n        if hasTopicToTriggerEvents then\n            haConfig.topic = createPropertyTopicName(device, \"triggerEvent\")\n        end\n\n        if haDeviceType == \"fan\" then\n            haConfig.optimistic = false\n\n            --haConfig.speed_state_topic = createPropertyTopicName(device, \"speed\")\n            --haConfig.speed_value_template = \"{{ value_json.value }}\"\n            --haConfig.payload_low_speed = \"low\"\n            --haConfig.payload_medium_speed = \"medium\"\n            --haConfig.payload_high_speed = \"high\"\n            --haConfig.speeds = { \"off\", \"low\", \"medium\", \"high\"}\n            --haConfig.state_value_template = \"{{ value_json.value }}\"\n\n            if isEditable then\n                --haConfig.oscillation_command_topic = createCommandTopicName(device, \"oscillation\")\n                --haConfig.speed_command_topic = createCommandTopicName(device, \"speed\")\n            end\n        end\n\n        j.metaInfo = device.metaInfo\n\n        -- self:debug(\"PUBLISH DEVICE CONFIG: \" .. json.encode(haConfig)) \n\n        -- Basic configuration for Home Assistant\n        self:publish(\n            createHaConfigTopicName(device), \n            json.encode(haConfig)\n        ) \n\n        -- Publish extra device attributes\n        self:publish(\n            createHaJsonAttributesTopicName(device), \n            json.encode(j)\n        )\n\n        -----------------------------------------------------------------\n        ----------- BROADCAST DEVICE CURRENT STATE TO HOME ASSISSTANT\n        -----------------------------------------------------------------\n\n        self:simulatePropertyUpdate(device, \"dead\", j.properties.dead)\n        if (j.propertiesDead) then\n            self:simulatePropertyUpdate(device, \"deadReason\", j.properties.deadReason)\n        end\n\n        if hasBrightness then\n            self:simulatePropertyUpdate(device, \"value\", j.properties.value)\n            self:simulatePropertyUpdate(device, \"state\", j.properties.state)\n        elseif hasPosition then\n            self:simulatePropertyUpdate(device, \"value\", j.properties.value)\n            self:simulatePropertyUpdate(device, \"state\", j.properties.state)\n        elseif haDeviceType == \"climate\" then\n            self:simulatePropertyUpdate(device, \"thermostatMode\", string.lower(j.properties.thermostatMode))\n            self:simulatePropertyUpdate(device, \"heatingThermostatSetpoint\", j.properties.heatingThermostatSetpoint)\n        elseif haDeviceType == \"fan\" then\n            -- do nothing, for now\n        elseif hasValue then\n            if decoyDevice then\n                self:simulatePropertyUpdate(device, \"value\", \"true\")\n            else\n                self:simulatePropertyUpdate(device, \"value\", j.properties.value)\n            end\n        else\n            self:trace(\"No value detected for \" .. self:getDeviceDescription(deviceId))\n        end\n\n        return haConfig\n    end\nend\n\nfunction QuickApp:removeDeviceFromMqtt(device)\n    self:publish(\n        createHaConfigTopicName(device), \n        \"\"\n    )\nend\n\nfunction QuickApp:onSubscribed()\n    self:debug(\"MQTT subscription established\")\n\n    self:discoverDevicesAndBroadcastToHa()\n\n    self.hc3ConnectionEnabled = true\n    self:readHc3Events()\n\n    self:debug(\"Started fetching HC3 events\")\n\n    self:updateProperty(\"value\", true)\nend\n\nfunction QuickApp:onPublished(event)\n    -- do nothing, for now\nend\n\nfunction QuickApp:onSetValue(deviceId, event)\n    local payload = event.payload\n\n    local osTime = os.time()\n\n    local data = {properties = {value = tostring(event.payload)} }\n\n    local fibaroBaseType = self:getFibaroDeviceBaseTypeById(deviceId)\n\n    if (fibaroBaseType == \"com.fibaro.multilevelSwitch\") then\n        local state = plugin.getProperty(deviceId, \"state\")\n        local brightness = plugin.getProperty(deviceId, \"value\")\n        if brightness > 0 then\n            state = true\n        end\n        if (event.payload == \"true\" and state == false) then\n\n            local dimmerBrightnessUpdateTime = self.dimmerBrightnessUpdateTime[deviceId]\n            if not dimmerBrightnessUpdateTime then\n                dimmerBrightnessUpdateTime = -1\n            end\n            local diff = os.time() - dimmerBrightnessUpdateTime\n            \n            if (diff > 1) then\n                fibaro.call(deviceId, \"turnOn\")\n            else\n                -- ignore\n            end\n        elseif (event.payload == \"false\" and state == true) then\n            fibaro.call(deviceId, \"turnOff\")\n        else\n            self:warning(\"Unknown value: \" .. json.encode(event))\n        end\n    else\n        if (event.payload == \"true\") then\n            fibaro.call(deviceId, \"turnOn\")\n        elseif (event.payload == \"false\") then\n            fibaro.call(deviceId, \"turnOff\")\n        else\n            self:warning(\"Unknown value: \" .. json.encode(event))\n        end\n    end\nend\n\nfunction QuickApp:onSetBrightness(deviceId, event)\n    local payload = event.payload\n\n    local osTime = os.time()\n\n    local data = {properties = {value = tostring(event.payload)} }\n    \n    self.dimmerBrightnessUpdateTime[deviceId] = os.time()\n    fibaro.call(deviceId, \"setValue\", event.payload)\nend\n\nfunction QuickApp:onSetPosition(deviceId, event)\n    local payload = event.payload\n\n    local data = {properties = {value = tostring(event.payload)} }\n    \n    fibaro.call(deviceId, \"setValue\", event.payload)\nend\n\nfunction QuickApp:onSetThermostatMode(deviceId, event)\n    local payload = event.payload\n\n    local deviceId = getDeviceIdFromTopic(event.topic)\n\n    local data = {properties = {value = tostring(event.payload)} }\n    \n    local mode = event.payload:gsub(\"^%l\", string.upper)\n\n    fibaro.call(deviceId, \"setThermostatMode\", mode)\nend\n\nfunction QuickApp:onSetHeatingThermostatSetpoint(deviceId, event)\n    local payload = json.decode(event.payload)\n\n    local data = {properties = {value = tostring(event.payload)} }\n    \n    fibaro.call(deviceId, \"setHeatingThermostatSetpoint\", event.payload)\nend\n\n-- FETCH HC3 EVENTS\nlocal lastRefresh = 0\nlocal http = net.HTTPClient()\nfunction QuickApp:readHc3Events()\n    local requestUrl = \"http://localhost:11111/api/refreshStates?last=\" .. lastRefresh;\n    --self:debug(\"Try fetch events from \" .. requestUrl .. \" | \" .. tostring(self.hc3ConnectionEnabled))\n\n    -- use non-block HTTP calls, avoid api.get(uri) that has a risk of blocking calls\n    local stat,res = http:request(\n        requestUrl,\n        {\n        options = {\n            headers = {\n                [\"Authorization\"] = \"Basic \" .. self:getVariable(\"hc3Auth\"),\n            }\n        },\n        success=function(res)\n            local states = res.status == 200 and json.decode(res.data)\n\n            if (res.status ~= 200) then\n                self:error(\"Unexpected response status \" .. res.status)\n            end\n            if (not res.data) then\n                self:error(\"Empty response\")\n            end\n            if (not self.hc3ConnectionEnabled) then\n                self:debug(\"Got flagged to stop reading HC3 events\")\n            end\n\n            if states and self.hc3ConnectionEnabled then\n                lastRefresh = states.last\n                if states.events and #states.events>0 then \n                    for i, v in ipairs(states.events) do\n                        self:dispatchFibaroEventToMqtt(v)self:dispatchFibaroEventToMqtt(v)\n                        --local status, err = pcall(function () self:dispatchFibaroEventToMqtt(v) end)\n                        --self:debug(\"RESP: \" .. json.encode(status) .. \" - \" .. json.encode(err))\n                    end\n                end\n            end\n\n            if (self.hc3ConnectionEnabled) then\n                fibaro.setTimeout(50, function()\n                --fibaro.setTimeout(1000, function()  \n                    self:readHc3Events()\n                end)\n            end\n        end,\n        error=function(res) \n            self:error(\"Error while reading HC3 events \" .. json.encode(res))\n            self:turnOff()\n        end\n    })\nend\n\nfunction QuickApp:simulatePropertyUpdate(device, propertyName, payload)\n    local event = createFibaroEventPayload(device, propertyName, payload)\n    event.simulation = true\n    --self:debug(\"SIMULATE PROPERTY UPDATE EVENT: \" .. json.encode(event))\n    self:dispatchFibaroEventToMqtt(event)\nend\n\nfunction QuickApp:dispatchFibaroEventToMqtt(event)\n    -- self:debug(\"Event 1: \" .. json.encode(event))\n    if (not event) then\n        self:error(\"No event found\")\n        return\n    end\n\n    if (not event.data) then\n        self:error(\"No event data found\")\n        return\n    end\n\n    local deviceId = event.data.id or event.data.deviceId\n\n    if not deviceId then\n        -- deviceId is must have for processing logic\n        self:warning(\"No device id for \" .. json.encode(event))\n        return\n    end\n    \n    local propertyName = event.data.property\n    if not propertyName then\n        propertyName = \"unknown\"\n    end\n\n    if (not event.type) then\n        event.type = \"unknown\"\n    end\n\n    local device = self:getDevice(deviceId)\n\n    --self:trace(\"Dispatch event \" .. json.encode(event) .. \" | \"  .. device.fibaroBaseType .. \" | \" .. device.fibaroType .. \" | \" .. event.type .. \" | \" .. tostring(event.simulation))\n\n    if (device.haType == \"unknown\") then\n        --self:warning(\"Unknown HA device type for \" .. \" | \" .. deviceId .. \" | \" .. json.encode(device) .. \" | \" .. tostring(self.haDeviceTypeById[device.id]) .. \" | \" .. json.encode(event))\n    end\n\n    local genericPayload = {\n        id = device.id,\n        --deviceId = device.id,\n        deviceName = device.name,\n        haType = device.haType,\n        fibaroType = device.fibaroType,\n        fibaroBaseType = device.fibaroBaseType,\n        created = event.created,\n        timestamp = os.date(),\n        roomId = fibaro.getRoomID(deviceId),\n        roomName = device.roomName\n    }\n\n    -- fibaro doesn't have a consistant use of \"value\" and \"state\" properties for \"dimmer\" device :(, so here goes a workaround\n    if (event.type == \"DeviceActionRanEvent\") then\n        if (device.haType == \"unknown\") then\n            --self:trace(json.encode(self.haDeviceTypeById))\n        end\n\n        if (event.data.actionName == \"turnOn\" or event.data.actionName == \"turnOff\") then\n            self:rememberLastHc3CommandTime(deviceId, event.sourceType)\n        end\n        \n    elseif (event.type == \"DevicePropertyUpdatedEvent\") then\n        local now = os.time()\n\n        local lastMqttCommandTime = self.lastMqttCommandTime[device.id]\n        if not lastMqttCommandTime then\n            lastMqttCommandTime = -1\n        end\n\n        local lastHc3CommandTime = self.lastHc3CommandTime[device.id]\n        if not lastHc3CommandTime then\n            lastHc3CommandTime = -1\n        end\n\n        local lastHc3CommandSourceType = self.lastHc3CommandSourceType[device.id]\n\n        local diffHc3 = now - lastHc3CommandTime\n        local diffMqtt = now - lastMqttCommandTime\n\n        --[[\n            Event: {\"sourceType\":\"system\",\"data\":{\"property\":\"value\",\"oldValue\":false,\"id\":42,\"newValue\":true},\"objects\":[{\"objectId\":42,\"objectType\":\"device\"}],\"type\":\"DevicePropertyUpdatedEvent\",\"created\":1601229076}\n            Event: {\"sourceType\":\"system\",\"data\":{\"property\":\"state\",\"oldValue\":false,\"id\":42,\"newValue\":true},\"objects\":[{\"objectId\":42,\"objectType\":\"device\"}],\"type\":\"DevicePropertyUpdatedEvent\",\"created\":1601229076}\n            Event: {\"sourceType\":\"device\",\"sourceId\":42,\"created\":1601229076,\"type\":\"SceneStartedEvent\",\"data\":{\"id\":36,\"subid\":1,\"trigger\":null,\"type\":\"\"},\"objects\":[{\"objectId\":36,\"objectType\":\"scene\"}]}\n        ]]--\n\n        local simulation = (event.simulation == true)\n\n        local source = \"zwave-device\"\n        if (simulation) then\n            source = \"mqtt-bridge-simulation\"\n        elseif (diffMqtt <= 2) then\n            source = \"mqtt\"\n        elseif (diffHc3 <= 2) then\n            if (lastHc3CommandSourceType == \"user\") then\n                source = \"zwave-hc3-user\"\n            elseif (lastHc3CommandSourceType == \"system\") then\n                source = \"zwave-hc3-system\"\n            else\n                self:warning(\"Unknown source type \" .. lastHc3CommandSourceType)\n            end\n        end\n\n        --genericPayload.debugDiffHc3 = diffHc3\n        --genericPayload.debugDiffMqtt = diffMqtt\n        genericPayload.source = source\n\n        if (device.fibaroBaseType == \"com.fibaro.multilevelSwitch\") then\n            if propertyName == \"state\" then\n                --self:debug(\"state --> value\")\n                propertyName = \"value\" \n            elseif propertyName == \"value\" then\n                --self:debug(\"value --> brightness\")\n                propertyName = \"brightness\" \n            else\n                -- no workaround required for other properties\n            end\n        elseif (device.fibaroBaseType == \"com.fibaro.baseShutter\") then\n            if propertyName == \"state\" then\n                --self:debug(\"state --> value\")\n                --propertyName = \"value\" \n            elseif propertyName == \"value\" then\n                --self:debug(\"value --> position\")\n                propertyName = \"position\" \n            else\n                -- no workaround required for other properties\n            end\n        --elseif (device.haType == \"climate\") then\n        end\n\n        self:dispatchPropertyUpdateEvent(\n            device, \n            event,\n            genericPayload,\n            propertyName\n            )\n\n    elseif (event.type == \"DeviceModifiedEvent\") then\n        self:dispatchDeviceModifiedEvent(device)\n\n    elseif (event.type == \"CentralSceneEvent\") then\n        if (device.fibaroType == \"com.fibaro.keyFob\") then\n            self:dispatchCentralSceneEvent(\n                device, \n                event,\n                genericPayload\n                )\n        end\n    \n    elseif (event.type == \"DeviceCreatedEvent\") then\n        self:dispatchDeviceCreatedEvent(device)\n\n    elseif (event.type == \"DeviceRemovedEvent\") then\n        self:dispatchDeviceRemovedEvent(device)\n\n    else\n        self:warning(\"TBD: Need to introduce new event type for \" .. tostring(event.type))\n        -- unknown event type\n\n    end\n\n    -- PUBLISH RAW EVENT FOR DEBUG PURPOSES\n\n    --self:debug(\"!\" .. event.type .. \" - \" .. json.encode(device))\n\n    self:publish(\n        createGenericEventTopicName(device, event.type) .. \"/raw_event\",\n        json.encode(event)\n    )\nend\n\nfunction QuickApp:rememberLastHc3CommandTime(deviceId, sourceType)\n    self.lastHc3CommandTime[deviceId] = os.time()\n    self.lastHc3CommandSourceType[deviceId] = sourceType\nend\n\nfunction QuickApp:rememberLastMqttCommandTime(deviceId)\n    self.lastMqttCommandTime[deviceId] = os.time()\nend\n\nfunction QuickApp:dispatchPropertyUpdateEvent(device, event, payload, propertyName)\n    -- PUBLISH DEVICE STATUS FOR HA AND NODE-RED\n    local topic = createPropertyTopicName(device, propertyName)\n\n    local value = (type(event.data.newValue) == \"number\" and event.data.newValue or tostring(event.data.newValue))\n    if not value then\n        --self:warning(\"No property value found. Ignoring event\")\n        --return\n    elseif value == \"nil\" then\n        --self:warning(\"Nil property value found. Ignoring event\")\n        --return\n    end\n    payload.value = string.lower(value)\n\n    local haPayload\n    if (propertyName == \"dead\") then\n        haPayload = tostring(payload.value)\n    else\n        haPayload = json.encode(payload)\n    end\n\n    --self:debug(\"SEND MESSAGE: \" .. topic .. \" = \" .. json.encode(haPayload))\n    self:publish(\n        topic,\n        haPayload\n    )\nend\n\nfunction QuickApp:dispatchDeviceCreatedEvent(device)\n    local fibaroDeviceInfo = api.get(\"/devices/\" .. device.id)\n\n    if (fibaroDeviceInfo.visible and fibaroDeviceInfo.enabled) then\n        self:debug(\"Device created \" .. json.encode(fibaroDeviceInfo))\n        self:publishDeviceToMqtt(fibaroDeviceInfo)\n    end\nend\n\nfunction QuickApp:dispatchDeviceModifiedEvent(device)\n    self:debug(\"Device modified \" .. device.id)\n\n    self:dispatchDeviceRemovedEvent(device)\n\n    self:dispatchDeviceCreatedEvent(device)\nend\n\nfunction QuickApp:dispatchDeviceRemovedEvent(device)\n    self:debug(\"Device removed \" .. device.id)\n    self:removeDeviceFromMqtt(device)\nend\n\nfunction QuickApp:dispatchCentralSceneEvent(device, event, payload)\n    -- PUBLISH DEVICE STATUS FOR HA AND NODE-RED\n    local topic = createGenericEventTopicName(device, \"CentralSceneEvent\", \"key\" .. event.data.keyAttribute)\n\n    createGenericEventTopicName(device, event.type)\n\n    self:publish(\n        topic,\n        event.data.keyId\n    )\nend\n\n\nfunction QuickApp:getDevice(deviceId)\n    local device = self:getDeviceFromCache(deviceId)\n\n    if not device then\n        device = self:getDeviceUncached(deviceId)\n\n        self.deviceById[deviceId] = device\n    end\n    \n    return device\nend\n\nfunction QuickApp:getDeviceFromCache(deviceId)\n    return self.deviceById[deviceId]\nend\n\nfunction QuickApp:getDeviceAndRefreshCache(deviceId)\n    self.deviceById[deviceId] = self:getDeviceUncached(deviceId)\n\n    return self:getDevice(deviceId)\nend\n\nfunction QuickApp:getDeviceUncached(deviceId)\n    local deviceName = fibaro.getName(deviceId)\n    if (not deviceName) then\n        self:warning(\"No device name for \" .. deviceId)\n        deviceName = \"unknown\"\n    end\n\n    local roomName = fibaro.getRoomNameByDeviceID(deviceId)\n    \n    local fibaroDeviceBaseType = self:getFibaroDeviceBaseTypeById(deviceId)\n    local fibaryDeviceType = self:getFibaroDeviceTypeById(deviceId)\n    local haDeviceType = self:getHaDeviceTypeById(deviceId)\n\n\n    -- extract meta information from device name if available, and purify device name\n    local metaInfo = extractMetaInfoFromDeviceName(deviceName)\n    if (metaInfo and metaInfo.pureName) then\n        deviceName = metaInfo.pureName\n    end\n    metaInfo.haType = haDeviceType or \"unknown\"\n\n    local device = {\n        id = deviceId,\n        name = deviceName, \n        fibaroBaseType = fibaroDeviceBaseType or \"unknown\",\n        fibaroType = fibaryDeviceType or \"unknown\",\n        haType = metaInfo.haType,\n        --haType = \"unknown\",\n        roomName = roomName,\n        metaInfo = metaInfo\n    }\n\n    return device\nend\n\nfunction QuickApp:getFibaroDeviceBaseTypeById(deviceId)\n    local fibaroBaseType = self.fibaroDeviceBaseTypeById[deviceId]\n    if not fibaroBaseType then\n        fibaroBaseType = \"unknown\"\n    end\n\n    return fibaroBaseType\nend\n\nfunction QuickApp:getFibaroDeviceTypeById(deviceId)\n    local fibaroType = self.fibaroDeviceTypeById[deviceId]\n    if not fibaroType then\n        fibaroType = \"unknown\"\n    end\n\n    return fibaroType\nend\n\nfunction QuickApp:getHaDeviceTypeById(deviceId)\n    local haType = self.haDeviceTypeById[deviceId]\n    if not haType then\n        haType = \"unknown\"\n    end\n\n    return haType\nend\n\nfunction QuickApp:getDeviceDescription(deviceId)\n    if (deviceId) then\n        local device = self:getDevice(deviceId) \n\n        if device and device.name and device.id and device.roomName then\n            return device.name .. \" #\" .. device.id .. \" (\" .. tostring(device.roomName) .. \")\"\n        else\n            return device.id\n        end\n    else\n        return \"no device id\"\n    end\nend\n\n-- TODO: com.fibaro.seismometer\n-- TODO: com.fibaro.accelerometer\n\n-- eye seismometer\n--  \"type\": \"com.fibaro.seismometer\",\n--  \"baseType\": \"com.fibaro.multilevelSensor\",\n\n-- eye accelerometer\n--  \"type\": \"com.fibaro.accelerometer\",\n--  \"baseType\": \"com.fibaro.sensor\",\n\n-- tamper for flood sensor\n-- \"type\": \"com.fibaro.motionSensor\",\n-- \"baseType\": \"com.fibaro.securitySensor\","},{"name":"tools","isMain":false,"isOpen":true,"content":"local alphabet = {\r\n    [\"А\"] = \"A\",\r\n    [\"Б\"] = \"B\",\r\n    [\"В\"] = \"V\",\r\n    [\"Г\"] = \"G\",\r\n    [\"Д\"] = \"D\",\r\n    [\"Е\"] = \"E\",\r\n    [\"Ж\"] = \"Zh\",\r\n    [\"З\"] = \"Z\",\r\n    [\"И\"] = \"I\",\r\n    [\"І\"] = \"I\",\r\n    [\"Ї\"] = \"I\",\r\n    [\"Й\"] = \"I\",\r\n    [\"К\"] = \"K\",\r\n    [\"Л\"] = \"L\",\r\n    [\"М\"] = \"M\",\r\n    [\"Н\"] = \"N\",\r\n    [\"О\"] = \"O\",\r\n    [\"П\"] = \"P\",\r\n    [\"Р\"] = \"R\",\r\n    [\"С\"] = \"S\",\r\n    [\"Т\"] = \"T\",\r\n    [\"У\"] = \"U\",\r\n    [\"Ф\"] = \"F\",\r\n    [\"Х\"] = \"H\",\r\n    [\"Ч\"] = \"Ch\",\r\n    [\"Ц\"] = \"C\",\r\n    [\"Ш\"] = \"Sh\",\r\n    [\"Щ\"] = \"Shch\",\r\n    [\"И\"] = \"I\",\r\n    [\"Є\"] = \"E\",\r\n    [\"Э\"] = \"E\",\r\n    [\"Ю\"] = \"Ju\",\r\n    [\"Я\"] = \"Ja\",\r\n    [\"а\"] = \"a\",\r\n    [\"б\"] = \"b\",\r\n    [\"в\"] = \"v\",\r\n    [\"г\"] = \"g\",\r\n    [\"д\"] = \"d\",\r\n    [\"е\"] = \"e\",\r\n    [\"~\"] = \"e\",\r\n    [\"ж\"] = \"zh\",\r\n    [\"з\"] = \"z\",\r\n    [\"и\"] = \"i\",\r\n    [\"і\"] = \"i\",\r\n    [\"ї\"] = \"i\",\r\n    [\"й\"] = \"i\",\r\n    [\"к\"] = \"k\",\r\n    [\"л\"] = \"l\",\r\n    [\"м\"] = \"m\",\r\n    [\"н\"] = \"n\",\r\n    [\"о\"] = \"o\",\r\n    [\"п\"] = \"p\",\r\n    [\"р\"] = \"r\",\r\n    [\"с\"] = \"s\",\r\n    [\"т\"] = \"t\",\r\n    [\"у\"] = \"u\",\r\n    [\"ф\"] = \"f\",\r\n    [\"х\"] = \"h\",\r\n    [\"ч\"] = \"ch\",\r\n    [\"ц\"] = \"c\",\r\n    [\"ш\"] = \"sh\",\r\n    [\"щ\"] = \"shch\",\r\n    [\"ы\"] = \"i\",\r\n    [\"ь\"] = \"'\",\r\n    [\"є\"] = \"e\",\r\n    [\"э\"] = \"e\",\r\n    [\"ю\"] = \"ju\",\r\n    [\"я\"] = \"ja\"\r\n}\r\n\r\nfunction transliterate(input)\r\n    if (not input) then\r\n        return \"unknown_input_for_transliteration\"\r\n    end\r\n\r\n    local output = {}\r\n    local i = 1\r\n\r\n    for p, c in utf8.codes(input) do  \r\n        local char = utf8.char(c)\r\n        local outputCharacter = alphabet[char]\r\n\r\n        if not outputCharacter then\r\n        if (string.find(char, \"%a\") or string.find(char, \"%d\")) then\r\n            outputCharacter = char\r\n        else\r\n            outputCharacter = \"-\"\r\n        end\r\n\r\n        end\r\n        output[i] = outputCharacter\r\n        i = i + 1\r\n    end\r\n\r\n    --print(\"RESULT \" .. table.concat(output) ) \r\n\r\n    return table.concat(output) \r\nend\r\n\r\nfunction extractMetaInfoFromDeviceName(deviceName)\r\n    local metaInfo = {\r\n        pureName = deviceName,\r\n        autoPower = true,\r\n        turnOffTimeout = 10 * 60,\r\n        segmentId = -1,\r\n    }\r\n    \r\n    local s, e = string.find(deviceName, \"%[.+%]\")\r\n    if s and e then\r\n        local pureName = string.gsub(string.sub(deviceName, 1, s-1), \"%s+$\", \"\")\r\n        local metaStr = string.sub(deviceName, s+1, e-1)\r\n\r\n        metaInfo.pureName = pureName\r\n \r\n        local attrs = splitStringToNumbers(metaStr, \"%.\")\r\n        if attrs[1] == \"1\" then\r\n            metaInfo.autoPower = true\r\n        else\r\n            metaInfo.autoPower = false\r\n        end\r\n\r\n        if attrs[2] and attrs[2] ~= \"-\" then \r\n            metaInfo.turnOffTimeout = math.ceil(attrs[2] * 60)\r\n        end\r\n\r\n        if attrs[3] and attrs[3] ~= \"-\" then \r\n            metaInfo.segmentId = tonumber(attrs[3])\r\n            metaInfo.rooms = {}\r\n\r\n            local segmentIdsStr = fibaro.getGlobalVariable(\"segment_\" .. metaInfo.segmentId)\r\n            if segmentIdsStr then\r\n                local roomIds = splitStringToNumbers(segmentIdsStr, \",\")\r\n                for i,roomIdStr in ipairs(roomIds) do\r\n                    metaInfo.rooms[i] = roomIdStr\r\n                end\r\n            end\r\n        end\r\n    else\r\n        metaInfo.name = deviceName\r\n    end\r\n\r\n    return metaInfo\r\nend\r\n\r\nfunction splitStringToNumbers(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c end)\r\n  return fields\r\nend\r\n\r\nfunction table_contains_value(tab, val)\r\n    if not tab then\r\n        return false\r\n    end\r\n    \r\n    for index, value in ipairs(tab) do\r\n        if value == val then\r\n            return true\r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction getDeviceIdFromTopic(topic)\r\n    local s, e = string.find(topic, \"%d+\")\r\n    --print(topic .. \" | \" .. tostring(s) .. \" | \" .. tostring(e))\r\n    if s then\r\n            return tonumber(string.sub(topic, s, e))\r\n    else\r\n        return 0\r\n    end\r\nend\r\n\r\nfunction createRootTopicName(device)\r\nreturn \"homeassistant/\" .. device.haType .. \"/\" .. device.id\r\n    --return \"homeassistant/\" .. device.haType .. \"/\" .. transliterate(device.roomName) .. \"/\" .. device.id .. \"-\" .. transliterate(device.name)\r\nend\r\n\r\nfunction createGenericEventTopicName(device, eventType, propertyName)\r\n    if (propertyName) then\r\n        return createRootTopicName(device) .. \"/events/\" .. eventType .. \"/\" .. propertyName\r\n    else\r\n        return createRootTopicName(device) .. \"/events/\" .. eventType\r\n    end\r\nend\r\n\r\nfunction createPropertyTopicName(device, propertyName)\r\n    return createGenericEventTopicName(device, \"DevicePropertyUpdatedEvent\", propertyName)     \r\nend\r\n\r\nfunction createCommandTopicName(device, commandName)\r\n    return createRootTopicName(device) .. \"/commands/\" .. \"set\" .. commandName:gsub(\"^%l\", string.upper)\r\nend\r\n\r\nfunction createHaConfigTopicName(device)\r\n    return createRootTopicName(device) .. \"/config\"\r\nend\r\n\r\nfunction createHaJsonAttributesTopicName(device)\r\n    return createRootTopicName(device) .. \"/config_json_attributes\"\r\nend\r\n\r\nfunction createFibaroEventPayload(device, propertyName, newValue) \r\n    -- THIS IS FIBARO EVENT FORMAT => DO NOT CHANGE VARIABLE NAMES\r\n    local payload = {\r\n        data = {\r\n            id = device.id,\r\n            property = propertyName,\r\n            newValue = newValue\r\n        },\r\n        type = \"DevicePropertyUpdatedEvent\",\r\n        created = os.time()\r\n    }\r\n\r\n    return payload\r\nend\r\n\r\nfunction isEmptyString(s)\r\n  return s == nil or s == \"\"\r\nend\r\n\r\nfunction base64Encode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    return ((data:gsub('.', function(x) \r\n        local r,b='',x:byte()\r\n        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\r\n        if (#x < 6) then return '' end\r\n        local c=0\r\n        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\r\n        return b:sub(c+1,c+1)\r\n    end)..({ '', '==', '=' })[#data%3+1])\r\nend\r\n\r\nfunction base64Decode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    data = string.gsub(data, '[^'..b..'=]', '')\r\n    return (data:gsub('.', function(x)\r\n        if (x == '=') then return '' end\r\n        local r,f='',(b:find(x)-1)\r\n        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\r\n        if (#x ~= 8) then return '' end\r\n        local c=0\r\n        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\r\n        return string.char(c)\r\n    end))\r\nend\r\n\r\nfunction decodeBase64Auth(encoded)\r\n    local decoded = base64Decode(encoded)\r\n    \r\n    local i = string.find(decoded, \":\")\r\n\r\n    if i then\r\n        return string.sub(decoded, 0, i-1), string.sub(decoded, i+1, string.len(decoded))\r\n    else\r\n        return nil\r\n    end\r\nend\r\n"}]}