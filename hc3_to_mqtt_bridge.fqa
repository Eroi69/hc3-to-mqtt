{"name":"HC3 <-> MQTT Bridge","type":"com.fibaro.binarySwitch","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_51"},"sections":{"items":[{"components":[{"name":"availableDevices","style":{"weight":"1.2"},"text":"Available devices: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bridgedDevices","style":{"weight":"1.2"},"text":"Bridged devices: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bootTime","style":{"weight":"1.2"},"text":"Boot time: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_51"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"mqttUrl","type":"string","value":"mqtt://<host>:1883"},{"name":"mqttKeepAlive","type":"string","value":"60"},{"name":"mqttUsername","type":"string","value":"your_mqtt_username"},{"name":"mqttPassword","type":"string","value":"your_mqtt_password"},{"name":"mqttConvention","type":"string","value":"home-assistant"},{"name":"developmentMode","type":"string","value":"false"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"function QuickApp:onInit()\n    self:debug(\"-------------------\")\n    self:debug(\"HC3 <-> MQTT BRIDGE\")\n    self:debug(\"Version: 1.0.173\")\n    self:debug(\"-------------------\")\n\n    self:turnOn()  \nend\n\nfunction QuickApp:publish(topic, payload)\n    self.mqtt:publish(topic, tostring(payload), {retain = true})\nend\n\nfunction QuickApp:turnOn() \n    self:establishMqttConnection()\nend\n\nfunction QuickApp:turnOff()\n    self:debug(\"HC3-to-MQTT bridget shutdown sequence initiated\")\n    self:disconnectFromMqttAndHc3()\n    self:updateProperty(\"value\", false)\n    self:debug(\"HC3-to-MQTT bridge shutdown sequence complete\")\nend\n\nfunction QuickApp:establishMqttConnection() \n    self.devices = {}\n\n    -- IDENTIFY WHICH MQTT CONVENTIONS TO BE USED (e.g. Home Assistant, Homio, etc)\n    self.mqttConventions = { }\n    local mqttConventionStr = self:getVariable(\"mqttConvention\")\n    if (isEmptyString(mqttConventionStr)) then\n        self.mqttConventions[0] = MqttConventionHomeAssistant\n    else\n        local arr = splitString(mqttConventionStr, \",\")\n        for i, j in ipairs(arr) do\n            local convention = mqttConventionMappings[j]\n            if (convention) then\n                self.mqttConventions[i] = clone(convention)\n            end\n        end\n    end\n\n    local mqttConnectionParameters = self:getMqttConnectionParameters()\n    self:trace(\"MQTT Connection Parameters: \" .. json.encode(mqttConnectionParameters))\n\n    local mqttClient = mqtt.Client.connect(\n                                    self:getVariable(\"mqttUrl\"),\n                                    mqttConnectionParameters) \n\n    mqttClient:addEventListener('connected', function(event) self:onConnected(event) end)\n    mqttClient:addEventListener('closed', function(event) self:onClosed(event) end)\n    mqttClient:addEventListener('message', function(event) self:onMessage(event) end)\n    mqttClient:addEventListener('error', function(event) self:onError(event) end)    \n    \n    self.mqtt = mqttClient\nend\n\nfunction QuickApp:getMqttConnectionParameters()\n    local mqttConnectionParameters = {\n        -- pickup last will from primary MQTT Convention provider\n        lastWill = self.mqttConventions[1]:getLastWillMessage()\n    }\n\n    -- MQTT CLIENT ID (OPTIONAL)\n    local mqttClientId = self:getVariable(\"mqttClientId\")\n    if (isEmptyString(mqttClientId)) then\n        local autogeneratedMqttClientId = \"HC3-\" .. plugin.mainDeviceId .. \"-\" .. tostring(os.time())\n        self:warning(\"All is good - we have just autogenerated mqttClientId for you \\\"\" .. autogeneratedMqttClientId .. \"\\\"\")\n        mqttConnectionParameters.clientId = autogeneratedMqttClientId\n    else\n        mqttConnectionParameters.clientId = mqttClientId\n    end\n\n    -- MQTT KEEP ALIVE PERIOD\n    local mqttKeepAlivePeriod = self:getVariable(\"mqttKeepAlive\")\n    if (mqttKeepAlivePeriod) then\n        mqttConnectionParameters.keepAlivePeriod = tonumber(mqttKeepAlivePeriod)\n    else\n        mqttConnectionParameters.keepAlivePeriod = 60\n    end\n\n    -- MQTT AUTH (USERNAME/PASSWORD)\n    local mqttUsername = self:getVariable(\"mqttUsername\")\n    local mqttPassword = self:getVariable(\"mqttPassword\")\n\n    if (mqttUsername) then\n        mqttConnectionParameters.username = mqttUsername\n    end\n    if (mqttPassword) then\n        mqttConnectionParameters.password = mqttPassword\n    end\n\n    return mqttConnectionParameters\nend\n\nfunction QuickApp:disconnectFromMqttAndHc3()\n    self.hc3ConnectionEnabled = false\n    self:closeMqttConnection()\n    self:debug(\"Disconnected from MQTT\")\nend\n\nfunction QuickApp:closeMqttConnection()\n    for i, j in ipairs(self.mqttConventions) do\n        if (j.mqtt ~= MqttConventionPrototype.mqtt) then\n            j:onDisconnected()\n        end\n    end\n\n    self.mqtt:disconnect()\nend\n\nfunction QuickApp:onClosed(event)\n    self:updateProperty(\"value\", false)\nend\n\nfunction QuickApp:onError(event)\n    self:error(\"MQTT ERROR: \" .. json.encode(event))\n    if event.code == 2 then\n        self:warning(\"MQTT username and/or password is possibly indicated wrongly\")\n    end\n    self:turnOff()\n    self:scheduleReconnectToMqtt();\nend\n\nfunction QuickApp:scheduleReconnectToMqtt()\n    fibaro.setTimeout(10000, function() \n        self:debug(\"Attempt to reconnect to MQTT...\")\n        self:establishMqttConnection()\n    end)\nend\n\nfunction QuickApp:onMessage(event)\n    for i, j in ipairs(self.mqttConventions) do\n        j:onCommand(event)\n    end\nend\n\nfunction QuickApp:onConnected(event) \n    self:debug(\"MQTT connection established\")\n\n    for _, mqttConvention in ipairs(self.mqttConventions) do\n        mqttConvention.mqtt = self.mqtt\n        mqttConvention.devices = self.devices\n        mqttConvention:onConnected()\n    end\n\n    self:discoverDevicesAndPublishToMqtt()\n\n    self.hc3ConnectionEnabled = true\n    self:scheduleHc3EventsFetcher()\n\n    self:updateProperty(\"value\", true)\nend\n\nfunction QuickApp:identifyAndPublishDeviceToMqtt(fibaroDevice)\n    local bridgedDevice = identifyDevice(fibaroDevice)\n    self:publishDeviceToMqtt(bridgedDevice)\nend\n\nfunction QuickApp:discoverDevicesAndPublishToMqtt()\n    local startTime = os.time()\n\n    local fibaroDevices = self:discoverDevices()\n    \n    self:identifyDevices(fibaroDevices)\n\n    for _, device in pairs(self.devices) do\n        self:publishDeviceToMqtt(device)\n    end\n\n    local diff = os.time() - startTime   \n\n    local bridgedDevices = 0\n    for _, _ in pairs(self.devices) do\n        bridgedDevices = bridgedDevices + 1\n    end\n    \n    self:updateView(\"availableDevices\", \"text\", \"Available devices: \" .. #fibaroDevices)\n    self:updateView(\"bridgedDevices\", \"text\", \"Bridged devices: \" .. bridgedDevices) \n    self:updateView(\"bootTime\" , \"text\", \"Boot time: \" .. diff .. \"s\")\n\n    self:debug(\"\")\n    self:debug(\"----------------------------------\")\n    self:debug(\"Device discovery has been complete\")\n    self:debug(\"----------------------------------\")\n\n    return haDevices\nend\n\nfunction QuickApp:discoverDevices()\n    local fibaroDevices\n\n    local developmentModeStr = self:getVariable(\"developmentMode\")\n    if ((not developmentModeStr) or (developmentModeStr ~= \"true\")) then\n        self:debug(\"Bridge mode: PRODUCTION\")\n\n        local customDeviceFilterJsonStr = self:getVariable(\"deviceFilter\")\n\n        fibaroDevices = getFibaroDevicesByFilter(customDeviceFilterJsonStr)\n    else\n        --smaller number of devices for development and testing purposes\n        self:debug(\"Bridge mode: DEVELOPMENT\")\n\n        fibaroDevices = {\n            --[[\n            getFibaroDeviceById(41), -- switch Onyx light,\n            getFibaroDeviceById(42), -- switch Fan,\n            getFibaroDeviceById(260), -- iPad screen\n            getFibaroDeviceById(287), -- door sensor\n            getFibaroDeviceById(54), -- motion sensor\n            getFibaroDeviceById(92), -- roller shutter\n            getFibaroDeviceById(78), -- dimmer\n            getFibaroDeviceById(66), -- temperature sensor\n            getFibaroDeviceById(56), -- light sensor (lux)\n            getFibaroDeviceById(245), -- volts\n            getFibaroDeviceById(105), -- on/off thermostat from CH\n            getFibaroDeviceById(106), -- temperature sensor\n            getFibaroDeviceById(120), -- IR thermostat from CH\n            getFibaroDeviceById(122), -- temperature sensor\n            getFibaroDeviceById(335), -- on/off thermostat from Qubino\n            getFibaroDeviceById(336), -- temperature sensor \n            getFibaroDeviceById(398), -- temperature sensor  \n            ]]--\n            getFibaroDeviceByInfo(\n                json.decode(\n                    \"{ \\\"id\\\": 968, \\\"name\\\": \\\"LightsHolGaraj\\\", \\\"roomID\\\": 226, \\\"view\\\": [ { \\\"assetsPath\\\": \\\"dynamic-plugins/com.fibaro.multilevelSwitch\\\", \\\"name\\\": \\\"com.fibaro.multilevelSwitch\\\", \\\"translatesPath\\\": \\\"/assets/i18n/com.fibaro.multilevelSwitch\\\", \\\"type\\\": \\\"ts\\\" }, { \\\"assetsPath\\\": \\\"dynamic-plugins/energy\\\", \\\"name\\\": \\\"energy\\\", \\\"translatesPath\\\": \\\"/assets/i18n/energy\\\", \\\"type\\\": \\\"ts\\\" }, { \\\"assetsPath\\\": \\\"\\\", \\\"name\\\": \\\"level-change\\\", \\\"translatesPath\\\": \\\"/assets/i18n/level-change\\\", \\\"type\\\": \\\"ts\\\" }, { \\\"assetsPath\\\": \\\"dynamic-plugins/power\\\", \\\"name\\\": \\\"power\\\", \\\"translatesPath\\\": \\\"/assets/i18n/power\\\", \\\"type\\\": \\\"ts\\\" } ], \\\"type\\\": \\\"com.fibaro.FGD212\\\", \\\"baseType\\\": \\\"com.fibaro.multilevelSwitch\\\", \\\"enabled\\\": true, \\\"visible\\\": true, \\\"isPlugin\\\": false, \\\"parentId\\\": 965, \\\"viewXml\\\": false, \\\"hasUIView\\\": true, \\\"configXml\\\": false, \\\"interfaces\\\": [ \\\"energy\\\", \\\"levelChange\\\", \\\"light\\\", \\\"power\\\", \\\"zwave\\\", \\\"zwaveAlarm\\\", \\\"zwaveMultiChannelAssociation\\\", \\\"zwaveProtection\\\", \\\"zwaveSceneActivation\\\" ], \\\"properties\\\": { \\\"parameters\\\": [ { \\\"id\\\": 1, \\\"lastReportedValue\\\": 1, \\\"lastSetValue\\\": 1, \\\"size\\\": 1, \\\"value\\\": 1 }, { \\\"id\\\": 2, \\\"lastReportedValue\\\": 30, \\\"lastSetValue\\\": 30, \\\"size\\\": 1, \\\"value\\\": 30 }, { \\\"id\\\": 3, \\\"lastReportedValue\\\": 99, \\\"lastSetValue\\\": 99, \\\"size\\\": 1, \\\"value\\\": 99 }, { \\\"id\\\": 4, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 2, \\\"value\\\": 0 }, { \\\"id\\\": 5, \\\"lastReportedValue\\\": 99, \\\"lastSetValue\\\": 99, \\\"size\\\": 1, \\\"value\\\": 99 }, { \\\"id\\\": 6, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 2, \\\"value\\\": 0 }, { \\\"id\\\": 7, \\\"lastReportedValue\\\": 99, \\\"lastSetValue\\\": 99, \\\"size\\\": 1, \\\"value\\\": 99 }, { \\\"id\\\": 8, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 2, \\\"value\\\": 0 }, { \\\"id\\\": 9, \\\"lastReportedValue\\\": 1, \\\"lastSetValue\\\": 1, \\\"size\\\": 1, \\\"value\\\": 1 }, { \\\"id\\\": 10, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 2, \\\"value\\\": 0 }, { \\\"id\\\": 11, \\\"lastReportedValue\\\": 255, \\\"lastSetValue\\\": 255, \\\"size\\\": 2, \\\"value\\\": 255 }, { \\\"id\\\": 13, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 14, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 15, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 16, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 2, \\\"value\\\": 0 }, { \\\"id\\\": 19, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 20, \\\"lastReportedValue\\\": 1, \\\"lastSetValue\\\": 1, \\\"size\\\": 1, \\\"value\\\": 1 }, { \\\"id\\\": 21, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 22, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 23, \\\"lastReportedValue\\\": 1, \\\"lastSetValue\\\": 1, \\\"size\\\": 1, \\\"value\\\": 1 }, { \\\"id\\\": 24, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 25, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 26, \\\"lastReportedValue\\\": 1, \\\"lastSetValue\\\": 1, \\\"size\\\": 1, \\\"value\\\": 1 }, { \\\"id\\\": 27, \\\"lastReportedValue\\\": 15, \\\"lastSetValue\\\": 15, \\\"size\\\": 1, \\\"value\\\": 15 }, { \\\"id\\\": 28, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 29, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 30, \\\"lastReportedValue\\\": 2, \\\"lastSetValue\\\": 2, \\\"size\\\": 1, \\\"value\\\": 2 }, { \\\"id\\\": 31, \\\"lastReportedValue\\\": 1, \\\"lastSetValue\\\": 1, \\\"size\\\": 1, \\\"value\\\": 1 }, { \\\"id\\\": 32, \\\"lastReportedValue\\\": 1, \\\"lastSetValue\\\": 1, \\\"size\\\": 1, \\\"value\\\": 1 }, { \\\"id\\\": 33, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 34, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 35, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 37, \\\"lastReportedValue\\\": 1, \\\"lastSetValue\\\": 1, \\\"size\\\": 1, \\\"value\\\": 1 }, { \\\"id\\\": 39, \\\"lastReportedValue\\\": 250, \\\"lastSetValue\\\": 250, \\\"size\\\": 2, \\\"value\\\": 250 }, { \\\"id\\\": 40, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 41, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 42, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 43, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 44, \\\"lastReportedValue\\\": 600, \\\"lastSetValue\\\": 600, \\\"size\\\": 2, \\\"value\\\": 600 }, { \\\"id\\\": 45, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 46, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 47, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 48, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 49, \\\"lastReportedValue\\\": 1, \\\"lastSetValue\\\": 1, \\\"size\\\": 1, \\\"value\\\": 1 }, { \\\"id\\\": 50, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 52, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 2, \\\"value\\\": 0 }, { \\\"id\\\": 53, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 2, \\\"value\\\": 0 }, { \\\"id\\\": 54, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 58, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 1, \\\"value\\\": 0 }, { \\\"id\\\": 59, \\\"lastReportedValue\\\": 0, \\\"lastSetValue\\\": 0, \\\"size\\\": 2, \\\"value\\\": 0 } ], \\\"pollingTimeSec\\\": 0, \\\"zwaveCompany\\\": \\\"Fibargroup\\\", \\\"zwaveInfo\\\": \\\"3,4,5\\\", \\\"zwaveVersion\\\": \\\"3.5\\\", \\\"RFProtectionState\\\": 0, \\\"RFProtectionSupport\\\": 3, \\\"alarmLevel\\\": 0, \\\"alarmType\\\": 0, \\\"categories\\\": [ \\\"lights\\\" ], \\\"configured\\\": true, \\\"dead\\\": false, \\\"deadReason\\\": \\\"\\\", \\\"deviceControlType\\\": 2, \\\"deviceIcon\\\": 15, \\\"deviceRole\\\": \\\"Light\\\", \\\"emailNotificationID\\\": 0, \\\"emailNotificationType\\\": 0, \\\"endPointId\\\": 1, \\\"energy\\\": 31.16, \\\"icon\\\": { \\\"path\\\": \\\"/assets/icon/fibaro/light/light0.png\\\", \\\"source\\\": \\\"HC\\\" }, \\\"isLight\\\": true, \\\"localProtectionState\\\": 0, \\\"localProtectionSupport\\\": 5, \\\"log\\\": \\\"\\\", \\\"logTemp\\\": \\\"\\\", \\\"manufacturer\\\": \\\"\\\", \\\"markAsDead\\\": true, \\\"model\\\": \\\"\\\", \\\"nodeId\\\": 207, \\\"parametersTemplate\\\": \\\"740\\\", \\\"power\\\": 0, \\\"productInfo\\\": \\\"1,15,1,2,16,0,3,5\\\", \\\"protectionExclusiveControl\\\": 0, \\\"protectionExclusiveControlSupport\\\": false, \\\"protectionState\\\": 0, \\\"protectionTimeout\\\": 0, \\\"protectionTimeoutSupport\\\": false, \\\"pushNotificationID\\\": 0, \\\"pushNotificationType\\\": 0, \\\"saveLogs\\\": true, \\\"saveToEnergyPanel\\\": true, \\\"sceneActivation\\\": 0, \\\"serialNumber\\\": \\\"h'0000000000006c3a\\\", \\\"showEnergy\\\": true, \\\"smsNotificationID\\\": 0, \\\"smsNotificationType\\\": 0, \\\"state\\\": false, \\\"storeEnergyData\\\": true, \\\"supportedDeviceRoles\\\": [ \\\"Light\\\" ], \\\"useTemplate\\\": true, \\\"userDescription\\\": \\\"\\\", \\\"value\\\": 0 }, \\\"actions\\\": { \\\"reconfigure\\\": 0, \\\"reset\\\": 0, \\\"sceneActivationSet\\\": 0, \\\"setValue\\\": 1, \\\"startLevelDecrease\\\": 0, \\\"startLevelIncrease\\\": 0, \\\"stopLevelChange\\\": 0, \\\"toggle\\\": 0, \\\"turnOff\\\": 0, \\\"turnOn\\\": 0 }, \\\"created\\\": 1650490691, \\\"modified\\\": 1663354248, \\\"sortOrder\\\": 17 }\"\n                )\n            ) \n        }\n    end\n\n    return fibaroDevices\nend\n\nfunction QuickApp:identifyDevices(fibaroDevices) \n    for _, fibaroDevice in ipairs(fibaroDevices) do\n        local device = identifyDevice(fibaroDevice)\n        if (device) then\n            self:debug(\"Device \" .. self:getDeviceDescription(device) .. \" identified as \" .. device.bridgeType .. \"-\" .. device.bridgeSubtype)\n            self.devices[device.id] = device\n\n            -- ***** ToDo: move to identifyDevice function, aiming support deviceRemoved and deviceModified and deviceCreated events\n\n            -- Does device support energy monitoring? Create a dedicated sensor for Home Assistant\n            if (table_contains_value(fibaroDevice.interfaces, \"energy\")) then \n                local energyDevice = self:createLinkedSensorDevice(device, \"energy\")\n                self.devices[energyDevice.id] = energyDevice\n            end\n\n            -- Does device support power monitoring? Create a dedicated sensor for Home Assistant\n            if (table_contains_value(fibaroDevice.interfaces, \"power\")) then \n                local powerDevice = self:createLinkedSensorDevice(device, \"power\")\n                self.devices[powerDevice.id] = powerDevice\n            end\n\n            -- Battery powered device? Create a dedicated battery sensor for Home Assistant\n            if (table_contains_value(fibaroDevice.interfaces, \"battery\")) then \n                local batteryLevelSensorDevice = self:createLinkedSensorDevice(device, \"batteryLevel\")\n                self.devices[batteryLevelSensorDevice.id] = batteryLevelSensorDevice\n            end\n\n\n            -- Is it a \"Remote Control\" device? Created dedicated devices for each combination of Button and Press Type\n            if (device.bridgeType == RemoteController.bridgeType and device.bridgeSubtype == RemoteController.bridgeSubtype) then\n                if device.properties.centralSceneSupport then\n                    for _, i in ipairs(device.properties.centralSceneSupport) do\n                        for _, j in ipairs(i.keyAttributes) do\n                            local keyDevice = self:createLinkedKey(device, i.keyId, j)\n                            self.devices[keyDevice.id] = keyDevice \n                        end\n                    end\n                end\n            end\n        else\n            self:debug(\"Couldn't recognize device #\" .. fibaroDevice.id .. \" - \" .. fibaroDevice.name .. \" - \" .. fibaroDevice.baseType .. \" - \" .. fibaroDevice.type)\n        end\n    end\nend\n\nfunction QuickApp:createLinkedDevice(fromDevice, linkedProperty, linkedUnit)\n    local newFibaroLinkedDevice = {\n        id = fromDevice.id .. \"_\" .. linkedProperty,\n        name = fromDevice.name,  \n        roomID = fromDevice.roomID,\n        roomName = fromDevice.roomName,\n        parentId = fromDevice.parentId,\n        linkedDevice = fromDevice,\n        linkedProperty = linkedProperty,\n        properties = {\n            unit = linkedUnit\n        },\n        comment = \"This device has been autogenerated by HC3 <-> Home Assistant bridge to adjust the data model difference between Fibaro HC3 and Home Assistant. Fibaro considers this device and the '\" .. linkedProperty .. \"' meter to be the single entity. And Home Asisstant requires these to be separate devices\"\n    }\n\n    return newFibaroLinkedDevice\nend\n\nfunction QuickApp:createLinkedSensorDevice(fromDevice, linkedProperty)\n    local linkedUnit\n    if (linkedProperty == \"energy\") then\n        linkedUnit = \"kWh\"\n        -- lastReset = \"1970-01-03T00:00:00+00:00\"\n    elseif (linkedProperty == \"power\") then\n        linkedUnit = \"W\"\n    end\n\n    local newFibaroLinkedSensor = self:createLinkedDevice(fromDevice, linkedProperty, linkedUnit)\n    newFibaroLinkedSensor.baseType = \"com.fibaro.multilevelSensor\"\n    newFibaroLinkedSensor.type = \"com.fibaro.\" .. linkedProperty .. \"Sensor\"\n\n    local newLinkedSensor = identifyDevice(newFibaroLinkedSensor)\n    newLinkedSensor.fibaroDevice.linkedDevice = nil\n\n    return newLinkedSensor\nend\n\nfunction QuickApp:createLinkedKey(fromDevice, keyId, keyAttribute)\n    local keyAttribute = string.lower(keyAttribute)\n\n    local action = keyId .. \"-\" .. keyAttribute\n\n    local newFibaroKey = self:createLinkedDevice(fromDevice, \"value\", nil)\n    newFibaroKey.baseType = \"com.alexander_vitishchenko.remoteKey\"\n    newFibaroKey.keyId = keyId\n    newFibaroKey.keyAttribute = keyAttribute\n\n    local newHaKey = identifyDevice(newFibaroKey)\n    newHaKey.fibaroDevice.linkedDevice = nil\n    \n    return newHaKey\nend\n\n\nfunction QuickApp:publishDeviceToMqtt(device)\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE EXISTANCE\n    ------------------------------------------------------------------\n    for i, j in ipairs(self.mqttConventions) do\n        j:onDeviceCreated(device)\n    end\n\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE CURRENT STATE => BY SIMULATING HC3 EVENTS\n    ------------------------------------------------------------------\n    self:simulatePropertyUpdate(device, \"dead\", device.properties.dead)\n    self:simulatePropertyUpdate(device, \"state\", device.properties.state)\n    self:simulatePropertyUpdate(device, \"value\", device.properties.value)\n    self:simulatePropertyUpdate(device, \"heatingThermostatSetpoint\", device.properties.heatingThermostatSetpoint)\n    self:simulatePropertyUpdate(device, \"thermostatMode\", device.properties.thermostatMode)\n    self:simulatePropertyUpdate(device, \"energy\", device.properties.energy)\n    self:simulatePropertyUpdate(device, \"power\", device.properties.power)\n    self:simulatePropertyUpdate(device, \"batteryLevel\", device.properties.batteryLevel)\n    self:simulatePropertyUpdate(device, \"color\", device.properties.color)\nend\n\nfunction QuickApp:onPublished(event)\n    -- do nothing, for now\nend\n\n-- FETCH HC3 EVENTS\nlocal lastRefresh = 0\nlocal http = net.HTTPClient()\n\nfunction QuickApp:scheduleHc3EventsFetcher()\n    self:readHc3EventAndScheduleFetcher()\n\n    self:debug(\"\")\n    self:debug(\"---------------------------------------------------\")\n    self:debug(\"Started monitoring events from Fibaro Home Center 3\")\n    self:debug(\"---------------------------------------------------\")\nend\n\nfunction QuickApp:readHc3EventAndScheduleFetcher()\n    -- This a reliable and high-performance method to get events from Fibaro HC3, by using non-blocking HTTP calls. Where 'passwordles' api.get() has a risk of blocking calls => peformance isues\n\n    local requestUrl = \"http://127.0.0.1:11111/api/refreshStates?last=\" .. lastRefresh\n    --self:debug(\"Fetch events from \" .. requestUrl .. \" | \" .. tostring(self.hc3ConnectionEnabled))\n\n    local stat, res = http:request(\n        requestUrl,\n        {\n        options = { },\n        success=function(res)\n            local data\n            if (res and not isEmptyString(res.data)) then\n                self:processFibaroHc3Events(json.decode(res.data))\n            else\n                self:error(\"Error while fetching events from Fibaro HC3. Response status code is \" .. res.status .. \". HTTP response body is '\" .. json.encode(res) .. \"'\")\n                self:turnOff()\n            end\n        end,\n        error=function(res) \n            self:error(\"Error while fetching Fibaro HC3 events \" .. json.encode(res))\n            self:turnOff()\n        end\n    })\n\n    if (self.hc3ConnectionEnabled) then\n        local delay\n        if self.gotError then\n            self:warning(\"Got error - retry in 1s\")\n            delay = 1000\n        else\n            delay = 1000\n        end\n\n        fibaro.setTimeout(delay, function()\n            self:readHc3EventAndScheduleFetcher()\n        end)\n    else\n        self:debug(\"Disconnected from HC3 (got flagged to stop reading HC3 events)\")\n    end\n\nend\n\nfunction QuickApp:processFibaroHc3Events(data)\n    -- Debug for \"paswordless\" mode. Doesn't work well for now due to blocking api-calls. Significantly reducing performance\n\n    if not self.hc3ConnectionEnabled then\n        return\n    end\n\n    self.gotError = false\n    if (data.status ~= 200 and data.status ~= \"IDLE\") then\n        self:warning(\"Unexpected response status \" .. tostring(data.status))\n        -- Disable automated turnOff after unexpected response status\n        -- Make QuickApp less sensetive, so QuickApp doesn't get shutdown when it is possible to continue its operation\n        -- self:turnOff()\n    end\n\n    local events = data.events\n\n    if (data.last) then\n        lastRefresh = data.last\n    end\n\n    if events and #events>0 then \n        for i, v in ipairs(events) do\n            self:dispatchFibaroEventToMqtt(v)\n        end\n    end\nend\n\nfunction QuickApp:simulatePropertyUpdate(device, propertyName, value)\n    if value ~= nil then\n        local event = createFibaroEventPayload(device, propertyName, value)\n        event.simulation = true\n        self:dispatchFibaroEventToMqtt(event)\n    end\nend\n\nfunction QuickApp:dispatchFibaroEventToMqtt(event)\n    --self:debug(\"Event: \" .. json.encode(event))\n    if (not event) then\n        self:error(\"No event found\")\n        return\n    end\n\n    if (not event.data) then\n        self:error(\"No event data found\")\n        return\n    end\n\n    local deviceId = event.data.id or event.data.deviceId\n\n    if not deviceId then\n        -- This is a system level event, which is not bound to a particular device => ignore\n        -- self:trace(\"Unsupported system event (feel free to reach out to QuickApp developer if you need it): \" .. json.encode(event))\n        return\n    end \n\n    if (not event.type) then\n        event.type = \"unknown\"\n    end\n\n    local device = self.devices[deviceId]\n\n    if (device) then\n        if (event.type == \"DevicePropertyUpdatedEvent\") then\n            self:dispatchDevicePropertyUpdatedEvent(device, event) \n        elseif (event.type == \"CentralSceneEvent\") then\n            -- fabricate property updated event, instead of \"CentralSceneEvent\", so we reuse the existing value dispatch mechanism rather than reinventing a wheel\n            local keyValueMapAsString = event.data.keyId .. \",\" .. string.lower(event.data.keyAttribute)\n            self:trace(\"Action => \" .. event.data.keyId .. \"-\" .. string.lower(event.data.keyAttribute))\n            self:simulatePropertyUpdate(device, \"value\", keyValueMapAsString)\n        elseif (event.type == \"DeviceModifiedEvent\") then\n            self:dispatchDeviceModifiedEvent(device)\n        elseif (event.type == \"DeviceCreatedEvent\") then\n            self:dispatchDeviceCreatedEvent(device)\n        elseif (event.type == \"DeviceRemovedEvent\") then \n            self:dispatchDeviceRemovedEvent(device)\n        elseif (event.type == \"DeviceActionRanEvent\") then\n        else\n            local eventType = tostring(event.type)\n            if (eventType == \"PluginChangedViewEvent\") then\n                -- exclude the event type from Debug view, as it's not intended for translation to Home Assistant world, and thus no need to confuse QuickApp users\n            else\n                self:debug(\"Unsupported event type \\\"\" .. eventType .. \"\\\" for \\\"\" .. self:getDeviceDescription(device) .. \"\\\". All is good - feel free raise a request, and it could be possibly implemented in a future - https://github.com/alexander-vitishchenko/hc3-to-mqtt/issues/new\")\n                self:debug(json.encode(event))\n            end\n        end\n\n    end\nend\n\nfunction QuickApp:dispatchDevicePropertyUpdatedEvent(device, event)\n    -- *** OVERRIDE FIBARO PROPERTY NAMES, FOR BEING MORE CONSISTENT AND THUS EASIER TO HANDLE \n    local propertyName = event.data.property\n    if not propertyName then\n        propertyName = \"unknown\"\n    end\n\n    if (device.bridgeType == \"binary_sensor\") and (propertyName == \"value\") then\n        -- Fibaro uses state/value fields inconsistently for binary sensor. Replace value --> state field\n        event.data.property = \"state\"\n    end\n\n    local value = event.data.newValue\n    if (isNumber(value)) then\n        value = round(value, 2)\n    end\n\n    event.data.newValue = (type(value) == \"number\" and value or tostring(value))\n    \n    for i, j in ipairs(self.mqttConventions) do\n        j:onPropertyUpdated(device, event)\n    end\nend\n\nfunction QuickApp:rememberLastMqttCommandTime(deviceId)\n    self.lastMqttCommandTime[deviceId] = os.time()\nend\n\nfunction QuickApp:dispatchDeviceCreatedEvent(device)\n    local fibaroDevice = getFibaroDeviceById(device.id)\n\n    if (fibaroDevice.visible and fibaroDevice.enabled) then\n        self:debug(\"New device configuration \" .. json.encode(fibaroDevice))\n        self:identifyAndPublishDeviceToMqtt(fibaroDevice)\n    end\nend\n\nfunction QuickApp:dispatchDeviceModifiedEvent(device)\n    self:debug(\"Device modified \" .. device.id)\n\n    self:dispatchDeviceRemovedEvent(device)\n\n    self:dispatchDeviceCreatedEvent(device)\nend\n\nfunction QuickApp:dispatchDeviceRemovedEvent(device)\n    self:debug(\"Device removed \" .. device.id)\n    for i, j in ipairs(self.mqttConventions) do\n        j:onDeviceRemoved(device)\n    end\n    --self:removeDeviceFromMqtt(device)\nend\n\nfunction QuickApp:getDeviceDescription(device)\n    if device and device.name and device.id and device.roomName then\n        return device.name .. \" #\" .. device.id .. \" (\" .. tostring(device.roomName) .. \")\"\n    else\n        if device.id then\n            return device.id\n        else\n            return \"<unknown device>\"\n        end\n    end\nend\n"},{"name":"tools","isMain":false,"isOpen":true,"content":"local alphabet = {\r\n    [\"А\"] = \"A\",\r\n    [\"Б\"] = \"B\",\r\n    [\"В\"] = \"V\",\r\n    [\"Г\"] = \"G\",\r\n    [\"Д\"] = \"D\",\r\n    [\"Е\"] = \"E\",\r\n    [\"Ж\"] = \"Zh\",\r\n    [\"З\"] = \"Z\",\r\n    [\"И\"] = \"I\",\r\n    [\"І\"] = \"I\",\r\n    [\"Ї\"] = \"I\",\r\n    [\"Й\"] = \"I\",\r\n    [\"К\"] = \"K\",\r\n    [\"Л\"] = \"L\",\r\n    [\"М\"] = \"M\",\r\n    [\"Н\"] = \"N\",\r\n    [\"О\"] = \"O\",\r\n    [\"П\"] = \"P\",\r\n    [\"Р\"] = \"R\",\r\n    [\"С\"] = \"S\",\r\n    [\"Т\"] = \"T\",\r\n    [\"У\"] = \"U\",\r\n    [\"Ф\"] = \"F\",\r\n    [\"Х\"] = \"H\",\r\n    [\"Ч\"] = \"Ch\",\r\n    [\"Ц\"] = \"C\",\r\n    [\"Ш\"] = \"Sh\",\r\n    [\"Щ\"] = \"Shch\",\r\n    [\"И\"] = \"I\",\r\n    [\"Є\"] = \"E\",\r\n    [\"Э\"] = \"E\",\r\n    [\"Ю\"] = \"Ju\",\r\n    [\"Я\"] = \"Ja\",\r\n    [\"а\"] = \"a\",\r\n    [\"б\"] = \"b\",\r\n    [\"в\"] = \"v\",\r\n    [\"г\"] = \"g\",\r\n    [\"д\"] = \"d\",\r\n    [\"е\"] = \"e\",\r\n    [\"~\"] = \"e\",\r\n    [\"ж\"] = \"zh\",\r\n    [\"з\"] = \"z\",\r\n    [\"и\"] = \"i\",\r\n    [\"і\"] = \"i\",\r\n    [\"ї\"] = \"i\",\r\n    [\"й\"] = \"i\",\r\n    [\"к\"] = \"k\",\r\n    [\"л\"] = \"l\",\r\n    [\"м\"] = \"m\",\r\n    [\"н\"] = \"n\",\r\n    [\"о\"] = \"o\",\r\n    [\"п\"] = \"p\",\r\n    [\"р\"] = \"r\",\r\n    [\"с\"] = \"s\",\r\n    [\"т\"] = \"t\",\r\n    [\"у\"] = \"u\",\r\n    [\"ф\"] = \"f\",\r\n    [\"х\"] = \"h\",\r\n    [\"ч\"] = \"ch\",\r\n    [\"ц\"] = \"c\",\r\n    [\"ш\"] = \"sh\",\r\n    [\"щ\"] = \"shch\",\r\n    [\"ы\"] = \"i\",\r\n    [\"ь\"] = \"'\",\r\n    [\"є\"] = \"e\",\r\n    [\"э\"] = \"e\",\r\n    [\"ю\"] = \"ju\",\r\n    [\"я\"] = \"ja\"\r\n}\r\n\r\nfunction transliterate(input)\r\n    if (not input) then\r\n        return \"unknown_input_for_transliteration\"\r\n    end\r\n\r\n    local output = {}\r\n    local i = 1\r\n\r\n    for p, c in utf8.codes(input) do  \r\n        local char = utf8.char(c)\r\n        local outputCharacter = alphabet[char]\r\n\r\n        if not outputCharacter then\r\n        if (string.find(char, \"%a\") or string.find(char, \"%d\")) then\r\n            outputCharacter = char\r\n        else\r\n            outputCharacter = \"-\"\r\n        end\r\n\r\n        end\r\n        output[i] = outputCharacter\r\n        i = i + 1\r\n    end\r\n\r\n    --print(\"RESULT \" .. table.concat(output) ) \r\n\r\n    return table.concat(output) \r\nend\r\n\r\nfunction extractMetaInfoFromDeviceName(deviceName)\r\n    local metaInfo = {\r\n        pureName = deviceName,\r\n        autoPower = true,\r\n        turnOffTimeout = 10 * 60,\r\n        segmentId = -1,\r\n    }\r\n    \r\n    local s, e = string.find(deviceName, \"%[.+%]\")\r\n    if s and e then\r\n        local pureName = string.gsub(string.sub(deviceName, 1, s-1), \"%s+$\", \"\")\r\n        local metaStr = string.sub(deviceName, s+1, e-1)\r\n\r\n        metaInfo.pureName = pureName\r\n \r\n        local attrs = splitStringToNumbers(metaStr, \"%.\")\r\n        if attrs[1] == \"1\" then\r\n            metaInfo.autoPower = true\r\n        else\r\n            metaInfo.autoPower = false\r\n        end\r\n\r\n        if attrs[2] and attrs[2] ~= \"-\" then \r\n            metaInfo.turnOffTimeout = math.ceil(attrs[2] * 60)\r\n        end\r\n\r\n        if attrs[3] and attrs[3] ~= \"-\" then \r\n            metaInfo.segmentId = tonumber(attrs[3])\r\n            metaInfo.rooms = {}\r\n\r\n            local segmentIdsStr = fibaro.getGlobalVariable(\"segment_\" .. metaInfo.segmentId)\r\n            if segmentIdsStr then\r\n                local roomIds = splitStringToNumbers(segmentIdsStr, \",\")\r\n                for i,roomIdStr in ipairs(roomIds) do\r\n                    metaInfo.rooms[i] = roomIdStr\r\n                end\r\n            end\r\n        end\r\n    else\r\n        metaInfo.name = deviceName\r\n    end\r\n\r\n    return metaInfo\r\nend\r\n\r\nfunction splitString(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c:gsub(\"^%s*(.-)%s*$\", \"%1\") end)\r\n  return fields\r\nend\r\n\r\n\r\nfunction splitStringToNumbers(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c end)\r\n  return fields\r\nend\r\n\r\nfunction table_contains_value(tab, val)\r\n    if not tab then\r\n        return false\r\n    end\r\n    \r\n    for index, value in ipairs(tab) do\r\n        if value == val then\r\n            return true\r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction createFibaroEventPayload(device, propertyName, newValue) \r\n    -- THIS IS FIBARO EVENT FORMAT => DO NOT CHANGE VARIABLE NAMES\r\n    local payload = {\r\n        data = {\r\n            id = device.id,\r\n            property = propertyName,\r\n            newValue = newValue\r\n        },\r\n        type = \"DevicePropertyUpdatedEvent\",\r\n        created = os.time()\r\n    }\r\n\r\n    return payload\r\nend\r\n\r\nfunction isEmptyString(s)\r\n  return s == nil or s == \"\"\r\nend\r\n\r\nfunction base64Encode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    return ((data:gsub('.', function(x) \r\n        local r,b='',x:byte()\r\n        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\r\n        if (#x < 6) then return '' end\r\n        local c=0\r\n        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\r\n        return b:sub(c+1,c+1)\r\n    end)..({ '', '==', '=' })[#data%3+1])\r\nend\r\n\r\nfunction base64Decode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    data = string.gsub(data, '[^'..b..'=]', '')\r\n    return (data:gsub('.', function(x)\r\n        if (x == '=') then return '' end\r\n        local r,f='',(b:find(x)-1)\r\n        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\r\n        if (#x ~= 8) then return '' end\r\n        local c=0\r\n        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\r\n        return string.char(c)\r\n    end))\r\nend\r\n\r\nfunction decodeBase64Auth(encoded)\r\n    local decoded = base64Decode(encoded)\r\n    \r\n    local i = string.find(decoded, \":\")\r\n\r\n    if i then\r\n        return string.sub(decoded, 0, i-1), string.sub(decoded, i+1, string.len(decoded))\r\n    else\r\n        return nil\r\n    end\r\nend\r\n\r\nfunction shallowInsertTo(from, to)\r\n    local orig_type = type(from)\r\n    if orig_type == 'table' then\r\n        for orig_key, orig_value in pairs(from) do\r\n            table.insert(to, orig_value)\r\n        end\r\n    else -- number, string, boolean, etc\r\n        copy = from\r\n    end\r\nend\r\n\r\nfunction shallowCopyTo(from, to)\r\n    local orig_type = type(from)\r\n    if orig_type == 'table' then\r\n        for orig_key, orig_value in pairs(from) do\r\n            to[orig_key] = orig_value\r\n        end\r\n    else -- number, string, boolean, etc\r\n        copy = from\r\n    end\r\nend\r\n\r\n\r\nfunction clone(orig)\r\n    local orig_type = type(orig)\r\n    local copy\r\n    if orig_type == 'table' then\r\n        copy = {}\r\n        for orig_key, orig_value in next, orig, nil do\r\n            copy[clone(orig_key)] = clone(orig_value)\r\n        end\r\n        --setmetatable(copy, clone(getmetatable(orig)))\r\n    else -- number, string, boolean, etc\r\n        copy = orig\r\n    end\r\n    return copy\r\nend\r\n\r\nfunction inheritFrom(orig)\r\n    return clone(orig)\r\nend\r\n\r\nfunction isNumber(value)\r\n    if type(value) == \"number\" then return true end\r\n\r\n    if value == tostring(tonumber(value)) then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\nfunction round(number, dec)\r\n    local k = 10^dec\r\n\r\n    local result = math.floor(number * k + 0.5) / k\r\n\r\n    local resultWithoutTrailingZero = math.floor(result)\r\n    if (resultWithoutTrailingZero ~= result) then\r\n        return result\r\n    else\r\n        return resultWithoutTrailingZero\r\n    end\r\n\r\n    return result\r\nend\r\n"},{"name":"mqtt_convention_api","isMain":false,"isOpen":true,"content":"MqttConventionPrototype = {\r\n    type = \"'type' needs to be overriden\", \r\n    mqtt = \"MQTT connection must be established first\"\r\n}\r\n \r\nfunction MqttConventionPrototype:getLastWillMessage() \r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onConnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceCreated(device)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceRemoved(device)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onPropertyUpdated(device, event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onCommand(event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDisconnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\n-----------------------------------\r\n-- HOME ASSISTANT \r\n-----------------------------------\r\nMqttConventionHomeAssistant = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomeAssistant.type = \"Home Assistant\"\r\nMqttConventionHomeAssistant.rootTopic = \"homeassistant/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomeAssistant:getDeviceTopic(device)\r\n    return self.rootTopic .. device.bridgeType .. \"/\" .. device.id .. \"/\"\r\nend\r\nfunction MqttConventionHomeAssistant:getGenericEventTopic(device, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomeAssistant:getterTopic(device, propertyName)\r\n    if (device.linkedDevice and propertyName == \"value\") then\r\n        local result = self:getGenericEventTopic(device.linkedDevice, \"DevicePropertyUpdatedEvent\", device.linkedProperty)\r\n\r\n        return result\r\n    elseif (device.linkedDevice and propertyName == \"dead\") then\r\n        local result = self:getGenericEventTopic(device.linkedDevice, \"DevicePropertyUpdatedEvent\", \"dead\")\r\n\r\n        return result\r\n    else\r\n        return self:getGenericEventTopic(device, \"DevicePropertyUpdatedEvent\", propertyName)\r\n    end\r\nend\r\nfunction MqttConventionHomeAssistant:getGenericCommandTopic(device, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(device) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:setterTopic(device, propertyName)\r\n    return self:getGenericCommandTopic(device, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getLastWillAvailabilityTopic()\r\n    return self.rootTopic .. \"hc3-dead\"\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getLastWillMessage()\r\n    return {\r\n        topic = self:getLastWillAvailabilityTopic(),\r\n        payload = \"true\"\r\n    }    \r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onConnected()\r\n    self.mqtt:publish(self.rootTopic .. \"hc3-dead\", \"false\", {retain = true})\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/set/+\")\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDisconnected()\r\n    self.mqtt:publish(self.rootTopic .. \"hc3-dead\", \"true\", {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceCreated(device)\r\n    if (device.bridgeType == RemoteControllerKey.bridgeType) then\r\n        -- Home Assistant pretty unique spec for \"device_automation/trigger\" devices\r\n        -- so better use another factory type for MQTT Discovery Message\r\n        MqttConventionHomeAssistant:onRemoteControllerKeyCreated(device, self.mqtt)\r\n        return\r\n    end\r\n\r\n    ------------------------------------------\r\n    --- AVAILABILITY\r\n    ------------------------------------------\r\n    local msg = {\r\n        unique_id = tostring(device.id),\r\n        name = device.name .. \" (\" .. device.roomName .. \")\",\r\n\r\n        availability_mode = \"all\",\r\n        availability = {\r\n            {\r\n                topic = self:getLastWillAvailabilityTopic(),\r\n                payload_available = \"false\",\r\n                payload_not_available = \"true\"\r\n            }\r\n            ,\r\n            {\r\n                topic = self:getterTopic(device, \"dead\"),\r\n                payload_available = \"false\",\r\n                payload_not_available = \"true\" \r\n            }\r\n        },\r\n\r\n        json_attributes_topic = self:getDeviceTopic(device) .. \"config_json_attributes\" \r\n    }\r\n\r\n    ------------------------------------------\r\n    --- PARENT DEVICE INFO\r\n    ------------------------------------------\r\n    self:enrichMessageWithParentDeviceInfo(device, msg)\r\n\r\n    ------------------------------------------\r\n    --- USE \"TRUE\"/\"FALSE\" VALUE PAYLOAD, instead of \"ON\"/\"OFF\"\r\n    ------------------------------------------\r\n    if (device.bridgeRead) then\r\n        if (device.bridgeBinary and device.bridgeType ~= \"cover\") then \r\n            msg.payload_on = \"true\"\r\n            msg.payload_off = \"false\"\r\n        end\r\n    end\r\n    \r\n    ------------------------------------------\r\n    ---- READ\r\n    ------------------------------------------\r\n    -- Does device have binary state to share?\r\n    if (device.bridgeRead and device.bridgeBinary) then\r\n        msg.state_topic = self:getterTopic(device, \"state\")\r\n        \r\n        if (device.bridgeType == \"light\") then\r\n            msg.state_value_template = \"{{ value_json.value }}\"\r\n        else\r\n            -- wish Home Assistant spec was consistent for all device types and \"state_value_template\" was used for all the devices with \"state\" property\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        end\r\n    end\r\n    -- Does device have multilevel state to share?\r\n    if (device.bridgeRead and device.bridgeMultilevel) then\r\n        if (device.bridgeType == \"light\") then\r\n            msg.brightness_state_topic = self:getterTopic(device, \"value\")\r\n            msg.brightness_value_template = \"{{ value_json.value }}\"\r\n        elseif (device.bridgeType == \"cover\") then\r\n            msg.position_topic = self:getterTopic(device, \"value\")\r\n        elseif (device.bridgeType == \"sensor\") then\r\n            msg.state_topic = self:getterTopic(device, \"value\")\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        else\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- WRITE\r\n    ------------------------------------------\r\n    -- Does device support binary write operations?\r\n    if (device.bridgeWrite and device.bridgeBinary) then\r\n        msg.command_topic = self:setterTopic(device, \"state\")\r\n    end\r\n    -- Does device support multilevel write operations?\r\n    if (device.bridgeWrite) and (device.bridgeMultilevel) then\r\n        if (device.bridgeType == \"light\") then\r\n            msg.brightness_command_topic = self:setterTopic(device, \"value\")\r\n            msg.brightness_scale = 99\r\n            msg.on_command_type = \"first\"\r\n        elseif (device.bridgeType == \"cover\") then\r\n            msg.set_position_topic = self:setterTopic(device, \"value\")\r\n            msg.position_template = \"{{ value_json.value }}\"\r\n            -- value_template is deprecated since Home Assistant Core 2021.6.\r\n            msg.value_template = nil\r\n            msg.position_open = 99\r\n            msg.position_closed = 0\r\n\r\n            msg.payload_open = \"open\"\r\n            msg.payload_close = \"close\"\r\n            msg.payload_stop = \"stop\"\r\n\r\n            msg.state_open = \"open\"\r\n            msg.state_closed = \"closed\"\r\n            msg.state_opening = \"opening\"\r\n            msg.state_closing = \"closing\"\r\n            msg.state_topic = self:setterTopic(device, \"state\")\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- SENSOR SPECIFIC\r\n    ------------------------------------------\r\n    if (device.bridgeType == \"binary_sensor\" or device.bridgeType == \"sensor\") then\r\n        if (PrototypeDevice.bridgeSubtype ~= device.bridgeSubtype) then\r\n            msg.device_class = device.bridgeSubtype\r\n        end\r\n        if (PrototypeDevice.bridgeUnitOfMeasurement ~= device.bridgeUnitOfMeasurement) then\r\n            msg.unit_of_measurement = device.bridgeUnitOfMeasurement\r\n        end\r\n\r\n        -- Energy meter requires extra properties\r\n        if (device.bridgeSubtype == \"energy\") then\r\n            msg.state_class = \"total_increasing\"\r\n        end\r\n\r\n        if (device.bridgeSubtype == RemoteController.bridgeSubtype) then\r\n            -- Remote controller sensor is not natively supported by Home Assistant, thus need to replace \"remoteController\" subtype with \"None\" device class\r\n            msg.device_class = nil\r\n            -- Add \"remote\" icon\r\n            msg.icon = \"mdi:remote\"\r\n        end\r\n\r\n        if (device.bridgeType == RemoteController.bridgeType) and (device.bridgeSubtype == RemoteController.bridgeSubtype) then\r\n            -- *** TBD - consider removing auto expiration\r\n            msg.expire_after = 10\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- THERMOSTAT SPECIFIC\r\n    ------------------------------------------\r\n    if (device.bridgeType == \"climate\") then\r\n        msg.modes = device.properties.supportedThermostatModes\r\n \r\n        msg.temperature_unit = device.properties.unit\r\n        msg.temp_step = device.properties.heatingThermostatSetpointStep[msg.temperature_unit]\r\n\r\n        -- MODE \r\n        msg.mode_state_topic = self:getterTopic(device, \"thermostatMode\")\r\n        msg.mode_command_topic = self:setterTopic(device, \"thermostatMode\")\r\n\r\n        -- MIX/MAX TEMPERATURE\r\n        msg.min_temp = device.properties.heatingThermostatSetpointCapabilitiesMin\r\n        msg.max_temp = device.properties.heatingThermostatSetpointCapabilitiesMax\r\n\r\n        -- TARGET TEMPERATURE\r\n        msg.temperature_state_topic = self:getterTopic(device, \"heatingThermostatSetpoint\")\r\n        msg.temperature_command_topic = self:setterTopic(device, \"heatingThermostatSetpoint\")\r\n        \r\n        -- CURRENT TEMPERATURE\r\n        local temperatureSensorDevice = device:getTemperatureSensor(self.devices)\r\n        if temperatureSensorDevice then \r\n            msg.current_temperature_topic = self:getterTopic(temperatureSensorDevice, \"value\")\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- RGBW\r\n    ------------------------------------------\r\n    if (device.bridgeType == \"light\" and device.bridgeSubtype == \"rgbw\") then\r\n        msg.rgbw_state_topic = self:getterTopic(device, \"color\")\r\n        msg.rgbw_value_template = \"{{ value_json.value.split(',')[:4] | join(',') }}\"\r\n        msg.rgbw_command_topic = self:setterTopic(device, \"color\")\r\n    end\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"config\", json.encode(msg), {retain = true})\r\n    \r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"config_json_attributes\", json.encode(device.fibaroDevice), {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onRemoteControllerKeyCreated(device, mqtt)\r\n    local keyId = device.keyId\r\n    local keyType = self:convertKeyAttributeToType(device.keyAttribute)\r\n    \r\n    local msg = {\r\n        automation_type = \"trigger\",\r\n\r\n        topic = self:getterTopic(device, \"value\"),\r\n        value_template = \"{{ value_json.value }}\", \r\n\r\n        type = keyType, \r\n        subtype = \"button_\" .. keyId,\r\n        payload = keyId .. \"-\" .. keyType\r\n    }\r\n\r\n    ------------------------------------------\r\n    --- PARENT DEVICE INFO\r\n    ------------------------------------------\r\n    self:enrichMessageWithParentDeviceInfo(device, msg)\r\n\r\n    mqtt:publish(self:getDeviceTopic(device) .. \"config\", json.encode(msg), {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:enrichMessageWithParentDeviceInfo(device, msg)\r\n    local parentDevice = device.bridgeParent\r\n    if parentDevice then\r\n        msg.device = {\r\n            identifiers = \"hc3-\" .. parentDevice.id,\r\n            name = parentDevice.name,\r\n            manufacturer = parentDevice.properties.zwaveCompany,\r\n            model = parentDevice.properties.model, \r\n            -- zwave version is used instead of device software version\r\n            sw_version = parentDevice.properties.zwaveVersion\r\n        }\r\n    end\r\nend\r\n\r\nlocal keyAttributeToTypeMap = {\r\n    [\"pressed\"] = \"button_short_press\",\r\n    [\"pressed2\"] = \"button_double_press\",\r\n    [\"pressed3\"] = \"button_triple_press\",\r\n    [\"helddown\"] = \"button_long_press\",\r\n    [\"released\"] = \"button_long_release\"\r\n}\r\nfunction MqttConventionHomeAssistant:convertKeyAttributeToType(keyAttribute)\r\n    local type = keyAttributeToTypeMap[keyAttribute]\r\n    if not type then\r\n        print(\"Unknown key attribute \\\"\" .. keyAttribute .. \"\\\"\")\r\n        type = \"unknown-\" .. keyAttribute\r\n    end\r\n    \r\n    return type\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceRemoved(device)\r\n    self.mqtt:publish(\r\n        self:getDeviceTopic(device) .. \"config\", \r\n        \"\",\r\n        {retain = true} \r\n    )\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onPropertyUpdated(device, event)\r\n    local propertyName = event.data.property\r\n\r\n    local value = event.data.newValue\r\n\r\n    -------------------------------------------\r\n    -- COVER SPECIFIC\r\n    -------------------------------------------\r\n    if device.bridgeType == \"cover\" then \r\n        if propertyName == \"value\" then\r\n            -- Fibaro doesn't use \"state\" attribute for covers, so we'll trigger it on behalf of Fibaro based on \"value\" attribute\r\n            local state\r\n            if value < 20 then\r\n                state = \"closed\"\r\n            elseif value > 80 then\r\n                state = \"open\"\r\n            else\r\n                state = \"unknown\"\r\n            end\r\n\r\n            if state then\r\n                local payload = {\r\n                    id = device.id,\r\n                    deviceName = device.name,\r\n                    created = event.created,\r\n                    timestamp = os.date(),\r\n                    roomName = device.roomName,\r\n                    value = state\r\n                }\r\n                formattedState = json.encode(payload)\r\n                --formattedState = state\r\n                self.mqtt:publish(self:getterTopic(device, \"state\"), formattedState, {retain = true})\r\n            end\r\n        elseif propertyName == \"state\" then\r\n            if (value == \"unknown\") then\r\n                -- drop event as Fibaro has \"Uknnown\" value constantly assigned to the \"state\" attribute \r\n                return\r\n            end\r\n        end\r\n    end\r\n\r\n    -------------------------------------------\r\n    -- REMOTE CONTROLLER (SENSOR) SPECIFIC\r\n    -------------------------------------------\r\n    if device.bridgeType == RemoteController.bridgeType and device.bridgeSubtype == RemoteController.bridgeSubtype and propertyName == \"value\" then\r\n        local keyValues = splitString(value, \",\")\r\n\r\n        local keyId = keyValues[1]\r\n        local keyAttribute = keyValues[2]\r\n        local keyType = self:convertKeyAttributeToType(keyAttribute)\r\n        \r\n        value = keyId .. \"-\" .. keyType\r\n    end\r\n    \r\n    value = string.lower(value)\r\n\r\n    local formattedPayload \r\n    if propertyName == \"dead\" then\r\n    -- ***\r\n    --if ((propertyName == \"dead\") or (device.bridgeType == RemoteController.bridgeType and device.bridgeSubtype == RemoteController.bridgeSubtype)) then\r\n        formattedPayload = tostring(value)\r\n    else\r\n        local payload = {\r\n            id = device.id,\r\n            deviceName = device.name,\r\n            created = event.created,\r\n            timestamp = os.date(),\r\n            roomName = device.roomName,\r\n            value = value\r\n        }\r\n        formattedPayload = json.encode(payload)\r\n    end\r\n\r\n    self.mqtt:publish(self:getterTopic(device, propertyName), formattedPayload, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onCommand(event)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        -- Home Assistant command detected\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[3])\r\n        local propertyName = topicElements[5]\r\n\r\n        local device = self.devices[deviceId]\r\n\r\n        local value = event.payload\r\n\r\n        if (device.bridgeType == \"climate\") then\r\n            -- Fibaro HC3 uses first letter in upper case, and HA relies on lower case\r\n            local firstPart = string.upper(string.sub(value, 1, 1))\r\n            local secondPart = string.sub(value, 2, string.len(value))\r\n            value = firstPart .. secondPart\r\n        end\r\n\r\n        device:setProperty(propertyName, value)\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- HOMIE\r\n-----------------------------------\r\nMqttConventionHomie = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomie.type = \"Homie\"\r\nMqttConventionHomie.rootTopic = \"homie/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomie:getDeviceTopic(device)\r\n    return self.rootTopic .. device.id .. \"/\"\r\nend\r\nfunction MqttConventionHomie:getGenericEventTopic(device, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomie:getterTopic(device, propertyName)\r\n    return self:getGenericEventTopic(device, \"DevicePropertyUpdatedEvent\", propertyName)     \r\nend\r\nfunction MqttConventionHomie:getGenericCommandTopic(device, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(device) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomie:getSetterTopic(device, propertyName)\r\n    return self:getGenericCommandTopic(device, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomie:getLastWillMessage() \r\n    return {\r\n        topic = self.rootTopic .. \"hc3-dead\",\r\n        payload = \"true\",\r\n        lastWill = true\r\n    }    \r\nend\r\n\r\nfunction MqttConventionHomie:onConnected()\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/+/set\")\r\nend\r\n\r\nfunction MqttConventionHomie:onDisconnected()\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceCreated(device)\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$homie\", \"2.1.0\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$name\", device.name .. \" (\" .. device.roomName .. \")\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$implementation\", \"Fibaro HC3 to MQTT bridge\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$nodes\", \"node\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$name\", device.name, {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$type\", \"\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$extensions\", \"\", {retain = true})\r\n\r\n    local properties = { }\r\n\r\n    if (device.bridgeRead) then\r\n        local propertyName = device.bridgeType\r\n        if (PrototypeDevice.bridgeSubtype ~= device.bridgeSubtype) then\r\n            propertyName = propertyName .. \" - \" .. device.bridgeSubtype\r\n        end\r\n\r\n        if (device.bridgeBinary) then\r\n            properties[\"state\"] = {\r\n                name = device.bridgeType,\r\n                datatype = \"boolean\",\r\n                settable = device.bridgeWrite, \r\n                retained = true,\r\n            }\r\n        end\r\n\r\n        if (device.bridgeMultilevel) then\r\n            properties[\"value\"] = {\r\n                name = device.bridgeType,\r\n                datatype = \"integer\",\r\n                settable = device.bridgeWrite,\r\n                retained = true,\r\n                unit = device.bridgeUnitOfMeasurement\r\n            }\r\n        end\r\n    end\r\n\r\n    local propertiesStr = \"\"\r\n    local firstParameter = true\r\n    for i, j in pairs(properties) do\r\n        if (not firstParameter) then\r\n            propertiesStr = propertiesStr .. \",\"\r\n        end\r\n        propertiesStr = propertiesStr .. i\r\n        firstParameter = false\r\n    end\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$properties\", propertiesStr, {retain = true})\r\n\r\n    for i, j in pairs(properties) do\r\n        local propertyTopic = self:getDeviceTopic(device) .. \"node/\" .. i .. \"/$\"\r\n        for m, n in pairs(j) do\r\n            self.mqtt:publish(propertyTopic .. m, tostring(n), {retain = true})\r\n        end\r\n    end\r\n\r\n    local homieState\r\n    if (device.dead) then\r\n        homieState = \"lost\"\r\n    else\r\n        homieState = \"ready\"\r\n    end\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$state\", homieState, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceRemoved(device)\r\nend\r\n\r\nfunction MqttConventionHomie:onPropertyUpdated(device, event)\r\n    local propertyName = event.data.property\r\n\r\n    local value = event.data.newValue\r\n\r\n    value = string.lower(value)\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/\" .. propertyName, value, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onCommand(event)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[2])\r\n        local device = self.devices[deviceId]\r\n\r\n        local propertyName = topicElements[4]\r\n        local value = event.payload\r\n\r\n        device:setProperty(propertyName, value)\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- FOR EXTENDED DEBUG PURPOSES\r\n-----------------------------------\r\n\r\nMqttConventionDebug = inheritFrom(MqttConventionPrototype) \r\nMqttConventionDebug.type = \"Debug\"\r\nfunction MqttConventionDebug:getLastWillMessage() \r\nend\r\nfunction MqttConventionDebug:onDeviceCreated(device)\r\nend\r\nfunction MqttConventionDebug:onDeviceRemoved(device)\r\nend\r\nfunction MqttConventionDebug:onPropertyUpdated(device, event)\r\nend\r\nfunction MqttConventionDebug:onConnected()\r\nend\r\nfunction MqttConventionDebug:onCommand(event)\r\nend\r\nfunction MqttConventionDebug:onDisconnected()\r\nend\r\n\r\n-----------------------------------\r\n-- MQTT CONVENTION MAPPINGS\r\n-----------------------------------\r\n\r\nmqttConventionMappings = {\r\n    [\"home-assistant\"] = MqttConventionHomeAssistant,\r\n    [\"homie\"] = MqttConventionHomie,\r\n    [\"debug\"] = MqttConventionDebug\r\n} \r\n"},{"name":"device_api","isMain":false,"isOpen":true,"content":"----------------------------------- \r\n-- PROTOTYPE OBJECT \r\n-----------------------------------\r\nPrototypeDevice = {\r\n    bridgeType = \"'bridgeType' needs to be set\",\r\n    bridgeSubtype = \"default\",\r\n    bridgeBinary = \"'bridgeBinary' needs to be set\",\r\n    bridgeBinaryProperty = \"value\",\r\n    bridgeMultilevel = \"'bridgeMultilevel' needs to be set\",\r\n    bridgeRead = \"'bridgeRead' needs to be set\",\r\n    bridgeWrite = \"'bridgeWrite' needs to be set\",\r\n    bridgeModes = \"'bridgeWrite' needs to be set to an array of modes, e.g. 'heat', 'cool'\",\r\n    customPropertySetters = nil -- could be optionally set by child class\r\n} \r\n\r\nfunction PrototypeDevice:new(fibaroDevice)\r\n    -- clone self, and copy fibaroDevice\r\n    local status, device = pcall(clone, self)\r\n    shallowCopyTo(fibaroDevice, device)\r\n\r\n    device.fibaroDevice = fibaroDevice\r\n    \r\n    if (not device.roomName) then\r\n        device.roomName = tostring(fibaro.getRoomNameByDeviceID(device.id))\r\n    end\r\n\r\n    self:init(device)\r\n\r\n    return device\r\nend\r\n\r\nfunction PrototypeDevice:init(device)\r\n    -- \"init\" function could be optionally overriden by subclasses implementation\r\nend \r\n\r\nfunction PrototypeDevice:setProperty(propertyName, value)\r\n    if isEmptyString(value) then\r\n        return\r\n    end\r\n\r\n    local customPropertySetter\r\n    if (self.customPropertySetters ~= nil) then\r\n        customPropertySetter = self.customPropertySetters[propertyName]\r\n    end\r\n\r\n    if (customPropertySetter == nil) then\r\n        -- DEFAULT PROPERTY SETTER\r\n        if (propertyName == \"state\") then\r\n            if (value == \"true\") then\r\n                --print(\"Turn ON for device #\" .. self.id)\r\n                fibaro.call(self.id, \"turnOn\")\r\n            elseif (value == \"false\") then\r\n                --print(\"Turn OFF for device #\" .. self.id)\r\n                fibaro.call(self.id, \"turnOff\")\r\n            else\r\n                print(\"Unexpected value: \" .. json.encode(event))\r\n            end\r\n        else\r\n            local firstPart = string.upper(string.sub(propertyName, 1, 1))\r\n            local secondPart = string.sub(propertyName, 2, string.len(propertyName))\r\n\r\n            local functionName = \"set\" .. firstPart .. secondPart\r\n            print(\"FUNCTION CALL: \\\"\" .. functionName .. \"\\\", with VALUE \\\"\" .. value .. \"\\\" for device #\" .. self.id)\r\n\r\n            if (propertyName == \"color\") then\r\n                local newRgbw = splitStringToNumbers(value, \",\")\r\n                fibaro.call(self.id, functionName, newRgbw[1], newRgbw[2], newRgbw[3], newRgbw[4])\r\n            else\r\n                fibaro.call(self.id, functionName, value)\r\n            end\r\n        end\r\n    else\r\n        -- CUSTOM PROPERTY SETTER\r\n        print(\"[CUSTOM PROPERTY] SET \\\"\" .. propertyName .. \"\\\" to \\\"\" .. value .. \"\\\" for device #\" .. self.id)\r\n        customPropertySetter(propertyName, value)\r\n    end\r\nend\r\n\r\nfunction PrototypeDevice.isSupported(fibaroDevice)\r\n    print(\"'isSupported' function is mandatory for implementation\")\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY SWITCH\r\n-----------------------------------\r\nSwitch = inheritFrom(PrototypeDevice)\r\nSwitch.bridgeType = \"switch\"\r\nSwitch.bridgeSubtype = \"binary\"\r\nSwitch.bridgeBinary = true\r\nSwitch.bridgeMultilevel = false\r\nSwitch.bridgeRead = true\r\nSwitch.bridgeWrite = true \r\n\r\nfunction Switch.isSupported(fibaroDevice)\r\n    if fibaroDeviceHasType(fibaroDevice, \"com.fibaro.binarySwitch\") and fibaroDeviceHasNoInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY LIGHT\r\n-----------------------------------\r\nLight = inheritFrom(PrototypeDevice)\r\nLight.bridgeType = \"light\"\r\nLight.bridgeSubtype = \"binary\"\r\nLight.bridgeBinary = true\r\nLight.bridgeMultilevel = false\r\nLight.bridgeRead = true\r\nLight.bridgeWrite = true\r\n\r\nfunction Light.isSupported(fibaroDevice)\r\n    if fibaroDeviceHasType(fibaroDevice, \"com.fibaro.binarySwitch\") and fibaroDeviceHasInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL LIGHT (DIMMERS)\r\n-----------------------------------\r\nDimmer = inheritFrom(PrototypeDevice)\r\nDimmer.bridgeType = \"light\"\r\nDimmer.bridgeSubtype = \"dimmer\"\r\nDimmer.bridgeBinary = true\r\nDimmer.bridgeMultilevel = true\r\nDimmer.bridgeRead = true\r\nDimmer.bridgeWrite = true\r\n\r\nfunction Dimmer.isSupported(fibaroDevice)\r\n    if fibaroDeviceHasType(fibaroDevice, \"com.fibaro.multilevelSwitch\") and fibaroDeviceHasInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL LIGHT (RGBW)\r\n-----------------------------------\r\nRgbw = inheritFrom(PrototypeDevice)\r\nRgbw.bridgeType = \"light\"\r\nRgbw.bridgeSubtype = \"rgbw\" \r\nRgbw.bridgeBinary = true\r\nRgbw.bridgeMultilevel = true\r\nRgbw.bridgeRead = true\r\nRgbw.bridgeWrite = true\r\n\r\nfunction Rgbw.isSupported(fibaroDevice)\r\n    if fibaroDeviceHasType(fibaroDevice, \"com.fibaro.colorController\") and fibaroDeviceHasInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY SENSOR (DOOR, MOTION, WATER LEAK, FIRE, SMORE SENSORSMULTILEVEL FOR TEMPERATURE, ETC)\r\n-----------------------------------\r\nBinarySensor = inheritFrom(PrototypeDevice)\r\nBinarySensor.bridgeType = \"binary_sensor\"\r\nBinarySensor.bridgeBinary = true\r\nBinarySensor.bridgeMultilevel = false\r\nBinarySensor.bridgeRead = true \r\nBinarySensor.bridgeWrite = false\r\n\r\nfunction BinarySensor.isSupported(fibaroDevice)\r\n    if (string.find(fibaroDevice.baseType, \"Sensor\")) or (string.find(fibaroDevice.baseType, \"sensor\")) then\r\n        --if (fibaroDevice.baseType ~= \"com.fibaro.multilevelSensor\") and (fibaroDevice.type ~= \"com.fibaro.multilevelSensor\") then\r\n        if fibaroDeviceHasNoType(fibaroDevice, \"com.fibaro.multilevelSensor\") then\r\n            return true \r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction BinarySensor:init(device)\r\n    -- set unit of measurement\r\n    device.bridgeUnitOfMeasurement = device.properties.unit\r\n\r\n    -- ToDo: refactor with mappings\r\n    if (device.type == \"com.fibaro.motionSensor\") or (device.baseType == \"com.fibaro.motionSensor\") then\r\n        device.bridgeSubtype = \"motion\"\r\n    elseif (device.baseType == \"com.fibaro.floodSensor\") then\r\n        device.bridgeSubtype = \"moisture\" \r\n    elseif (device.baseType == \"com.fibaro.doorWindowSensor\") then\r\n        if (device.type == \"com.fibaro.doorSensor\") then\r\n            device.bridgeSubtype = \"door\"\r\n        else\r\n            print(\"[BinarySensor.init] Uknown doow/window sensor \" .. device.id .. \" \" .. device.name)\r\n        end\r\n    elseif (device.baseType == \"com.fibaro.lifeDangerSensor\") then\r\n        device.bridgeSubtype = \"safety\"\r\n    elseif (device.baseType == \"com.fibaro.smokeSensor\") or (device.type == \"com.fibaro.smokeSensor\") then\r\n        device.bridgeSubtype = \"smoke\"\r\n    else\r\n        print(\"[BinarySensor.init] Unknown binary sensor\")\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL SENSOR (TEMPERATURE, HUMIDITY, VOLTAGE, ETC) \r\n-----------------------------------\r\nMultilevelSensor = inheritFrom(PrototypeDevice)\r\nMultilevelSensor.bridgeType = \"sensor\"\r\nMultilevelSensor.bridgeBinary = false\r\nMultilevelSensor.bridgeMultilevel = true\r\nMultilevelSensor.bridgeUnitOfMeasurement = \"'unit of measurement' needs to be initialized\"\r\nMultilevelSensor.bridgeRead = true\r\nMultilevelSensor.bridgeWrite = false\r\n\r\nfunction MultilevelSensor.isSupported(fibaroDevice)\r\n    if (string.find(fibaroDevice.baseType, \"Sensor\")) or (string.find(fibaroDevice.baseType, \"sensor\")) then\r\n        if (fibaroDevice.baseType == \"com.fibaro.multilevelSensor\") or (fibaroDevice.type == \"com.fibaro.multilevelSensor\") then\r\n            return true \r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction MultilevelSensor:init(device)\r\n    -- initialize unit of measurement\r\n    device.bridgeUnitOfMeasurement = device.properties.unit\r\n\r\n    -- initialize subtype \r\n    -- ToDo *** refactor with mappings\r\n    if (device.type == \"com.fibaro.temperatureSensor\") then\r\n        device.bridgeSubtype = \"temperature\"\r\n        device.bridgeUnitOfMeasurement = \"°\" .. device.properties.unit\r\n    elseif (device.type == \"com.fibaro.lightSensor\") then\r\n        device.bridgeSubtype = \"illuminance\"\r\n    elseif (device.type == \"com.fibaro.humiditySensor\") then \r\n        device.bridgeSubtype = \"humidity\"\r\n    elseif (device.type == \"com.fibaro.energySensor\") then \r\n        device.bridgeSubtype = \"energy\"\r\n    elseif (device.type == \"com.fibaro.powerSensor\") then \r\n        device.bridgeSubtype = \"power\"\r\n    elseif (device.type == \"com.fibaro.batteryLevelSensor\") then \r\n        device.bridgeSubtype = \"battery\"\r\n    elseif (device.bridgeSubtype == RemoteController.bridgeSubtype) then \r\n        -- do nothing / the purpose for this logical condition is to make sure RemoteController doesn't fall into \"Unknown multilevel sensor\" category\r\n    elseif (device.properties.unit == \"V\") then\r\n        device.bridgeSubtype = \"voltage\"\r\n    elseif (device.properties.unit == \"A\") then\r\n        device.bridgeSubtype = \"current\"\r\n    elseif (device.properties.unit == \"W\" or device.properties.unit == \"kW\" or device.properties.unit == \"kVA\") then\r\n        device.bridgeSubtype = \"power\"\r\n    else\r\n        print(\"[MultilevelSensor.init] Using default sensor type, as couldn't identify specialisation for \" .. tostring(device.id) .. \" \" .. tostring(device.name) .. \" \" .. tostring(device.properties.unit))\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL SWITCH (COVER)\r\n-----------------------------------\r\nCover = inheritFrom(PrototypeDevice)\r\nCover.bridgeType = \"cover\"\r\nCover.bridgeBinary = true\r\nCover.bridgeMultilevel = true\r\nCover.bridgeRead = true\r\nCover.bridgeWrite = true\r\n\r\nfunction Cover.isSupported(fibaroDevice)\r\n    if (fibaroDevice.baseType == \"com.fibaro.baseShutter\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction Cover:init(device) \r\n    device.customPropertySetters = { }\r\n    device.customPropertySetters[\"state\"] = function (propertyName, value) \r\n        if (value == \"open\") then\r\n            fibaro.call(device.id, \"setValue\", 99)\r\n        elseif (value == \"close\") then\r\n            fibaro.call(device.id, \"setValue\", 0)\r\n        elseif (value == \"stop\") then\r\n            fibaro.call(device.id, \"stop\")\r\n        else\r\n            print(\"Unsupported state\")\r\n        end\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- THERMOSTAT (MULTILEVEL SWITCH)\r\n-----------------------------------\r\nThermostat = inheritFrom(PrototypeDevice)\r\nThermostat.bridgeType = \"climate\"\r\nThermostat.bridgeBinary = false\r\nThermostat.bridgeMultilevel = true\r\nThermostat.bridgeRead = true\r\nThermostat.bridgeWrite = true \r\n\r\nfunction Thermostat.isSupported(fibaroDevice)\r\n    if (fibaroDevice.type == \"com.fibaro.hvacSystem\") then \r\n        return true \r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction Thermostat:init(device) \r\n    for i, mode in ipairs(device.properties.supportedThermostatModes) do\r\n        device.properties.supportedThermostatModes[i] = string.lower(mode)\r\n    end\r\nend\r\n\r\nfunction Thermostat:setMode(mode)\r\n    fibaro.call(self.id, \"setThermostatMode\", mode)\r\nend\r\n\r\nfunction Thermostat:setHeatingThermostatSetpoint(targetTemperature)\r\n    fibaro.call(self.id, \"setHeatingThermostatSetpoint\", targetTemperature)\r\nend\r\n\r\nfunction Thermostat:getTemperatureSensor(allDevices)\r\n    local device = allDevices[self.id + 1]\r\n    if (not Thermostat.isTemperatureSensor(device)) then\r\n        -- *** no laughs, to be refactored with linked devices later :)\r\n        device = allDevices[self.id + 2]\r\n    end\r\n\r\n    if (Thermostat.isTemperatureSensor(device)) then\r\n        return device\r\n    else\r\n        return nil\r\n    end\r\nend\r\n\r\nfunction Thermostat.isTemperatureSensor(device)\r\n    if ((device ~= nil) and (MultilevelSensor.isSupported(device)) and (device.bridgeSubtype == \"temperature\")) then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- REMOTE CONTROLLER\r\n-----------------------------------\r\nRemoteController = inheritFrom(MultilevelSensor)\r\nRemoteController.bridgeSubtype = \"remoteController\"\r\n\r\nfunction RemoteController.isSupported(fibaroDevice)\r\n    if ((fibaroDevice.baseType == \"com.fibaro.remoteController\") or ( fibaroDevice.baseType == \"com.fibaro.remoteSceneController\") or ( fibaroDevice.type == \"com.fibaro.remoteController\") or (fibaroDevice.type == \"com.fibaro.remoteSceneController\"))      then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n------------------------------------\r\n-- REMOTE CONTROLLER - BUTTON ACTION\r\n------------------------------------\r\nRemoteControllerKey = inheritFrom(PrototypeDevice)\r\nRemoteControllerKey.bridgeType = \"device_automation\"\r\nRemoteControllerKey.bridgeSubtype = \"trigger\"\r\nRemoteControllerKey.bridgeBinary = true\r\nRemoteControllerKey.bridgeMultilevel = false\r\nRemoteControllerKey.bridgeRead = true\r\nRemoteControllerKey.bridgeWrite = false\r\n\r\nfunction RemoteControllerKey.isSupported(fibaroDevice)\r\n    if (fibaroDevice.baseType == \"com.alexander_vitishchenko.remoteKey\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction RemoteControllerKey.init(device)\r\n    -- not needed for now\r\nend\r\n\r\n\r\n-----------------------------------\r\n-- HELPER FUNCTIONS - OVERRIDE \"WRONG\" DEVICE TYPES FROM FIBARO DEVICE API\r\n-----------------------------------\r\n\r\nlocal fibaroBaseTypeOverride = {\r\n    [\"com.fibaro.FGR\"] = \"com.fibaro.baseShutter\",\r\n    [\"com.fibaro.FGMS001\"] = \"com.fibaro.motionSensor\",\r\n    [\"com.fibaro.FGWP\"] = \"com.fibaro.binarySwitch\"\r\n}\r\n\r\nlocal fibaroTypeOverride = { \r\n    [\"com.fibaro.FGKF601\"] = \"com.fibaro.keyFob\",\r\n    [\"com.fibaro.FGD212\"] = \"com.fibaro.dimmer\",\r\n    [\"com.fibaro.FGMS001v2\"] = \"com.fibaro.motionSensor\",\r\n    [\"com.fibaro.FGFS101\"] = \"com.fibaro.floodSensor\",\r\n    [\"com.fibaro.FGWP102\"] = \"com.fibaro.binarySwitch\"\r\n}\r\n\r\nfunction getFibaroDevicesByFilter(customDeviceFilterJsonStr)\r\n    -- EXAMPLE FILTERS FROM  https://manuals.fibaro.com/content/other/FIBARO_System_Lua_API.pdf => \"fibaro:getDevicesId(filters)\"\r\n    --[[\r\n            {\r\n                \"filter\": \"hasProperty\",\r\n                \"value\": [\"configured\", \"dead\", \"model\"]\r\n            },\r\n\r\n            {\r\n                \"filter\": \"interface\",\r\n                \"value\": [\"zwave\", \"levelChange\"]\r\n            },\r\n\r\n            {\r\n                \"filter\": \"parentId\",\r\n                \"value\": [664]\r\n            },\r\n\r\n            {\r\n                \"filter\": \"type\",\r\n                \"value\": [\"com.fibaro.multilevelSwitch\"]\r\n            },\r\n\r\n            {\r\n                \"filter\": \"roomID\",\r\n                \"value\": [2, 3]\r\n            },\r\n\r\n            {\r\n                \"filter\": \"baseType\",\r\n                \"value\": [\"com.fibaro.binarySwitch\"]\r\n            },\r\n\r\n            {\r\n                \"filter\": \"isTypeOf\",\r\n                \"value\": [\"com.fibaro.binarySwitch\"]\r\n            },\r\n\r\n            {\r\n                \"filter\": \"isPlugin\",\r\n                \"value\": [true]\r\n            },\r\n\r\n            {\r\n                \"filter\": \"propertyEquals\",\r\n                \"value\":\r\n                    [\r\n                        {\r\n                            \"propertyName\": \"configured\",\r\n                            \"propertyValue\": [true]\r\n                        },\r\n                        {\r\n                            \"propertyName\": \"dead\",\r\n                            \"propertyValue\": [false]\r\n                        },\r\n                        {\r\n                            \"propertyName\": \"deviceIcon\",\r\n                            \"propertyValue\": [15]\r\n                        },\r\n                        {\r\n                            \"propertyName\": \"deviceControlType\",\r\n                            \"propertyValue\": [15,20,25]\r\n                        }\r\n                    ]\r\n            },\r\n\r\n            {\r\n                \"filter\": \"deviceID\",\r\n                \"value\": [55,120,902]\r\n            }\r\n    ]]--\r\n    \r\n    local deviceFilterJson = \r\n        {\r\n            filters = {\r\n                {\r\n                    filter = \"enabled\",\r\n                    value = { true }\r\n                },\r\n                {\r\n                    filter = \"visible\",\r\n                    value = { true }\r\n                }\r\n            }, \r\n            attributes = {\r\n                -- define the list of Fibaro device attributes we are interested in\r\n                main = {\r\n                    \"id\", \"name\", \"roomID\", \"view\", \"type\", \"baseType\", \"enabled\", \"visible\", \"isPlugin\", \"parentId\", \"viewXml\", \"hasUIView\", \"configXml\", \"interfaces\", \"properties\", \"actions\", \"created\", \"modified\", \"sortOrder\"\r\n                }\r\n            }\r\n        }\r\n\r\n    if (not isEmptyString(customDeviceFilterJsonStr)) then\r\n        print(\"\")\r\n        print(\"(!) Apply custom device filter: \" .. tostring(customDeviceFilterJsonStr))\r\n        print(\"--> It will only work if the provided filter is JSON like: \" .. \"{\\\"filter\\\":\\\"baseType\\\", \\\"value\\\":[\\\"com.fibaro.actor\\\"]},   {\\\"filter\\\":\\\"deviceID\\\", \\\"value\\\":[41,42]},   { MORE FILTERS MAY GO HERE }\")\r\n        print(\"--> See the list of Fibaro API filter types at https://manuals.fibaro.com/content/other/FIBARO_System_Lua_API.pdf => \\\"fibaro:getDevicesId(filters)\\\"\")\r\n        print(\"\")\r\n\r\n        local customDeviceFilterJson = json.decode(\"{ filters: [ \" .. customDeviceFilterJsonStr .. \"] }\") \r\n\r\n        shallowInsertTo(customDeviceFilterJson.filters, deviceFilterJson.filters)\r\n    end\r\n\r\n    local allDevices = api.post( \r\n        \"/devices/filter\", \r\n        deviceFilterJson\r\n    )\r\n\r\n    print(\"Filter: \" .. json.encode(deviceFilterJson))\r\n\r\n    print(\"Found devices \" .. #allDevices)\r\n    print(\"\")\r\n\r\n    for i, j in ipairs(allDevices) do\r\n        overrideFibaroDeviceType(j)\r\n    end\r\n\r\n    return allDevices\r\nend\r\n\r\nfunction getFibaroDeviceById(id)\r\n    local fibaroDevice = api.get(\"/devices/\" .. id)\r\n\r\n    return getFibaroDeviceByInfo(fibaroDevice)\r\nend\r\n\r\nfunction getFibaroDeviceByInfo(info)\r\n    local fibaroDevice = info\r\n\r\n    overrideFibaroDeviceType(fibaroDevice) \r\n\r\n    return fibaroDevice\r\nend\r\n\r\nfunction overrideFibaroDeviceType(fibaroDevice)\r\n    if (not fibaroDevice) or (not fibaroDevice.type) then\r\n        return\r\n    end\r\n    local overrideType = fibaroTypeOverride[fibaroDevice.type]\r\n    if overrideType then \r\n        fibaroDevice.type = overrideType\r\n    end\r\n    \r\n    local overrideBaseType = fibaroBaseTypeOverride[fibaroDevice.baseType]\r\n    if overrideBaseType then \r\n        fibaroDevice.baseType = overrideBaseType\r\n    end\r\nend\r\n\r\nfunction fibaroDeviceHasType(fibaroDevice, type)\r\n    return (fibaroDevice.baseType == type) or (fibaroDevice.type == type)\r\nend\r\n\r\nfunction fibaroDeviceHasNoType(fibaroDevice, type)\r\n    return not fibaroDeviceHasType(fibaroDevice, type)\r\nend\r\n\r\nfunction fibaroDeviceHasInterface(fibaroDevice, interface)\r\n    return table_contains_value(fibaroDevice.interfaces, interface)\r\nend\r\n\r\nfunction fibaroDeviceHasNoInterface(fibaroDevice, interface)\r\n    return not fibaroDeviceHasInterface(fibaroDevice, interface)\r\nend\r\n\r\n-----------------------------------\r\n-- HELPER FUNCTIONS - IDENTIFY DEVICE BRIDGE TYPE BY LOOKING AT FIBARO DEVICE TYPE\r\n-----------------------------------\r\n\r\ndeviceTypeMappings = {\r\n    Switch, -- binary switch\r\n    Cover, -- multilevel switch\r\n    Light, -- binary light\r\n    Dimmer, -- multilevel light \r\n    Rgbw, -- multichannel and multilevel light\r\n    BinarySensor,\r\n    MultilevelSensor,\r\n    Thermostat,\r\n    RemoteController,\r\n    RemoteControllerKey\r\n}  \r\n\r\nfunction identifyDevice(fibaroDevice)\r\n    for i, j in ipairs(deviceTypeMappings) do\r\n        if (j.isSupported(fibaroDevice)) then\r\n            local device = j:new(fibaroDevice)\r\n            if (device.parentId and device.parentId ~= 0) then\r\n                device.bridgeParent = getFibaroDeviceById(device.parentId)\r\n            end\r\n\r\n            return device\r\n        end\r\n    end\r\n\r\n    return nil\r\nend\r\n"}]}

