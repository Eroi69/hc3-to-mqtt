{"name":"HC3 <-> MQTT Bridge","type":"com.fibaro.binarySwitch","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_51"},"sections":{"items":[{"components":[{"name":"availableDevices","style":{"weight":"1.2"},"text":"Available devices: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bridgedDevices","style":{"weight":"1.2"},"text":"Bridged devices: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bootTime","style":{"weight":"1.2"},"text":"Boot time: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_51"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"mqttUrl","value":"mqtt://192.168.1.100:1883"},{"name":"mqttKeepAlive","value":"15"},{"name":"mqttUsername","value":"your_mqtt_username"},{"name":"mqttPassword","value":"your_mqtt_password"},{"name":"mqttConvention","value":"home-assistant"},{"name":"hc3Username","value":""},{"name":"hc3Password","value":""}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"function QuickApp:onInit()\n    self:debug(\"-------------------------\")\n    self:debug(\"HC3 <-> MQTT BRIDGE\")\n    self:debug(\"-------------------------\")\n\n    self:turnOn() \nend\n\nfunction QuickApp:publish(topic, payload)\n    self.mqtt:publish(topic, tostring(payload), {retain = true})\nend\n\nfunction QuickApp:turnOn()\n    self:establishMqttConnection()\nend\n\nfunction QuickApp:turnOff()\n    self:disconnectFromMqttAndHc3()\n    self:updateProperty(\"value\", false)\nend\n\nfunction QuickApp:establishMqttConnection()\n    self.devices = {}\n\n    -- IDENTIFY WHICH MQTT CONVENTIONS TO BE USED (e.g. Home Assistant, Homio, etc)\n    self.mqttConventions = { }\n    local mqttConventionStr = self:getVariable(\"mqttConvention\")\n    if (isEmptyString(mqttConventionStr)) then\n        self.mqttConventions[0] = MqttConventionHomeAssistant\n    else\n        local arr = splitString(mqttConventionStr, \",\")\n        for i, j in ipairs(arr) do\n            local convention = mqttConventionMappings[j]\n            if (convention) then\n                self.mqttConventions[i] = clone(convention)\n            end\n        end\n    end\n\n    local mqttConnectionParameters = self:getMqttConnectionParameters()\n    self:trace(\"MQTT Connection Parameters: \" .. json.encode(mqttConnectionParameters))\n\n    local mqttClient = mqtt.Client.connect(\n                                    self:getVariable(\"mqttUrl\"), \n                                    mqttConnectionParameters) \n\n    mqttClient:addEventListener('connected', function(event) self:onConnected(event) end)\n    mqttClient:addEventListener('closed', function(event) self:onClosed(event) end)\n    mqttClient:addEventListener('message', function(event) self:onMessage(event) end)\n    mqttClient:addEventListener('error', function(event) self:onError(event) end)    \n    \n    -- skip event handlers to aid higher performance\n    --mqttClient:addEventListener('subscribed', function(event) self:onSubscribed(event) end)\n    --mqttClient:addEventListener('published', function(event) self:onPublished(event) end) \n\n    self.mqtt = mqttClient\nend\n\nfunction QuickApp:getMqttConnectionParameters()\n    local mqttConnectionParameters = { \n        -- pickup last will from primary MQTT Convention provider\n        lastWill = self.mqttConventions[1]:getLastWillMessage()\n    }\n\n    -- MQTT CLIENT ID\n    local mqttClientId = self:getVariable(\"mqttClientId\")\n    if (isEmptyString(mqttClientId)) then\n        mqttConnectionParameters.clientId = \"HC3-\" .. plugin.mainDeviceId\n    else\n        mqttConnectionParameters.clientId = mqttClientId\n    end\n\n    -- MQTT KEEP ALIVE PERIOD\n    local mqttKeepAlivePeriod = self:getVariable(\"mqttKeepAlive\")\n    if (mqttKeepAlivePeriod) then\n        mqttConnectionParameters.keepAlivePeriod = tonumber(mqttKeepAlivePeriod)\n    else\n        mqttConnectionParameters.keepAlivePeriod = 30\n    end\n\n    -- MQTT AUTH (USERNAME/PASSWORD)\n    local mqttAuth = self:getVariable(\"mqttAuth\") \n    local mqttUsername\n    local mqttPassword\n    if (isEmptyString(mqttAuth)) then\n        mqttUsername = self:getVariable(\"mqttUsername\")\n        mqttPassword = self:getVariable(\"mqttPassword\")\n    else \n        local mqttAuth = self:getVariable(\"mqttAuth\")\n        if (mqttAuth) then\n            mqttUsername, mqttPassword = decodeBase64Auth(mqttAuth)\n        end\n    end\n\n    if (mqttUsername) then\n        mqttConnectionParameters.username = mqttUsername\n    end\n    if (mqttPassword) then\n        mqttConnectionParameters.password = mqttPassword\n    end\n\n    return mqttConnectionParameters\nend\n\nfunction QuickApp:disconnectFromMqttAndHc3()\n    self.hc3ConnectionEnabled = false\n    self:closeMqttConnection()\nend\n\nfunction QuickApp:closeMqttConnection()\n    for i, j in ipairs(self.mqttConventions) do\n        j:onDisconnected()\n    end\n\n    self.mqtt:disconnect()\nend\n\nfunction QuickApp:onConnected(event)\n    self:debug(\"MQTT connection established\")\n\n    for i, j in ipairs(self.mqttConventions) do\n        j.mqtt = self.mqtt\n        j.devices = self.devices\n\n        j:onConnected()\n    end\n\n    self:discoverDevicesAndBroadcastToHa()\n\n    self.hc3ConnectionEnabled = true\n    self:scheduleHc3EventsFetcher()\n\n    self:updateProperty(\"value\", true)\nend\n\nfunction QuickApp:onClosed(event)\n    self:updateProperty(\"value\", false)\nend\n\nfunction QuickApp:onError(event)\n    self:error(\"MQTT ERROR: \" .. json.encode(event))\n    self:turnOff()\n    self:scheduleReconnectToMqtt();\nend\n\nfunction QuickApp:scheduleReconnectToMqtt()\n    self:debug(\"Schedule attempt to reconnect to MQTT...\")\n    fibaro.setTimeout(10000, function() \n        self:establishMqttConnection()\n    end)\nend\n\nfunction QuickApp:onMessage(event)\n    for i, j in ipairs(self.mqttConventions) do\n        j.mqtt = self.mqtt\n        j:onCommand(event)\n    end\nend\n \nfunction QuickApp:discoverDevicesAndBroadcastToHa()\n    local startTime = os.time()\n\n    local allDevices = getFibaroDevicesByFilter({\n        enabled = true,\n        visible = true\n    })\n\n    local bridgedDevices = 0\n\n    local developmentModeStr = self:getVariable(\"developmentMode\")\n    if ((not developmentModeStr) or (developmentModeStr ~= \"true\")) then\n        self:debug(\"Bridge mode: PRODUCTION\")\n        for i, j in pairs(allDevices) do\n            if (self:identifyAndPublishDeviceToMqtt(j)) then\n                bridgedDevices = bridgedDevices + 1\n            end\n        end\n    else\n        -- useful to reduce amount information for debug with smaller number of devices\n        self:debug(\"Bridge mode: DEVELOPMENT\")\n\n        local testDevices = { \n            getFibaroDeviceById(42), -- switch,\n            getFibaroDeviceById(260), -- iPad screen\n            getFibaroDeviceById(287), -- door sensor\n            getFibaroDeviceById(54), -- motion sensor\n            getFibaroDeviceById(92), -- roller shutter\n            getFibaroDeviceById(78), -- dimmer\n            getFibaroDeviceById(66), -- temperature\n            getFibaroDeviceById(56), -- light sensor (lux)\n            getFibaroDeviceById(245) -- volts\n        }\n\n        for i, j in pairs(testDevices) do\n            if (self:identifyAndPublishDeviceToMqtt(j)) then\n                bridgedDevices = bridgedDevices + 1\n            end\n        end\n    end\n\n    local endTime = os.time()\n    local diff = endTime - startTime  \n\n    self:updateView(\"availableDevices\", \"text\", \"Available devices: \" .. #allDevices)\n\n    self:updateView(\"bridgedDevices\", \"text\", \"Bridged devices: \" .. bridgedDevices)\n    self:updateView(\"bootTime\" , \"text\", \"Boot time: \" .. diff .. \"s\")\n\n    self:debug(\"----------------------------------\")\n    self:debug(\"Device discovery has been complete\")\n    self:debug(\"----------------------------------\")\n\n    return haDevices\nend\n\nfunction QuickApp:identifyAndPublishDeviceToMqtt(fibaroDevice)\n    ------------------------------------------------------------------\n    ------- IDENTIFY DEVICE TYPE\n    ------------------------------------------------------------------\n\n    local device = identifyDevice(fibaroDevice) \n    if (device) then\n        self:debug(\"Device \" .. self:getDeviceDescription(device) .. \" identified as \" .. device.bridgeType)\n        self.devices[device.id] = device\n    else\n        self:debug(\"Couldn't recognize device #\" .. fibaroDevice.id .. \" - \" .. fibaroDevice.name)\n        return \n    end\n\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE EXISTANCE\n    ------------------------------------------------------------------\n\n    for i, j in ipairs(self.mqttConventions) do\n        j:onDeviceCreated(device)\n    end\n\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE CURRENT STATE => BY SIMULATING HC3 EVENTS\n    ------------------------------------------------------------------\n\n    self:simulatePropertyUpdate(device, \"dead\", device.properties.dead)\n    if (device.properties.state ~= nil) then\n        self:simulatePropertyUpdate(device, \"state\", device.properties.state)\n    end\n    if (device.properties.value ~= nil) then\n        self:simulatePropertyUpdate(device, \"value\", device.properties.value)\n    end\n\n    return device\nend\n\nfunction QuickApp:onPublished(event)\n    -- do nothing, for now\nend\n\n-- FETCH HC3 EVENTS\nlocal lastRefresh = 0\nlocal http = net.HTTPClient()\n\nfunction QuickApp:scheduleHc3EventsFetcher()\n    local hc3Auth = self:getVariable(\"hc3Auth\")\n    if (isEmptyString(hc3Auth)) then\n        local hc3Username = self:getVariable(\"hc3Username\")\n        local hc3Password = self:getVariable(\"hc3Password\")\n        if (isEmptyString(hc3Username) or isEmptyString(hc3Password)) then\n            self:error(\"You need to provide username/password for your Fibaro HC3\")\n            error(\"You need to provide username/password for your Fibaro HC3\")\n        end\n        hc3Auth = base64Encode(hc3Username .. \":\" .. hc3Password)\n    end\n\n    self.hc3Auth = hc3Auth\n\n    self:readHc3EventAndScheduleFetcher()\n    self:debug(\"---------------------------------------------------\")\n    self:debug(\"Started monitoring events from Fibaro Home Center 3\")\n    self:debug(\"---------------------------------------------------\")\nend\n\nfunction QuickApp:readHc3EventAndScheduleFetcher()\n    local requestUrl = \"http://localhost:11111/api/refreshStates?last=\" .. lastRefresh;\n    --self:debug(\"Try fetch events from \" .. requestUrl .. \" | \" .. tostring(self.hc3ConnectionEnabled))\n\n    -- use non-block HTTP calls, avoid api.get(uri) that has a risk of blocking calls\n    local stat,res = http:request(\n        requestUrl,\n        {\n        options = {\n            headers = {\n                [\"Authorization\"] = \"Basic \" .. self.hc3Auth,\n            }\n        },\n        success=function(res)\n            local states = res.status == 200 and json.decode(res.data)\n\n            if (res.status ~= 200) then\n                self:error(\"Unexpected response status \" .. res.status)\n            end\n            if (not res.data) then\n                self:error(\"Empty response\")\n            end\n            if (not self.hc3ConnectionEnabled) then\n                self:debug(\"Got flagged to stop reading HC3 events\")\n            end\n\n            if states and self.hc3ConnectionEnabled then\n                lastRefresh = states.last\n                if states.events and #states.events>0 then \n                    for i, v in ipairs(states.events) do\n                        self:dispatchFibaroEventToMqtt(v)\n                        --local status, err = pcall(function () self:dispatchFibaroEventToMqtt(v) end)\n                        --self:debug(\"RESP: \" .. json.encode(status) .. \" - \" .. json.encode(err))\n                    end\n                end\n            end\n\n            if (self.hc3ConnectionEnabled) then\n                fibaro.setTimeout(25, function()\n                    self:readHc3EventAndScheduleFetcher()\n                end)\n            end\n        end,\n        error=function(res) \n            self:error(\"Error while reading HC3 events \" .. json.encode(res))\n            self:turnOff()\n        end\n    })\nend\n\nfunction QuickApp:simulatePropertyUpdate(device, propertyName, payload)\n    local event = createFibaroEventPayload(device, propertyName, payload)\n    event.simulation = true\n    self:dispatchFibaroEventToMqtt(event)\nend\n\nfunction QuickApp:dispatchFibaroEventToMqtt(event)\n    --self:debug(\"Event: \" .. json.encode(event))\n    if (not event) then\n        self:error(\"No event found\")\n        return\n    end\n\n    if (not event.data) then\n        self:error(\"No event data found\")\n        return\n    end\n\n    local deviceId = event.data.id or event.data.deviceId\n\n    if not deviceId then\n        -- deviceId is must have for processing logic\n        self:warning(\"No device id for \" .. json.encode(event))\n        return\n    end\n    \n    local propertyName = event.data.property\n    if not propertyName then\n        propertyName = \"unknown\"\n    end\n\n    if (not event.type) then\n        event.type = \"unknown\"\n    end\n\n    local device = self.devices[deviceId]\n\n    if (device) then\n\n        if (event.type == \"DevicePropertyUpdatedEvent\") then\n            if (device.bridgeType == \"binary_sensor\") and (propertyName == \"value\") then\n                -- Fibaro uses state/value fields inconsistently for binary sensor. Replace value --> state field\n                event.data.property = \"state\"\n            end\n\n\n            for i, j in ipairs(self.mqttConventions) do\n                j:onPropertyUpdateEvent(device, event)\n            end\n        elseif (event.type == \"DeviceModifiedEvent\") then\n            self:dispatchDeviceModifiedEvent(device)\n        elseif (event.type == \"DeviceCreatedEvent\") then\n            self:dispatchDeviceCreatedEvent(device)\n        elseif (event.type == \"DeviceRemovedEvent\") then\n            self:dispatchDeviceRemovedEvent(device)\n        elseif (event.type == \"DeviceActionRanEvent\") then\n            if (event.data.actionName == \"turnOn\" or event.data.actionName == \"turnOff\") then\n                --self:rememberLastHc3CommandTime(deviceId, event.sourceType)\n            end\n        else\n            self:warning(\"TBD: Need to introduce new event type for \" .. tostring(event.type))\n        end\n\n    end\nend\n\nfunction QuickApp:rememberLastMqttCommandTime(deviceId)\n    self.lastMqttCommandTime[deviceId] = os.time()\nend\n\nfunction QuickApp:dispatchPropertyUpdateEvent(device, event, payload, propertyName)\n    -- PUBLISH DEVICE STATUS FOR HA AND NODE-RED\n    local topic = createPropertyTopicName(device, propertyName)\n\n    local value = (type(event.data.newValue) == \"number\" and event.data.newValue or tostring(event.data.newValue))\n    if not value then\n        value = (type(event.value) == \"number\" and event.value or tostring(event.value))    \n    end\n\n    payload.value = string.lower(value)\n\n    local haPayload\n    if (propertyName == \"dead\") then\n        haPayload = tostring(payload.value)\n    else\n        haPayload = json.encode(payload)\n    end\n\n    --self:debug(\"SEND MESSAGE: \" .. topic .. \" = \" .. json.encode(haPayload))\n    self:publish(\n        topic,\n        haPayload\n    )\nend\n\nfunction QuickApp:dispatchDeviceCreatedEvent(device)\n    local fibaroDeviceInfo = api.get(\"/devices/\" .. device.id)\n\n    if (fibaroDeviceInfo.visible and fibaroDeviceInfo.enabled) then\n        self:debug(\"Device created \" .. json.encode(fibaroDeviceInfo))\n        self:identifyAndPublishDeviceToMqtt(fibaroDeviceInfo)\n    end\nend\n\nfunction QuickApp:dispatchDeviceModifiedEvent(device)\n    self:debug(\"Device modified \" .. device.id)\n\n    self:dispatchDeviceRemovedEvent(device)\n\n    self:dispatchDeviceCreatedEvent(device)\nend\n\nfunction QuickApp:dispatchDeviceRemovedEvent(device)\n    self:debug(\"Device removed \" .. device.id)\n    for i, j in ipairs(self.mqttConventions) do\n        j:onDeviceRemoved(device)\n    end\n    --self:removeDeviceFromMqtt(device)\nend\n\nfunction QuickApp:dispatchCentralSceneEvent(device, event, payload)\n    -- PUBLISH DEVICE STATUS FOR HA AND NODE-RED\n    local topic = createGenericEventTopicName(device, \"CentralSceneEvent\", \"key\" .. event.data.keyAttribute)\n\n    createGenericEventTopicName(device, event.type)\n\n    self:publish(\n        topic,\n        event.data.keyId\n    )\nend\n\nfunction QuickApp:getDeviceDescription(device)\n    if device and device.name and device.id and device.roomName then\n        return device.name .. \" #\" .. device.id .. \" (\" .. tostring(device.roomName) .. \")\"\n    else\n        return device.id\n    end\nend\n"},{"name":"tools","isMain":false,"isOpen":true,"content":"local alphabet = {\r\n    [\"А\"] = \"A\",\r\n    [\"Б\"] = \"B\",\r\n    [\"В\"] = \"V\",\r\n    [\"Г\"] = \"G\",\r\n    [\"Д\"] = \"D\",\r\n    [\"Е\"] = \"E\",\r\n    [\"Ж\"] = \"Zh\",\r\n    [\"З\"] = \"Z\",\r\n    [\"И\"] = \"I\",\r\n    [\"І\"] = \"I\",\r\n    [\"Ї\"] = \"I\",\r\n    [\"Й\"] = \"I\",\r\n    [\"К\"] = \"K\",\r\n    [\"Л\"] = \"L\",\r\n    [\"М\"] = \"M\",\r\n    [\"Н\"] = \"N\",\r\n    [\"О\"] = \"O\",\r\n    [\"П\"] = \"P\",\r\n    [\"Р\"] = \"R\",\r\n    [\"С\"] = \"S\",\r\n    [\"Т\"] = \"T\",\r\n    [\"У\"] = \"U\",\r\n    [\"Ф\"] = \"F\",\r\n    [\"Х\"] = \"H\",\r\n    [\"Ч\"] = \"Ch\",\r\n    [\"Ц\"] = \"C\",\r\n    [\"Ш\"] = \"Sh\",\r\n    [\"Щ\"] = \"Shch\",\r\n    [\"И\"] = \"I\",\r\n    [\"Є\"] = \"E\",\r\n    [\"Э\"] = \"E\",\r\n    [\"Ю\"] = \"Ju\",\r\n    [\"Я\"] = \"Ja\",\r\n    [\"а\"] = \"a\",\r\n    [\"б\"] = \"b\",\r\n    [\"в\"] = \"v\",\r\n    [\"г\"] = \"g\",\r\n    [\"д\"] = \"d\",\r\n    [\"е\"] = \"e\",\r\n    [\"~\"] = \"e\",\r\n    [\"ж\"] = \"zh\",\r\n    [\"з\"] = \"z\",\r\n    [\"и\"] = \"i\",\r\n    [\"і\"] = \"i\",\r\n    [\"ї\"] = \"i\",\r\n    [\"й\"] = \"i\",\r\n    [\"к\"] = \"k\",\r\n    [\"л\"] = \"l\",\r\n    [\"м\"] = \"m\",\r\n    [\"н\"] = \"n\",\r\n    [\"о\"] = \"o\",\r\n    [\"п\"] = \"p\",\r\n    [\"р\"] = \"r\",\r\n    [\"с\"] = \"s\",\r\n    [\"т\"] = \"t\",\r\n    [\"у\"] = \"u\",\r\n    [\"ф\"] = \"f\",\r\n    [\"х\"] = \"h\",\r\n    [\"ч\"] = \"ch\",\r\n    [\"ц\"] = \"c\",\r\n    [\"ш\"] = \"sh\",\r\n    [\"щ\"] = \"shch\",\r\n    [\"ы\"] = \"i\",\r\n    [\"ь\"] = \"'\",\r\n    [\"є\"] = \"e\",\r\n    [\"э\"] = \"e\",\r\n    [\"ю\"] = \"ju\",\r\n    [\"я\"] = \"ja\"\r\n}\r\n\r\nfunction transliterate(input)\r\n    if (not input) then\r\n        return \"unknown_input_for_transliteration\"\r\n    end\r\n\r\n    local output = {}\r\n    local i = 1\r\n\r\n    for p, c in utf8.codes(input) do  \r\n        local char = utf8.char(c)\r\n        local outputCharacter = alphabet[char]\r\n\r\n        if not outputCharacter then\r\n        if (string.find(char, \"%a\") or string.find(char, \"%d\")) then\r\n            outputCharacter = char\r\n        else\r\n            outputCharacter = \"-\"\r\n        end\r\n\r\n        end\r\n        output[i] = outputCharacter\r\n        i = i + 1\r\n    end\r\n\r\n    --print(\"RESULT \" .. table.concat(output) ) \r\n\r\n    return table.concat(output) \r\nend\r\n\r\nfunction extractMetaInfoFromDeviceName(deviceName)\r\n    local metaInfo = {\r\n        pureName = deviceName,\r\n        autoPower = true,\r\n        turnOffTimeout = 10 * 60,\r\n        segmentId = -1,\r\n    }\r\n    \r\n    local s, e = string.find(deviceName, \"%[.+%]\")\r\n    if s and e then\r\n        local pureName = string.gsub(string.sub(deviceName, 1, s-1), \"%s+$\", \"\")\r\n        local metaStr = string.sub(deviceName, s+1, e-1)\r\n\r\n        metaInfo.pureName = pureName\r\n \r\n        local attrs = splitStringToNumbers(metaStr, \"%.\")\r\n        if attrs[1] == \"1\" then\r\n            metaInfo.autoPower = true\r\n        else\r\n            metaInfo.autoPower = false\r\n        end\r\n\r\n        if attrs[2] and attrs[2] ~= \"-\" then \r\n            metaInfo.turnOffTimeout = math.ceil(attrs[2] * 60)\r\n        end\r\n\r\n        if attrs[3] and attrs[3] ~= \"-\" then \r\n            metaInfo.segmentId = tonumber(attrs[3])\r\n            metaInfo.rooms = {}\r\n\r\n            local segmentIdsStr = fibaro.getGlobalVariable(\"segment_\" .. metaInfo.segmentId)\r\n            if segmentIdsStr then\r\n                local roomIds = splitStringToNumbers(segmentIdsStr, \",\")\r\n                for i,roomIdStr in ipairs(roomIds) do\r\n                    metaInfo.rooms[i] = roomIdStr\r\n                end\r\n            end\r\n        end\r\n    else\r\n        metaInfo.name = deviceName\r\n    end\r\n\r\n    return metaInfo\r\nend\r\n\r\nfunction splitString(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c:gsub(\"^%s*(.-)%s*$\", \"%1\") end)\r\n  return fields\r\nend\r\n\r\n\r\nfunction splitStringToNumbers(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c end)\r\n  return fields\r\nend\r\n\r\nfunction table_contains_value(tab, val)\r\n    if not tab then\r\n        return false\r\n    end\r\n    \r\n    for index, value in ipairs(tab) do\r\n        if value == val then\r\n            return true\r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction getDeviceIdFromTopic(topic)\r\n    local s, e = string.find(topic, \"%d+\")\r\n    --print(topic .. \" | \" .. tostring(s) .. \" | \" .. tostring(e))\r\n    if s then\r\n            return tonumber(string.sub(topic, s, e))\r\n    else\r\n        return 0\r\n    end\r\nend\r\n\r\nfunction createRootTopicName(device)\r\nreturn \"homeassistant/\" .. device.haType .. \"/\" .. device.id\r\n    --return \"homeassistant/\" .. device.haType .. \"/\" .. transliterate(device.roomName) .. \"/\" .. device.id .. \"-\" .. transliterate(device.name)\r\nend\r\n\r\nfunction createGenericEventTopicName(device, eventType, propertyName)\r\n    if (propertyName) then\r\n        return createRootTopicName(device) .. \"/events/\" .. eventType .. \"/\" .. propertyName\r\n    else\r\n        return createRootTopicName(device) .. \"/events/\" .. eventType\r\n    end\r\nend\r\n\r\nfunction createPropertyTopicName(device, propertyName)\r\n    return createGenericEventTopicName(device, \"DevicePropertyUpdatedEvent\", propertyName)     \r\nend\r\n\r\nfunction createCommandTopicName(device, commandName)\r\n    return createRootTopicName(device) .. \"/commands/\" .. \"set\" .. commandName:gsub(\"^%l\", string.upper)\r\nend\r\n\r\nfunction createHaConfigTopicName(device)\r\n    return createRootTopicName(device) .. \"/config\"\r\nend\r\n\r\nfunction createHaJsonAttributesTopicName(device)\r\n    return createRootTopicName(device) .. \"/config_json_attributes\"\r\nend\r\n\r\nfunction createFibaroEventPayload(device, propertyName, newValue) \r\n    -- THIS IS FIBARO EVENT FORMAT => DO NOT CHANGE VARIABLE NAMES\r\n    local payload = {\r\n        data = {\r\n            id = device.id,\r\n            property = propertyName,\r\n            newValue = newValue\r\n        },\r\n        type = \"DevicePropertyUpdatedEvent\",\r\n        created = os.time()\r\n    }\r\n\r\n    return payload\r\nend\r\n\r\nfunction isEmptyString(s)\r\n  return s == nil or s == \"\"\r\nend\r\n\r\nfunction base64Encode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    return ((data:gsub('.', function(x) \r\n        local r,b='',x:byte()\r\n        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\r\n        if (#x < 6) then return '' end\r\n        local c=0\r\n        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\r\n        return b:sub(c+1,c+1)\r\n    end)..({ '', '==', '=' })[#data%3+1])\r\nend\r\n\r\nfunction base64Decode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    data = string.gsub(data, '[^'..b..'=]', '')\r\n    return (data:gsub('.', function(x)\r\n        if (x == '=') then return '' end\r\n        local r,f='',(b:find(x)-1)\r\n        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\r\n        if (#x ~= 8) then return '' end\r\n        local c=0\r\n        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\r\n        return string.char(c)\r\n    end))\r\nend\r\n\r\nfunction decodeBase64Auth(encoded)\r\n    local decoded = base64Decode(encoded)\r\n    \r\n    local i = string.find(decoded, \":\")\r\n\r\n    if i then\r\n        return string.sub(decoded, 0, i-1), string.sub(decoded, i+1, string.len(decoded))\r\n    else\r\n        return nil\r\n    end\r\nend\r\n\r\nfunction shallowCopyTo(from, to)\r\n    local orig_type = type(from)\r\n    if orig_type == 'table' then\r\n        for orig_key, orig_value in pairs(from) do\r\n            to[orig_key] = orig_value\r\n        end\r\n    else -- number, string, boolean, etc\r\n        copy = from\r\n    end\r\nend\r\n\r\n\r\nfunction clone(orig)\r\n    local orig_type = type(orig)\r\n    local copy\r\n    if orig_type == 'table' then\r\n        copy = {}\r\n        for orig_key, orig_value in next, orig, nil do\r\n            copy[clone(orig_key)] = clone(orig_value)\r\n        end\r\n        --setmetatable(copy, clone(getmetatable(orig)))\r\n    else -- number, string, boolean, etc\r\n        copy = orig\r\n    end\r\n    return copy\r\nend\r\n\r\nfunction inheritFrom(orig)\r\n    return clone(orig)\r\nend"},{"name":"mqtt_convention_api","isMain":false,"isOpen":true,"content":"MqttConventionPrototype = {\r\n    type = \"'type' needs to be overriden\", \r\n    mqtt = \"MQTT connection must be established first\"\r\n}\r\n\r\nfunction MqttConventionPrototype:getLastWillMessage() \r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onConnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceCreated(device)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceRemoved(device)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onPropertyUpdateEvent(device, event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\n\r\nfunction MqttConventionPrototype:onCommand(event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDisconnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\n-----------------------------------\r\n-- HOME ASSISTANT \r\n-----------------------------------\r\n\r\nMqttConventionHomeAssistant = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomeAssistant.type = \"Home Assistant\"\r\nMqttConventionHomeAssistant.rootTopic = \"homeassistant/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomeAssistant:getDeviceTopic(device)\r\n    return self.rootTopic .. device.bridgeType .. \"/\" .. device.id .. \"/\"\r\nend\r\nfunction MqttConventionHomeAssistant:getGenericEventTopic(device, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomeAssistant:getPropertyTopic(device, propertyName)\r\n    return self:getGenericEventTopic(device, \"DevicePropertyUpdatedEvent\", propertyName)     \r\nend\r\nfunction MqttConventionHomeAssistant:getGenericCommandTopic(device, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(device) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getSetterTopic(device, propertyName)\r\n    return self:getGenericCommandTopic(device, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getLastWillMessage()\r\n    return {\r\n        topic = self.rootTopic .. \"hc3-dead\",\r\n        payload = \"true\"\r\n    }    \r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onConnected()\r\n    self.mqtt:publish(self.rootTopic .. \"hc3-dead\", \"false\")\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/set/+\")\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDisconnected()\r\n    self.mqtt:publish(self.rootTopic .. \"hc3-dead\", \"true\")\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceCreated(device)\r\n    local msg = {\r\n        unique_id = device.fibaroDevice.id,\r\n        name = device.fibaroDevice.name .. \" (\" .. device.roomName .. \")\",\r\n\r\n        availability_topic = self:getPropertyTopic(device, \"dead\"),\r\n        payload_available = \"false\",\r\n        payload_not_available = \"true\", \r\n\r\n        json_attributes_topic = self:getDeviceTopic(device) .. \"config_json_attributes\" \r\n    }\r\n\r\n    -- Setup \"true\"/\"false\" values to be used for device state tracking + JSON parser\r\n    if (device.bridgeRead) then\r\n        if (device.bridgeBinary and device.bridgeType ~= \"cover\") then \r\n            msg.payload_on = \"true\"\r\n            msg.payload_off = \"false\"\r\n        end\r\n        msg.value_template = \"{{ value_json.value }}\"\r\n    end\r\n    \r\n    ------------------------------------------\r\n    ---- READ\r\n    ------------------------------------------\r\n    -- Does device have binary state to share?\r\n    if (device.bridgeRead and device.bridgeBinary) then\r\n        msg.state_topic = self:getPropertyTopic(device, \"state\")\r\n    end\r\n    -- Does device have multilevel state to share?\r\n    if (device.bridgeRead and device.bridgeMultilevel) then\r\n        if (device.bridgeType == \"light\") then\r\n            msg.brightness_state_topic = self:getPropertyTopic(device, \"value\")\r\n            msg.brightness_value_template = \"{{ value_json.value }}\"\r\n        elseif (device.bridgeType == \"cover\") then\r\n            msg.position_topic = self:getPropertyTopic(device, \"value\")\r\n        elseif (device.bridgeType == \"sensor\") then\r\n            msg.state_topic = self:getPropertyTopic(device, \"value\")\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- WRITE\r\n    ------------------------------------------\r\n    -- Does device support binary write operations?\r\n    if (device.bridgeWrite and device.bridgeBinary) then\r\n        msg.command_topic = self:getSetterTopic(device, \"state\")\r\n    end\r\n    -- Does device support multilevel write operations?\r\n    if (device.bridgeWrite) and (device.bridgeMultilevel) then\r\n        if (device.bridgeType == \"light\") then\r\n            msg.brightness_command_topic = self:getSetterTopic(device, \"value\")\r\n            msg.brightness_scale = 99\r\n            msg.on_command_type = \"brightness\"\r\n        elseif (device.bridgeType == \"cover\") then\r\n            msg.set_position_topic = self:getSetterTopic(device, \"value\")\r\n            msg.position_open = 99 \r\n            msg.position_closed = 0\r\n\r\n            msg.payload_open = \"open\"\r\n            msg.payload_close = \"close\"\r\n            msg.payload_stop = \"stop\"\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- SENSOR SPECIFIC\r\n    ------------------------------------------\r\n    if (device.bridgeType == \"binary_sensor\" or device.bridgeType == \"sensor\") then\r\n        if (PrototypeDevice.bridgeUnitOfMeasurement ~= device.bridgeSubtype) then\r\n            msg.device_class = device.bridgeSubtype\r\n        end\r\n        if (PrototypeDevice.bridgeUnitOfMeasurement ~= device.bridgeUnitOfMeasurement) then\r\n            msg.unit_of_measurement = device.bridgeUnitOfMeasurement\r\n        end\r\n    end \r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"config\", json.encode(msg), {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"config_json_attributes\", json.encode(device.fibaroDevice), {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceRemoved(device)\r\n    self.mqtt:publish(\r\n        self:getDeviceTopic(device) .. \"config\", \r\n        \"\" \r\n    )\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onPropertyUpdateEvent(device, event)\r\n    local propertyName = event.data.property\r\n    local payload = {\r\n        id = device.id,\r\n        deviceName = device.name,\r\n        created = event.created,\r\n        timestamp = os.date(),\r\n        roomName = device.roomName\r\n    }\r\n\r\n    local value = (type(event.data.newValue) == \"number\" and event.data.newValue or tostring(event.data.newValue))\r\n\r\n    payload.value = string.lower(value)\r\n\r\n    local formattedPayload\r\n    if (propertyName == \"dead\") then\r\n        formattedPayload = tostring(payload.value)\r\n    else\r\n        formattedPayload = json.encode(payload)\r\n    end\r\n\r\n    --local simulation = (event.simulation == true)\r\n\r\n    self.mqtt:publish(self:getPropertyTopic(device, propertyName), formattedPayload, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onCommand(event)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[3])\r\n        local propertyName = topicElements[5]\r\n\r\n        local device = self.devices[deviceId]\r\n\r\n        if (propertyName == \"state\") then\r\n            device:setState(event.payload)\r\n        elseif (propertyName == \"value\") then\r\n            device:setValue(event.payload)\r\n        end\r\n\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- HOMIE\r\n-----------------------------------\r\n\r\nMqttConventionHomie = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomie.type = \"Homie\"\r\nMqttConventionHomie.rootTopic = \"homie/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomie:getDeviceTopic(device)\r\n    return self.rootTopic .. device.id .. \"/\"\r\nend\r\nfunction MqttConventionHomie:getGenericEventTopic(device, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomie:getPropertyTopic(device, propertyName)\r\n    return self:getGenericEventTopic(device, \"DevicePropertyUpdatedEvent\", propertyName)     \r\nend\r\nfunction MqttConventionHomie:getGenericCommandTopic(device, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(device) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomie:getSetterTopic(device, propertyName)\r\n    return self:getGenericCommandTopic(device, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomie:getLastWillMessage() \r\n    return {\r\n        topic = self.rootTopic .. \"hc3-dead\",\r\n        payload = \"true\"\r\n    }    \r\nend\r\n\r\nfunction MqttConventionHomie:onConnected()\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/+/set\")\r\nend\r\n\r\nfunction MqttConventionHomie:onDisconnected()\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceCreated(device)\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$homie\", \"2.1.0\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$name\", device.name .. \" (\" .. device.roomName .. \")\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$implementation\", \"Fibaro HC3 to MQTT bridge\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$nodes\", \"node\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$name\", device.name, {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$type\", \"\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$extensions\", \"\", {retain = true})\r\n\r\n    local properties = { }\r\n\r\n    if (device.bridgeRead) then\r\n        local propertyName = device.bridgeType\r\n        if (device.bridgeSubtype ~= PrototypeDevice.bridgeSubtype) then\r\n            propertyName = propertyName .. \" - \" .. device.bridgeSubtype\r\n        end\r\n\r\n\r\n        if (device.bridgeBinary) then\r\n            properties[\"state\"] = {\r\n                name = device.bridgeType,\r\n                datatype = \"boolean\",\r\n                settable = device.bridgeWrite, \r\n                retained = true,\r\n            }\r\n        end\r\n        if (device.bridgeMultilevel) then\r\n            properties[\"value\"] = {\r\n                name = device.bridgeType,\r\n                datatype = \"integer\",\r\n                settable = device.bridgeWrite,\r\n                retained = true,\r\n                unit = device.bridgeUnitOfMeasurement\r\n            }\r\n        end\r\n    end\r\n\r\n    local propertiesStr = \"\"\r\n    local firstParameter = true\r\n    for i, j in pairs(properties) do\r\n        if (not firstParameter) then\r\n            propertiesStr = propertiesStr .. \",\"\r\n        end\r\n        propertiesStr = propertiesStr .. i\r\n        firstParameter = false\r\n    end\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$properties\", propertiesStr, {retain = true})\r\n\r\n    for i, j in pairs(properties) do\r\n        local propertyTopic = self:getDeviceTopic(device) .. \"node/\" .. i .. \"/$\"\r\n        for m, n in pairs(j) do\r\n            self.mqtt:publish(propertyTopic .. m, tostring(n), {retain = true})\r\n        end\r\n    end\r\n\r\n    local homieState\r\n    if (device.dead) then\r\n        homieState = \"lost\"\r\n    else\r\n        homieState = \"ready\"\r\n    end\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$state\", homieState, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceRemoved(device)\r\n    print(\"TBD\")\r\nend\r\n\r\nfunction MqttConventionHomie:onPropertyUpdateEvent(device, event)\r\n    local propertyName = event.data.property\r\n\r\n    local value = (type(event.data.newValue) == \"number\" and event.data.newValue or tostring(event.data.newValue))\r\n\r\n    value = string.lower(value)\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/\" .. propertyName, value, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onCommand(event)\r\n    print(\"[MqttConventionHomie:onCommand]\" )\r\n    print(event.topic)\r\n    print(event.payload)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[2])\r\n        local propertyName = topicElements[4]\r\n\r\n        local device = self.devices[deviceId]\r\n\r\n        if (propertyName == \"state\") then\r\n            device:setState(event.payload)\r\n        elseif (propertyName == \"value\") then\r\n            device:setValue(event.payload)\r\n        end\r\n\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- FOR EXTENDED DEBUG PURPOSES\r\n-----------------------------------\r\n\r\nMqttConventionDebug = inheritFrom(MqttConventionPrototype) \r\nMqttConventionDebug.type = \"Debug\"\r\nfunction MqttConventionDebug:getLastWillMessage() \r\nend\r\nfunction MqttConventionDebug:onDeviceCreated(device)\r\nend\r\nfunction MqttConventionDebug:onDeviceRemoved(device)\r\nend\r\nfunction MqttConventionDebug:onPropertyUpdateEvent(device, event)\r\nend\r\nfunction MqttConventionDebug:onConnected()\r\nend\r\nfunction MqttConventionDebug:onCommand(event)\r\nend\r\nfunction MqttConventionDebug:onDisconnected()\r\nend\r\n\r\n-----------------------------------\r\n-- MQTT CONVENTION MAPPINGS\r\n-----------------------------------\r\n\r\nmqttConventionMappings = {\r\n    [\"home-assistant\"] = MqttConventionHomeAssistant,\r\n    [\"homie\"] = MqttConventionHomie,\r\n    [\"debug\"] = MqttConventionDebug\r\n} \r\n"},{"name":"device_api","isMain":false,"isOpen":true,"content":"----------------------------------- \r\n-- PROTOTYPE OBJECT \r\n-----------------------------------\r\n\r\nPrototypeDevice = {\r\n    bridgeType = \"'bridgeType' needs to be set\",\r\n    bridgeSubtype = \"'bridgeSubtype' needs to be set\",\r\n    bridgeBinary = \"'bridgeBinary' needs to be set\",\r\n    bridgeBinaryProperty = \"value\",\r\n    bridgeMultilevel = \"'bridgeMultilevel' needs to be set\",\r\n    bridgeRead = \"'bridgeRead' needs to be set\",\r\n    bridgeWrite = \"'bridgeWrite' needs to be set\",\r\n}\r\n\r\nfunction PrototypeDevice:new(fibaroDevice)\r\n    -- clone self, and copy fibaroDevice\r\n    local status, device = pcall(clone, self)\r\n    shallowCopyTo(fibaroDevice, device)\r\n\r\n    device.fibaroDevice = fibaroDevice\r\n    \r\n    device.roomName = fibaro.getRoomNameByDeviceID(device.id)\r\n\r\n    self:init(device)\r\n\r\n    return device\r\nend\r\n\r\nfunction PrototypeDevice:init(device)\r\n    -- to be overriden by subclasses when need to set up \"bridgeSubtype\" property\r\nend\r\n\r\nfunction PrototypeDevice:setState(state)\r\n    if self.bridgeBinary and self.bridgeWrite then\r\n        --fibaro.call(self.id, \"setState\", state)\r\n        \r\n        if (state == \"true\") then\r\n            print(\"Turn ON for \" .. self.id)\r\n            fibaro.call(self.id, \"turnOn\")\r\n        elseif (state == \"false\") then\r\n            print(\"Turn OFF for \" .. self.id)\r\n            fibaro.call(self.id, \"turnOff\")\r\n        else\r\n            print(\"Unexpected value: \" .. json.encode(event))\r\n        end\r\n        \r\n    else\r\n        print(\"WARNING: trying to turn ON undesignated devices\")\r\n    end\r\nend\r\n\r\nfunction PrototypeDevice:setValue(value)\r\n    if self.bridgeMultilevel and self.bridgeWrite then\r\n        fibaro.call(self.id, \"setValue\", value)\r\n    else\r\n        print(\"WARNING: trying to turn ON undesignated devices\")\r\n    end\r\nend\r\n\r\nfunction PrototypeDevice.isSupported(fibaroDevice)\r\n    print(\"'isSupported' function is mandatory for implementation\")\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY SWITCH\r\n-----------------------------------\r\n\r\nSwitch = inheritFrom(PrototypeDevice)\r\nSwitch.bridgeType = \"switch\"\r\nSwitch.bridgeBinary = true\r\nSwitch.bridgeMultilevel = false\r\nSwitch.bridgeRead = true\r\nSwitch.bridgeWrite = true\r\n\r\nfunction Switch.isSupported(fibaroDevice)\r\n    if (fibaroDevice.type == \"com.fibaro.binarySwitch\") and not table_contains_value(fibaroDevice.interfaces, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY LIGHT\r\n-----------------------------------\r\n\r\nLight = inheritFrom(PrototypeDevice)\r\nLight.bridgeType = \"light\"\r\nLight.bridgeBinary = true\r\nLight.bridgeMultilevel = false\r\nLight.bridgeRead = true\r\nLight.bridgeWrite = true\r\n\r\nfunction Light.isSupported(fibaroDevice)\r\n    if (fibaroDevice.type == \"com.fibaro.binarySwitch\") and table_contains_value(fibaroDevice.interfaces, \"light\")      then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL LIGHT (DIMMERS)\r\n-----------------------------------\r\n\r\nDimmer = inheritFrom(PrototypeDevice)\r\nDimmer.bridgeType = \"light\"\r\nDimmer.bridgeBinary = true\r\nDimmer.bridgeMultilevel = true\r\nDimmer.bridgeRead = true\r\nDimmer.bridgeWrite = true\r\n\r\nfunction Dimmer.isSupported(fibaroDevice)\r\n    if (fibaroDevice.baseType == \"com.fibaro.multilevelSwitch\") and table_contains_value(fibaroDevice.interfaces, \"light\")      then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY SENSOR (DOOR, MOTION, WATER LEAK, FIRE, SMORE SENSORSMULTILEVEL FOR TEMPERATURE, ETC)\r\n-----------------------------------\r\n\r\nBinarySensor = inheritFrom(PrototypeDevice)\r\nBinarySensor.bridgeType = \"binary_sensor\"\r\nBinarySensor.bridgeBinary = true\r\nBinarySensor.bridgeMultilevel = false\r\nBinarySensor.bridgeRead = true \r\nBinarySensor.bridgeWrite = false\r\n\r\nfunction BinarySensor.isSupported(fibaroDevice)\r\n    if (string.find(fibaroDevice.baseType, \"Sensor\")) or (string.find(fibaroDevice.baseType, \"sensor\")) then\r\n        if (fibaroDevice.baseType ~= \"com.fibaro.multilevelSensor\") and (fibaroDevice.type ~= \"com.fibaro.multilevelSensor\") then\r\n            return true \r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction BinarySensor:init(device)\r\n    -- set unit of measurement\r\n    device.bridgeUnitOfMeasurement = device.properties.unit\r\n\r\n    if (device.type == \"com.fibaro.motionSensor\") or (device.baseType == \"com.fibaro.motionSensor\") then\r\n        device.bridgeSubtype = \"motion\"\r\n    elseif (device.baseType == \"com.fibaro.floodSensor\") then\r\n        device.bridgeSubtype = \"moisture\" \r\n    elseif (device.baseType == \"com.fibaro.doorWindowSensor\") then\r\n        if (device.type == \"com.fibaro.doorSensor\") then\r\n            device.bridgeSubtype = \"door\"\r\n        else\r\n            print(\"[BinarySensor.init] Uknown doow/window sensor \" .. device.id .. \" \" .. device.name)\r\n        end\r\n    elseif (device.baseType == \"com.fibaro.lifeDangerSensor\") then\r\n        device.bridgeSubtype = \"safety\"\r\n    elseif (device.baseType == \"com.fibaro.smokeSensor\") or (device.type == \"com.fibaro.smokeSensor\") then\r\n        device.bridgeSubtype = \"smoke\"\r\n    else\r\n        print(\"[BinarySensor.init] Unknown binary sensor\")\r\n        device.bridgeSubtype = nil\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL SENSOR (TEMPERATURE, HUMIDITY, VOLTAGE, ETC) \r\n-----------------------------------\r\n\r\nMultilevelSensor = inheritFrom(PrototypeDevice)\r\nMultilevelSensor.bridgeType = \"sensor\"\r\nMultilevelSensor.bridgeBinary = false\r\nMultilevelSensor.bridgeMultilevel = true\r\nMultilevelSensor.bridgeUnitOfMeasurement = \"'unit of measurement' needs to be initialized\"\r\nMultilevelSensor.bridgeRead = true\r\nMultilevelSensor.bridgeWrite = false\r\n\r\nfunction MultilevelSensor.isSupported(fibaroDevice)\r\n    if (string.find(fibaroDevice.baseType, \"Sensor\")) or (string.find(fibaroDevice.baseType, \"sensor\")) then\r\n        if (fibaroDevice.baseType == \"com.fibaro.multilevelSensor\") or (fibaroDevice.type == \"com.fibaro.multilevelSensor\") then\r\n            return true \r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction MultilevelSensor:init(device)\r\n    -- initialize unit of measurement\r\n    device.bridgeUnitOfMeasurement = device.properties.unit\r\n\r\n    -- initialize subtype\r\n    if (device.type == \"com.fibaro.temperatureSensor\") then\r\n        device.bridgeSubtype = \"temperature\"\r\n        device.bridgeUnitOfMeasurement = \"°\" .. device.properties.unit\r\n    elseif (device.type == \"com.fibaro.lightSensor\") then\r\n        device.bridgeSubtype = \"illuminance\"\r\n    elseif (device.properties.unit == \"V\") then\r\n        device.bridgeSubtype = \"voltage\"\r\n    elseif (device.properties.unit == \"A\") then\r\n        device.bridgeSubtype = \"current\"\r\n    elseif (device.properties.unit == \"W\" or device.properties.unit == \"kW\" or device.properties.unit == \"kVA\") then\r\n        device.bridgeSubtype = \"power\"\r\n    else\r\n        print(\"[MultilevelSensor.init] Unknown multilevel sensor \" .. tostring(device.id) .. \" \" .. tostring(device.name))\r\n        device.bridgeSubtype = nil\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL SWITCH (COVER)\r\n-----------------------------------\r\n\r\nCover = inheritFrom(PrototypeDevice)\r\nCover.bridgeType = \"cover\"\r\nCover.bridgeBinary = true\r\nCover.bridgeMultilevel = true\r\nCover.bridgeRead = true\r\nCover.bridgeWrite = true\r\n\r\nfunction Cover.isSupported(fibaroDevice)\r\n    if (fibaroDevice.baseType == \"com.fibaro.baseShutter\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction Cover:setState(state)\r\n    print(\"[Cover:setState] setState \" .. state)\r\n    if (state == \"open\") then\r\n        self:setValue(99)\r\n    elseif (state == \"close\") then\r\n        self:setValue(0)\r\n    elseif (state == \"stop\") then\r\n        fibaro.call(self.id, \"stop\")\r\n    else\r\n        print(\"Unsupported state\")\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- HELPER FUNCTIONS - IDENTIFY DEVICE BRIDGE TYPE BY LOOKING AT FIBARO DEVICE TYPE\r\n-----------------------------------\r\n\r\ndeviceTypeMappings = {\r\n    Switch, -- binary switch\r\n    Cover, -- multilevel switch\r\n    Light, -- binary light\r\n    Dimmer, -- multilevel light\r\n    BinarySensor,\r\n    MultilevelSensor\r\n}  \r\n\r\nfunction identifyDevice(fibaroDevice)\r\n    for i, j in ipairs(deviceTypeMappings) do\r\n        if (j.isSupported(fibaroDevice)) then\r\n            return j:new(fibaroDevice)\r\n        end\r\n    end\r\n\r\n    return nil\r\nend\r\n\r\n-----------------------------------\r\n-- HELPER FUNCTIONS - FIX \"WRONG\" DEVICE TYPES FROM FIBARO DEVICE API\r\n-----------------------------------\r\n\r\nlocal fibaroBaseTypeOverride = {\r\n    [\"com.fibaro.FGR\"] = \"com.fibaro.baseShutter\",\r\n    [\"com.fibaro.FGMS001\"] = \"com.fibaro.motionSensor\"\r\n}\r\n\r\nlocal fibaroTypeOverride = { \r\n    [\"com.fibaro.FGKF601\"] = \"com.fibaro.keyFob\",\r\n    [\"com.fibaro.FGD212\"] = \"com.fibaro.dimmer\",\r\n    [\"com.fibaro.FGMS001v2\"] = \"com.fibaro.motionSensor\",\r\n    [\"com.fibaro.FGFS101\"] = \"com.fibaro.floodSensor\" \r\n}\r\n\r\nfunction getFibaroDevicesByFilter(filter)\r\n    local filterStr = \"\"\r\n\r\n    local firstParameter = true\r\n    for i, j in pairs(filter) do\r\n        if (not firstParameter) then\r\n            filterStr = filterStr .. \"&\"\r\n        end\r\n        filterStr = filterStr .. i .. \"=\" .. tostring(j)\r\n        firstParameter = false\r\n    end\r\n\r\n    print(\"Device filter URI '\" .. \"/devices?\" .. filterStr .. \"'\")\r\n\r\n    local allDevices = api.get(\"/devices?\" .. filterStr)\r\n\r\n    for i, j in ipairs(allDevices) do\r\n        overrideFibaroDeviceType(j)\r\n    end\r\n\r\n    return allDevices\r\nend\r\n\r\nfunction getFibaroDeviceById(id)\r\n    local fibaroDevice = api.get(\"/devices/\" .. id)\r\n\r\n    overrideFibaroDeviceType(fibaroDevice)\r\n\r\n    return fibaroDevice\r\nend\r\n\r\nfunction overrideFibaroDeviceType(fibaroDevice)\r\n    local overrideType = fibaroTypeOverride[fibaroDevice.type]\r\n    if overrideType then \r\n        fibaroDevice.type = overrideType\r\n    end\r\n\r\n    local overrideBaseType = fibaroBaseTypeOverride[fibaroDevice.baseType]\r\n    if overrideBaseType then \r\n        fibaroDevice.baseType = overrideBaseType\r\n    end\r\nend\r\n\r\n-- TODO: com.fibaro.seismometer\r\n-- TODO: com.fibaro.accelerometer\r\n\r\n-- motion eye => seismometer\r\n--  \"type\": \"com.fibaro.seismometer\",\r\n--  \"baseType\": \"com.fibaro.multilevelSensor\",\r\n\r\n-- motion eye => accelerometer\r\n--  \"type\": \"com.fibaro.accelerometer\",\r\n--  \"baseType\": \"com.fibaro.sensor\",\r\n\r\n-- tamper for flood sensor and other Fibaro sensors\r\n-- \"type\": \"com.fibaro.motionSensor\",\r\n-- \"baseType\": \"com.fibaro.securitySensor\","}]}