{"name":"HC3 <-> MQTT Bridge","type":"com.fibaro.binarySwitch","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_51"},"sections":{"items":[{"components":[{"name":"availableDevices","style":{"weight":"1.2"},"text":"Available devices: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bridgedDevices","style":{"weight":"1.2"},"text":"Bridged devices: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bootTime","style":{"weight":"1.2"},"text":"Boot time: -","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_51"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"mqttUrl","type":"string","value":"mqtt://<host>:1883"},{"name":"mqttKeepAlive","type":"string","value":"15"},{"name":"mqttUsername","type":"string","value":"your_mqtt_username"},{"name":"mqttPassword","type":"string","value":"your_mqtt_password"},{"name":"mqttConvention","type":"string","value":"home-assistant"},{"name":"developmentMode","type":"string","value":"false"},{"name":"hc3Username","type":"string","value":"your_hc3_username"},{"name":"hc3Password","type":"string","value":"your_hc3_password"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"function QuickApp:onInit()\n    self:debug(\"-------------------------\")\n    self:debug(\"HC3 <-> MQTT BRIDGE\")\n    self:debug(\"-------------------------\")\n\n    self:turnOn() \nend\n\nfunction QuickApp:publish(topic, payload)\n    self.mqtt:publish(topic, tostring(payload), {retain = true})\nend\n\nfunction QuickApp:turnOn()\n    self:establishMqttConnection()\nend\n\nfunction QuickApp:turnOff()\n    self:disconnectFromMqttAndHc3()\n    self:updateProperty(\"value\", false)\n    self:debug(\"HC3-to-MQTT bridge shutdown sequence complete\")\nend\n\nfunction QuickApp:establishMqttConnection() \n    self.devices = {}\n\n    -- IDENTIFY WHICH MQTT CONVENTIONS TO BE USED (e.g. Home Assistant, Homio, etc)\n    self.mqttConventions = { }\n    local mqttConventionStr = self:getVariable(\"mqttConvention\")\n    if (isEmptyString(mqttConventionStr)) then\n        self.mqttConventions[0] = MqttConventionHomeAssistant\n    else\n        local arr = splitString(mqttConventionStr, \",\")\n        for i, j in ipairs(arr) do\n            local convention = mqttConventionMappings[j]\n            if (convention) then\n                self.mqttConventions[i] = clone(convention)\n            end\n        end\n    end\n\n    local mqttConnectionParameters = self:getMqttConnectionParameters()\n    self:trace(\"MQTT Connection Parameters: \" .. json.encode(mqttConnectionParameters))\n\n    local mqttClient = mqtt.Client.connect(\n                                    self:getVariable(\"mqttUrl\"),\n                                    mqttConnectionParameters) \n\n    mqttClient:addEventListener('connected', function(event) self:onConnected(event) end)\n    mqttClient:addEventListener('closed', function(event) self:onClosed(event) end)\n    mqttClient:addEventListener('message', function(event) self:onMessage(event) end)\n    mqttClient:addEventListener('error', function(event) self:onError(event) end)    \n    \n    -- skip event handlers to aid higher performance\n    --mqttClient:addEventListener('subscribed', function(event) self:onSubscribed(event) end)\n    --mqttClient:addEventListener('published', function(event) self:onPublished(event) end)\n\n    self.mqtt = mqttClient\nend\n\nfunction QuickApp:getMqttConnectionParameters()\n    local mqttConnectionParameters = {\n        -- pickup last will from primary MQTT Convention provider\n        lastWill = self.mqttConventions[1]:getLastWillMessage()\n    }\n\n    -- MQTT CLIENT ID (OPTIONAL)\n    local mqttClientId = self:getVariable(\"mqttClientId\")\n    if (isEmptyString(mqttClientId)) then\n        local autogeneratedMqttClientId = \"HC3-\" .. plugin.mainDeviceId .. \"-\" .. tostring(os.time())\n        self:warning(\"All is good - we have just autogenerated mqttClientId for you \\\"\" .. autogeneratedMqttClientId .. \"\\\"\")\n        mqttConnectionParameters.clientId = autogeneratedMqttClientId\n    else\n        mqttConnectionParameters.clientId = mqttClientId\n    end\n\n    -- MQTT KEEP ALIVE PERIOD\n    local mqttKeepAlivePeriod = self:getVariable(\"mqttKeepAlive\")\n    if (mqttKeepAlivePeriod) then\n        mqttConnectionParameters.keepAlivePeriod = tonumber(mqttKeepAlivePeriod)\n    else\n        mqttConnectionParameters.keepAlivePeriod = 30\n    end\n\n    -- MQTT AUTH (USERNAME/PASSWORD)\n    local mqttUsername = self:getVariable(\"mqttUsername\")\n    local mqttPassword = self:getVariable(\"mqttPassword\")\n\n    if (mqttUsername) then\n        mqttConnectionParameters.username = mqttUsername\n    end\n    if (mqttPassword) then\n        mqttConnectionParameters.password = mqttPassword\n    end\n\n    return mqttConnectionParameters\nend\n\nfunction QuickApp:disconnectFromMqttAndHc3()\n    self.hc3ConnectionEnabled = false\n    self:closeMqttConnection()\n    self:debug(\"Disconnected from MQTT\")\nend\n\nfunction QuickApp:closeMqttConnection()\n    for i, j in ipairs(self.mqttConventions) do\n        if (j.mqtt ~= MqttConventionPrototype.mqtt) then\n            j:onDisconnected()\n        end\n    end\n\n    self.mqtt:disconnect()\nend\n\nfunction QuickApp:onClosed(event)\n    self:updateProperty(\"value\", false)\nend\n\nfunction QuickApp:onError(event)\n    self:error(\"MQTT ERROR: \" .. json.encode(event))\n    if event.code == 2 then\n        self:warning(\"MQTT username and/or password could be indicated wrongly\")\n    end\n    self:turnOff()\n    self:scheduleReconnectToMqtt();\nend\n\nfunction QuickApp:scheduleReconnectToMqtt()\n    fibaro.setTimeout(10000, function() \n        self:debug(\"Attempt to reconnect to MQTT...\")\n        self:establishMqttConnection()\n    end)\nend\n\nfunction QuickApp:onMessage(event)\n    for i, j in ipairs(self.mqttConventions) do\n        j:onCommand(event)\n    end\nend\n\nfunction QuickApp:onConnected(event) \n    self:debug(\"MQTT connection established\")\n\n    for _, mqttConvention in ipairs(self.mqttConventions) do\n        mqttConvention.mqtt = self.mqtt\n        mqttConvention.devices = self.devices\n        mqttConvention:onConnected()\n    end\n\n    self:discoverDevicesAndPublishToMqtt()\n\n    self.hc3ConnectionEnabled = true\n    self:scheduleHc3EventsFetcher()\n\n    self:updateProperty(\"value\", true)\nend\n\nfunction QuickApp:identifyAndPublishDeviceToMqtt(fibaroDevice)\n    local bridgedDevice = identifyDevice(fibaroDevice)\n    self:publishDeviceToMqtt(bridgedDevice)\nend\n\nfunction QuickApp:discoverDevicesAndPublishToMqtt()\n    local startTime = os.time()\n\n    local fibaroDevices = self:discoverDevices()\n    \n    self:identifyDevices(fibaroDevices)\n\n    for _, device in pairs(self.devices) do\n        self:publishDeviceToMqtt(device)\n    end\n\n    local diff = os.time() - startTime   \n\n    local bridgedDevices = 0\n    for _, _ in pairs(self.devices) do\n        bridgedDevices = bridgedDevices + 1\n    end\n    \n    self:updateView(\"availableDevices\", \"text\", \"Available devices: \" .. #fibaroDevices)\n    self:updateView(\"bridgedDevices\", \"text\", \"Bridged devices: \" .. bridgedDevices) \n    self:updateView(\"bootTime\" , \"text\", \"Boot time: \" .. diff .. \"s\")\n\n    self:debug(\"----------------------------------\")\n    self:debug(\"Device discovery has been complete\")\n    self:debug(\"----------------------------------\")\n\n    return haDevices\nend\n\nfunction QuickApp:discoverDevices()\n    local fibaroDevices\n\n    local developmentModeStr = self:getVariable(\"developmentMode\")\n    if ((not developmentModeStr) or (developmentModeStr ~= \"true\")) then\n        self:debug(\"Bridge mode: PRODUCTION\")\n\n        fibaroDevices = getFibaroDevicesByFilter({\n            enabled = true,\n            visible = true\n        })\n    else\n        --smaller number of devices for development and testing purposes\n        self:debug(\"Bridge mode: DEVELOPMENT\")\n\n        fibaroDevices = {\n            getFibaroDeviceById(41), -- switch Onyx light,\n            getFibaroDeviceById(42), -- switch Fan,\n            getFibaroDeviceById(260), -- iPad screen\n            getFibaroDeviceById(287), -- door sensor\n            getFibaroDeviceById(54), -- motion sensor\n            getFibaroDeviceById(92), -- roller shutter\n            getFibaroDeviceById(78), -- dimmer\n            getFibaroDeviceById(66), -- temperature sensor\n            getFibaroDeviceById(56), -- light sensor (lux)\n            getFibaroDeviceById(245), -- volts\n            getFibaroDeviceById(105), -- on/off thermostat from CH\n            getFibaroDeviceById(106), -- temperature sensor\n            getFibaroDeviceById(120), -- IR thermostat from CH\n            getFibaroDeviceById(122), -- temperature sensor\n            getFibaroDeviceById(335), -- on/off thermostat from Qubino\n            getFibaroDeviceById(336), -- temperature sensor \n            getFibaroDeviceByInfo(json.decode(\"\"))\n        }\n    end\n\n    return fibaroDevices \nend\n\nfunction QuickApp:identifyDevices(fibaroDevices) \n    for _, fibaroDevice in ipairs(fibaroDevices) do\n        local device = identifyDevice(fibaroDevice)\n        if (device) then\n            self:debug(\"Device \" .. self:getDeviceDescription(device) .. \" identified as \" .. device.bridgeType)\n            self.devices[device.id] = device\n\n            -- ***** ToDo: move to identifyDevice function, aiming support deviceRemoved and deviceModified and deviceCreated events\n            -- Does device support energy monitoring? Create a dedicated sensor for Home Assistant\n            if (table_contains_value(fibaroDevice.interfaces, \"energy\")) then \n                local energyDevice = self:createLinkedSensorDevice(device, \"energy\")\n                self.devices[energyDevice.id] = energyDevice\n            end\n\n            -- Does device support power monitoring? Create a dedicated sensor for Home Assistant\n            if (table_contains_value(fibaroDevice.interfaces, \"power\")) then \n                local powerDevice = self:createLinkedSensorDevice(device, \"power\")\n                self.devices[powerDevice.id] = powerDevice\n            end\n        else\n            self:debug(\"Couldn't recognize device #\" .. fibaroDevice.id .. \" - \" .. fibaroDevice.name .. \" - \" .. fibaroDevice.baseType .. \" - \" .. fibaroDevice.type)\n        end\n    end\nend\n\nfunction QuickApp:createLinkedSensorDevice(fromDevice, linkedProperty)\n    local linkedUnit\n    --local last_reset\n    if (linkedProperty == \"energy\") then\n        linkedUnit = \"kWh\"\n        --lastReset = \"1970-01-03T00:00:00+00:00\"\n    elseif (linkedProperty == \"power\") then\n        linkedUnit = \"W\"\n    end\n\n    local newFibaroLinkedSensor = {\n        id = fromDevice.id .. \"_\" .. linkedProperty,\n        baseType = \"com.fibaro.multilevelSensor\",\n        type = \"com.fibaro.\" .. linkedProperty .. \"Sensor\",\n        name = fromDevice.name,  \n        roomID = fromDevice.roomID,\n        roomName = fromDevice.roomName,\n        parentId = fromDevice.parentId,\n        linkedDevice = fromDevice,\n        linkedProperty = linkedProperty,\n        properties = {\n            unit = linkedUnit,\n            dead = false,\n            --lastReset = lastReset\n        },\n        comment = \"This device has been autogenerated by HC3 <-> Home Assistant bridge to adjust the data model difference between Fibaro HC3 and Home Assistant. Fibaro considers this device and the '\" .. linkedProperty .. \"' meter to be the single entity. And Home Asisstant requires these to be separate devices\"\n    }\n\n    local newLinkedSensor = identifyDevice(newFibaroLinkedSensor)\n    newLinkedSensor.fibaroDevice.linkedDevice = nil\n\n    return newLinkedSensor\nend\n\nfunction QuickApp:publishDeviceToMqtt(device)\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE EXISTANCE\n    ------------------------------------------------------------------\n    for i, j in ipairs(self.mqttConventions) do\n        j:onDeviceCreated(device)\n    end\n\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE CURRENT STATE => BY SIMULATING HC3 EVENTS\n    ------------------------------------------------------------------\n    self:simulatePropertyUpdate(device, \"dead\", device.properties.dead)\n    self:simulatePropertyUpdate(device, \"state\", device.properties.state)\n    self:simulatePropertyUpdate(device, \"value\", device.properties.value)\n    self:simulatePropertyUpdate(device, \"heatingThermostatSetpoint\", device.properties.heatingThermostatSetpoint)\n    self:simulatePropertyUpdate(device, \"thermostatMode\", device.properties.thermostatMode)\n    self:simulatePropertyUpdate(device, \"energy\", device.properties.energy)\n    self:simulatePropertyUpdate(device, \"power\", device.properties.power)\n    --self:simulatePropertyUpdate(device, \"lastReset\", device.properties.lastReset)\nend\n\nfunction QuickApp:onPublished(event)\n    -- do nothing, for now\nend\n\n-- FETCH HC3 EVENTS\nlocal lastRefresh = 0\nlocal http = net.HTTPClient()\n\nfunction QuickApp:scheduleHc3EventsFetcher()\n    -- hc3Auth variable is deprecated as being overcomplex for QuickApp users\n    local hc3Auth = nil\n    --local hc3Auth = self:getVariable(\"hc3Auth\")\n    if (isEmptyString(hc3Auth)) then\n        local hc3Username = self:getVariable(\"hc3Username\")\n        local hc3Password = self:getVariable(\"hc3Password\")\n        if (isEmptyString(hc3Username) or isEmptyString(hc3Password)) then\n            self:warning(\"You have not provided Fibaro HC3 username and password, as result you have experimental 'passwordless' mode enabled\")\n            --error(\"You need to provide username/password for your Fibaro HC3\")\n        end\n        hc3Auth = base64Encode(hc3Username .. \":\" .. hc3Password)\n    end\n\n    self.hc3Auth = hc3Auth\n\n    self:readHc3EventAndScheduleFetcher()\n    self:debug(\"---------------------------------------------------\")\n    self:debug(\"Started monitoring events from Fibaro Home Center 3\")\n    self:debug(\"---------------------------------------------------\")\nend\n\nfunction QuickApp:readHc3EventAndScheduleFetcher()\n\n    if self.hc3Auth then\n        -- This a reliable and high-performance method to get events from Fibaro HC3, by using non-blocking HTTP calls. Where 'passwordles' api.get() has a rick of blocking calls => peformance isues\n\n        local requestUrl = \"http://localhost:11111/api/refreshStates?last=\" .. lastRefresh\n        --self:debug(\"Try fetch events from \" .. requestUrl .. \" | \" .. tostring(self.hc3ConnectionEnabled))\n\n        local stat, res = http:request(\n            requestUrl,\n            {\n            options = {\n                headers = {\n                    [\"Authorization\"] = \"Basic \" .. self.hc3Auth,\n                }\n            },\n            success=function(res)\n                local data\n                if (res and not isEmptyString(res.data)) then\n                    self:processFibaroHc3Events(json.decode(res.data))\n                else\n                    self:error(\"Error while fetching events from Fibaro HC3. Response status code is \" .. res.status .. \". HTTP response body is '\" .. json.encode(res) .. \"'\")\n                    self:turnOff()\n                end\n            end,\n            error=function(res) \n                self:error(\"Error while fetching Fibaro HC3 events \" .. json.encode(res))\n                self:turnOff()\n            end\n        })\n\n    else\n        -- Experimental 'passwordless' mode for Fibaro HC3\n        local res = api.get(\"/refreshStates?last=\" .. lastRefresh)\n        self:processFibaroHc3Events(res) \n    end\n\n    if (self.hc3ConnectionEnabled) then\n        local delay\n        if self.gotError then\n            self:warning(\"Got error - retry in 1s\")\n            delay = 1000\n        else\n            delay = 1000\n        end\n\n        fibaro.setTimeout(delay, function()\n            self:readHc3EventAndScheduleFetcher()\n        end)\n    else\n        self:debug(\"Disconnected from HC3 (got flagged to stop reading HC3 events)\")\n    end\n\nend\n\nfunction QuickApp:processFibaroHc3Events(data)\n    -- Debug for \"paswordless\" mode. Doesn't work well for now due to blocking api-calls. Significantly reducing performance\n\n    if not self.hc3ConnectionEnabled then\n        return\n    end\n\n    self.gotError = false\n    if (data.status ~= 200 and data.status ~= \"IDLE\") then\n        self:error(\"Unexpected response status \" .. tostring(data.status))\n        self:turnOff()\n    end\n\n    local events = data.events --= data.status == 200 and json.decode(data.data)\n\n\n    if (data.last) then\n        lastRefresh = data.last\n    end\n\n    if events and #events>0 then \n        -- self:debug(json.encode(events))\n        for i, v in ipairs(events) do\n            self:dispatchFibaroEventToMqtt(v)\n        end\n    end\nend\n\nfunction QuickApp:simulatePropertyUpdate(device, propertyName, value)\n    if value ~= nil then\n        local event = createFibaroEventPayload(device, propertyName, value)\n        event.simulation = true\n        self:dispatchFibaroEventToMqtt(event)\n    end\nend\n\nfunction QuickApp:dispatchFibaroEventToMqtt(event)\n    --self:debug(\"Event: \" .. json.encode(event))\n    if (not event) then\n        self:error(\"No event found\")\n        return\n    end\n\n    if (not event.data) then\n        self:error(\"No event data found\")\n        return\n    end\n\n    local deviceId = event.data.id or event.data.deviceId\n\n    if not deviceId then\n        -- deviceId is must have for processing logic\n        self:warning(\"No device id for \" .. json.encode(event))\n        return\n    end \n    \n    local propertyName = event.data.property\n    if not propertyName then\n        propertyName = \"unknown\"\n    end\n\n    if (not event.type) then\n        event.type = \"unknown\"\n    end\n\n    local device = self.devices[deviceId]\n\n    if (device) then\n\n        if (event.type == \"DevicePropertyUpdatedEvent\") then\n\n            -- *** OVERRIDE FIBARO PROPERTY NAMES, FOR BEING MORE CONSISTENT AND THUS EASIER TO HANDLE \n            if (device.bridgeType == \"binary_sensor\") and (propertyName == \"value\") then\n                -- Fibaro uses state/value fields inconsistently for binary sensor. Replace value --> state field\n                event.data.property = \"state\"\n            end\n\n            local value = event.data.newValue\n            if (isNumber(value)) then\n                value = round(value, 2)\n            end\n            event.data.newValue = (type(value) == \"number\" and value or tostring(value))\n\n            for i, j in ipairs(self.mqttConventions) do\n                j:onPropertyUpdated(device, event)\n            end\n        elseif (event.type == \"DeviceModifiedEvent\") then\n            self:dispatchDeviceModifiedEvent(device)\n        elseif (event.type == \"DeviceCreatedEvent\") then\n            self:dispatchDeviceCreatedEvent(device)\n        elseif (event.type == \"DeviceRemovedEvent\") then \n            self:dispatchDeviceRemovedEvent(device)\n        elseif (event.type == \"DeviceActionRanEvent\") then\n            if (event.data.actionName == \"turnOn\" or event.data.actionName == \"turnOff\") then\n                --self:rememberLastHc3CommandTime(deviceId, event.sourceType)\n            end\n        else\n            self:debug(\"Unsupported event type received \\\"\" .. tostring(event.type) .. \"\\\". All is good - feel free contact this QuickApp developer to get it supported\")\n        end\n\n    end\nend\n\nfunction QuickApp:rememberLastMqttCommandTime(deviceId)\n    self.lastMqttCommandTime[deviceId] = os.time()\nend\n\nfunction QuickApp:dispatchDeviceCreatedEvent(device)\n    local fibaroDevice = api.get(\"/devices/\" .. device.id)\n\n    if (fibaroDevice.visible and fibaroDevice.enabled) then\n        self:debug(\"Device created \" .. json.encode(fibaroDevice))\n        self:identifyAndPublishDeviceToMqtt(fibaroDevice)\n    end\nend\n\nfunction QuickApp:dispatchDeviceModifiedEvent(device)\n    self:debug(\"Device modified \" .. device.id)\n\n    self:dispatchDeviceRemovedEvent(device)\n\n    self:dispatchDeviceCreatedEvent(device)\nend\n\nfunction QuickApp:dispatchDeviceRemovedEvent(device)\n    self:debug(\"Device removed \" .. device.id)\n    for i, j in ipairs(self.mqttConventions) do\n        j:onDeviceRemoved(device)\n    end\n    --self:removeDeviceFromMqtt(device)\nend\n\nfunction QuickApp:dispatchCentralSceneEvent(device, event, payload)\n    -- PUBLISH DEVICE STATUS TO HOME ASSISTANT\n    local topic = createGenericEventTopicName(device, \"CentralSceneEvent\", \"key\" .. event.data.keyAttribute)\n\n    createGenericEventTopicName(device, event.type)\n\n    self:publish(\n        topic,\n        event.data.keyId\n    )\nend\n\nfunction QuickApp:getDeviceDescription(device)\n    if device and device.name and device.id and device.roomName then\n        return device.name .. \" #\" .. device.id .. \" (\" .. tostring(device.roomName) .. \")\"\n    else\n        return device.id\n    end\nend\n"},{"name":"tools","isMain":false,"isOpen":true,"content":"local alphabet = {\r\n    [\"А\"] = \"A\",\r\n    [\"Б\"] = \"B\",\r\n    [\"В\"] = \"V\",\r\n    [\"Г\"] = \"G\",\r\n    [\"Д\"] = \"D\",\r\n    [\"Е\"] = \"E\",\r\n    [\"Ж\"] = \"Zh\",\r\n    [\"З\"] = \"Z\",\r\n    [\"И\"] = \"I\",\r\n    [\"І\"] = \"I\",\r\n    [\"Ї\"] = \"I\",\r\n    [\"Й\"] = \"I\",\r\n    [\"К\"] = \"K\",\r\n    [\"Л\"] = \"L\",\r\n    [\"М\"] = \"M\",\r\n    [\"Н\"] = \"N\",\r\n    [\"О\"] = \"O\",\r\n    [\"П\"] = \"P\",\r\n    [\"Р\"] = \"R\",\r\n    [\"С\"] = \"S\",\r\n    [\"Т\"] = \"T\",\r\n    [\"У\"] = \"U\",\r\n    [\"Ф\"] = \"F\",\r\n    [\"Х\"] = \"H\",\r\n    [\"Ч\"] = \"Ch\",\r\n    [\"Ц\"] = \"C\",\r\n    [\"Ш\"] = \"Sh\",\r\n    [\"Щ\"] = \"Shch\",\r\n    [\"И\"] = \"I\",\r\n    [\"Є\"] = \"E\",\r\n    [\"Э\"] = \"E\",\r\n    [\"Ю\"] = \"Ju\",\r\n    [\"Я\"] = \"Ja\",\r\n    [\"а\"] = \"a\",\r\n    [\"б\"] = \"b\",\r\n    [\"в\"] = \"v\",\r\n    [\"г\"] = \"g\",\r\n    [\"д\"] = \"d\",\r\n    [\"е\"] = \"e\",\r\n    [\"~\"] = \"e\",\r\n    [\"ж\"] = \"zh\",\r\n    [\"з\"] = \"z\",\r\n    [\"и\"] = \"i\",\r\n    [\"і\"] = \"i\",\r\n    [\"ї\"] = \"i\",\r\n    [\"й\"] = \"i\",\r\n    [\"к\"] = \"k\",\r\n    [\"л\"] = \"l\",\r\n    [\"м\"] = \"m\",\r\n    [\"н\"] = \"n\",\r\n    [\"о\"] = \"o\",\r\n    [\"п\"] = \"p\",\r\n    [\"р\"] = \"r\",\r\n    [\"с\"] = \"s\",\r\n    [\"т\"] = \"t\",\r\n    [\"у\"] = \"u\",\r\n    [\"ф\"] = \"f\",\r\n    [\"х\"] = \"h\",\r\n    [\"ч\"] = \"ch\",\r\n    [\"ц\"] = \"c\",\r\n    [\"ш\"] = \"sh\",\r\n    [\"щ\"] = \"shch\",\r\n    [\"ы\"] = \"i\",\r\n    [\"ь\"] = \"'\",\r\n    [\"є\"] = \"e\",\r\n    [\"э\"] = \"e\",\r\n    [\"ю\"] = \"ju\",\r\n    [\"я\"] = \"ja\"\r\n}\r\n\r\nfunction transliterate(input)\r\n    if (not input) then\r\n        return \"unknown_input_for_transliteration\"\r\n    end\r\n\r\n    local output = {}\r\n    local i = 1\r\n\r\n    for p, c in utf8.codes(input) do  \r\n        local char = utf8.char(c)\r\n        local outputCharacter = alphabet[char]\r\n\r\n        if not outputCharacter then\r\n        if (string.find(char, \"%a\") or string.find(char, \"%d\")) then\r\n            outputCharacter = char\r\n        else\r\n            outputCharacter = \"-\"\r\n        end\r\n\r\n        end\r\n        output[i] = outputCharacter\r\n        i = i + 1\r\n    end\r\n\r\n    --print(\"RESULT \" .. table.concat(output) ) \r\n\r\n    return table.concat(output) \r\nend\r\n\r\nfunction extractMetaInfoFromDeviceName(deviceName)\r\n    local metaInfo = {\r\n        pureName = deviceName,\r\n        autoPower = true,\r\n        turnOffTimeout = 10 * 60,\r\n        segmentId = -1,\r\n    }\r\n    \r\n    local s, e = string.find(deviceName, \"%[.+%]\")\r\n    if s and e then\r\n        local pureName = string.gsub(string.sub(deviceName, 1, s-1), \"%s+$\", \"\")\r\n        local metaStr = string.sub(deviceName, s+1, e-1)\r\n\r\n        metaInfo.pureName = pureName\r\n \r\n        local attrs = splitStringToNumbers(metaStr, \"%.\")\r\n        if attrs[1] == \"1\" then\r\n            metaInfo.autoPower = true\r\n        else\r\n            metaInfo.autoPower = false\r\n        end\r\n\r\n        if attrs[2] and attrs[2] ~= \"-\" then \r\n            metaInfo.turnOffTimeout = math.ceil(attrs[2] * 60)\r\n        end\r\n\r\n        if attrs[3] and attrs[3] ~= \"-\" then \r\n            metaInfo.segmentId = tonumber(attrs[3])\r\n            metaInfo.rooms = {}\r\n\r\n            local segmentIdsStr = fibaro.getGlobalVariable(\"segment_\" .. metaInfo.segmentId)\r\n            if segmentIdsStr then\r\n                local roomIds = splitStringToNumbers(segmentIdsStr, \",\")\r\n                for i,roomIdStr in ipairs(roomIds) do\r\n                    metaInfo.rooms[i] = roomIdStr\r\n                end\r\n            end\r\n        end\r\n    else\r\n        metaInfo.name = deviceName\r\n    end\r\n\r\n    return metaInfo\r\nend\r\n\r\nfunction splitString(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c:gsub(\"^%s*(.-)%s*$\", \"%1\") end)\r\n  return fields\r\nend\r\n\r\n\r\nfunction splitStringToNumbers(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c end)\r\n  return fields\r\nend\r\n\r\nfunction table_contains_value(tab, val)\r\n    if not tab then\r\n        return false\r\n    end\r\n    \r\n    for index, value in ipairs(tab) do\r\n        if value == val then\r\n            return true\r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction getDeviceIdFromTopic(topic)\r\n    local s, e = string.find(topic, \"%d+\")\r\n    --print(topic .. \" | \" .. tostring(s) .. \" | \" .. tostring(e))\r\n    if s then\r\n            return tonumber(string.sub(topic, s, e))\r\n    else\r\n        return 0\r\n    end\r\nend\r\n\r\nfunction createRootTopicName(device)\r\nreturn \"homeassistant/\" .. device.haType .. \"/\" .. device.id\r\n    --return \"homeassistant/\" .. device.haType .. \"/\" .. transliterate(device.roomName) .. \"/\" .. device.id .. \"-\" .. transliterate(device.name)\r\nend\r\n\r\nfunction createGenericEventTopicName(device, eventType, propertyName)\r\n    if (propertyName) then\r\n        return createRootTopicName(device) .. \"/events/\" .. eventType .. \"/\" .. propertyName\r\n    else\r\n        return createRootTopicName(device) .. \"/events/\" .. eventType\r\n    end\r\nend\r\n\r\nfunction createPropertyTopicName(device, propertyName)\r\n    return createGenericEventTopicName(device, \"DevicePropertyUpdatedEvent\", propertyName)     \r\nend\r\n\r\nfunction createCommandTopicName(device, commandName)\r\n    return createRootTopicName(device) .. \"/commands/\" .. \"set\" .. commandName:gsub(\"^%l\", string.upper)\r\nend\r\n\r\nfunction createHaConfigTopicName(device)\r\n    return createRootTopicName(device) .. \"/config\"\r\nend\r\n\r\nfunction createHaJsonAttributesTopicName(device)\r\n    return createRootTopicName(device) .. \"/config_json_attributes\"\r\nend\r\n\r\nfunction createFibaroEventPayload(device, propertyName, newValue) \r\n    -- THIS IS FIBARO EVENT FORMAT => DO NOT CHANGE VARIABLE NAMES\r\n    local payload = {\r\n        data = {\r\n            id = device.id,\r\n            property = propertyName,\r\n            newValue = newValue\r\n        },\r\n        type = \"DevicePropertyUpdatedEvent\",\r\n        created = os.time()\r\n    }\r\n\r\n    return payload\r\nend\r\n\r\nfunction isEmptyString(s)\r\n  return s == nil or s == \"\"\r\nend\r\n\r\nfunction base64Encode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    return ((data:gsub('.', function(x) \r\n        local r,b='',x:byte()\r\n        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\r\n        if (#x < 6) then return '' end\r\n        local c=0\r\n        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\r\n        return b:sub(c+1,c+1)\r\n    end)..({ '', '==', '=' })[#data%3+1])\r\nend\r\n\r\nfunction base64Decode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    data = string.gsub(data, '[^'..b..'=]', '')\r\n    return (data:gsub('.', function(x)\r\n        if (x == '=') then return '' end\r\n        local r,f='',(b:find(x)-1)\r\n        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\r\n        if (#x ~= 8) then return '' end\r\n        local c=0\r\n        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\r\n        return string.char(c)\r\n    end))\r\nend\r\n\r\nfunction decodeBase64Auth(encoded)\r\n    local decoded = base64Decode(encoded)\r\n    \r\n    local i = string.find(decoded, \":\")\r\n\r\n    if i then\r\n        return string.sub(decoded, 0, i-1), string.sub(decoded, i+1, string.len(decoded))\r\n    else\r\n        return nil\r\n    end\r\nend\r\n\r\nfunction shallowCopyTo(from, to)\r\n    local orig_type = type(from)\r\n    if orig_type == 'table' then\r\n        for orig_key, orig_value in pairs(from) do\r\n            to[orig_key] = orig_value\r\n        end\r\n    else -- number, string, boolean, etc\r\n        copy = from\r\n    end\r\nend\r\n\r\n\r\nfunction clone(orig)\r\n    local orig_type = type(orig)\r\n    local copy\r\n    if orig_type == 'table' then\r\n        copy = {}\r\n        for orig_key, orig_value in next, orig, nil do\r\n            copy[clone(orig_key)] = clone(orig_value)\r\n        end\r\n        --setmetatable(copy, clone(getmetatable(orig)))\r\n    else -- number, string, boolean, etc\r\n        copy = orig\r\n    end\r\n    return copy\r\nend\r\n\r\nfunction inheritFrom(orig)\r\n    return clone(orig)\r\nend\r\n\r\nfunction isNumber(value)\r\n    if type(value) == \"number\" then return true end\r\n\r\n    if value == tostring(tonumber(value)) then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\nfunction round(number, dec)\r\n    local k = 10^dec\r\n\r\n    local result = math.floor(number * k + 0.5) / k\r\n\r\n    local resultWithoutTrailingZero = math.floor(result)\r\n    if (resultWithoutTrailingZero ~= result) then\r\n        return result\r\n    else\r\n        return resultWithoutTrailingZero\r\n    end\r\n\r\n    return result\r\nend"},{"name":"mqtt_convention_api","isMain":false,"isOpen":true,"content":"MqttConventionPrototype = {\r\n    type = \"'type' needs to be overriden\", \r\n    mqtt = \"MQTT connection must be established first\"\r\n}\r\n \r\nfunction MqttConventionPrototype:getLastWillMessage() \r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onConnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceCreated(device)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceRemoved(device)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onPropertyUpdated(device, event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\n\r\nfunction MqttConventionPrototype:onCommand(event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDisconnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\n-----------------------------------\r\n-- HOME ASSISTANT \r\n-----------------------------------\r\nMqttConventionHomeAssistant = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomeAssistant.type = \"Home Assistant\"\r\nMqttConventionHomeAssistant.rootTopic = \"homeassistant/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomeAssistant:getDeviceTopic(device)\r\n    return self.rootTopic .. device.bridgeType .. \"/\" .. device.id .. \"/\"\r\nend\r\nfunction MqttConventionHomeAssistant:getGenericEventTopic(device, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomeAssistant:getterTopic(device, propertyName)\r\n    if (device.linkedDevice and propertyName == \"value\") then\r\n        local result = self:getGenericEventTopic(device.linkedDevice, \"DevicePropertyUpdatedEvent\", device.linkedProperty)\r\n\r\n        return result\r\n    else\r\n        return self:getGenericEventTopic(device, \"DevicePropertyUpdatedEvent\", propertyName)\r\n    end\r\nend\r\nfunction MqttConventionHomeAssistant:getGenericCommandTopic(device, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(device) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:setterTopic(device, propertyName)\r\n    return self:getGenericCommandTopic(device, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getLastWillAvailabilityTopic()\r\n    return self.rootTopic .. \"hc3-dead\"\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getLastWillMessage()\r\n    return {\r\n        topic = self:getLastWillAvailabilityTopic(),\r\n        payload = \"true\"\r\n    }    \r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onConnected()\r\n    self.mqtt:publish(self.rootTopic .. \"hc3-dead\", \"false\", {retain = true})\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/set/+\")\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDisconnected()\r\n    self.mqtt:publish(self.rootTopic .. \"hc3-dead\", \"true\", {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceCreated(device)\r\n    ------------------------------------------\r\n    --- AVAILABILITY\r\n    ------------------------------------------\r\n    local msg = {\r\n        unique_id = tostring(device.id),\r\n        name = device.name .. \" (\" .. device.roomName .. \")\",\r\n\r\n        availability_mode = \"all\",\r\n        availability = {\r\n            {\r\n                topic = self:getLastWillAvailabilityTopic(),\r\n                payload_available = \"false\",\r\n                payload_not_available = \"true\"\r\n            }\r\n            ,\r\n            {\r\n                topic = self:getterTopic(device, \"dead\"),\r\n                payload_available = \"false\",\r\n                payload_not_available = \"true\" \r\n            }\r\n        },\r\n\r\n        json_attributes_topic = self:getDeviceTopic(device) .. \"config_json_attributes\" \r\n    }\r\n\r\n    ------------------------------------------\r\n    --- PARENT DEVICE INFO\r\n    ------------------------------------------\r\n    local parentDevice = device.bridgeParent\r\n    if parentDevice then\r\n        msg.device = {\r\n            identifiers = \"hc3-\" .. parentDevice.id,\r\n            name = parentDevice.name,\r\n            manufacturer = parentDevice.properties.zwaveCompany,\r\n            model = parentDevice.properties.model, \r\n            -- zwave version is used instead of device software version\r\n            sw_version = parentDevice.properties.zwaveVersion\r\n        }\r\n    end\r\n\r\n    ------------------------------------------\r\n    --- USE \"TRUE\"/\"FALSE\" VALUE PAYLOAD, instead of \"ON\"/\"OFF\"\r\n    ------------------------------------------\r\n    if (device.bridgeRead) then\r\n        if (device.bridgeBinary and device.bridgeType ~= \"cover\") then \r\n            msg.payload_on = \"true\"\r\n            msg.payload_off = \"false\"\r\n        end\r\n    end\r\n    \r\n    ------------------------------------------\r\n    ---- READ\r\n    ------------------------------------------\r\n    -- Does device have binary state to share?\r\n    if (device.bridgeRead and device.bridgeBinary) then\r\n        msg.state_topic = self:getterTopic(device, \"state\")\r\n        \r\n        if (device.bridgeType == \"light\") then\r\n            msg.state_value_template = \"{{ value_json.value }}\"\r\n        else\r\n            -- wish Home Assistant spec was consistent for all device types and \"state_value_template\" was used for all the devices with \"state\" property\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        end\r\n    end\r\n    -- Does device have multilevel state to share?\r\n    if (device.bridgeRead and device.bridgeMultilevel) then\r\n        if (device.bridgeType == \"light\") then\r\n            msg.brightness_state_topic = self:getterTopic(device, \"value\")\r\n            msg.brightness_value_template = \"{{ value_json.value }}\"\r\n        elseif (device.bridgeType == \"cover\") then\r\n            msg.position_topic = self:getterTopic(device, \"value\")\r\n        elseif (device.bridgeType == \"sensor\") then\r\n            msg.state_topic = self:getterTopic(device, \"value\")\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        else\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- WRITE\r\n    ------------------------------------------\r\n    -- Does device support binary write operations?\r\n    if (device.bridgeWrite and device.bridgeBinary) then\r\n        msg.command_topic = self:setterTopic(device, \"state\")\r\n    end\r\n    -- Does device support multilevel write operations?\r\n    if (device.bridgeWrite) and (device.bridgeMultilevel) then\r\n        if (device.bridgeType == \"light\") then\r\n            msg.brightness_command_topic = self:setterTopic(device, \"value\")\r\n            msg.brightness_scale = 99\r\n            msg.on_command_type = \"brightness\"\r\n        elseif (device.bridgeType == \"cover\") then\r\n            msg.set_position_topic = self:setterTopic(device, \"value\")\r\n            msg.position_template = \"{{ value_json.value }}\"\r\n            -- value_template is deprecated since Home Assistant Core 2021.6.\r\n            msg.value_template = nil\r\n            msg.position_open = 99\r\n            msg.position_closed = 0\r\n\r\n            msg.payload_open = \"open\"\r\n            msg.payload_close = \"close\"\r\n            msg.payload_stop = \"stop\"\r\n\r\n            msg.state_open = \"open\"\r\n            msg.state_closed = \"closed\"\r\n            msg.state_opening = \"opening\"\r\n            msg.state_closing = \"closing\"\r\n            msg.state_topic = self:setterTopic(device, \"state\")\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- SENSOR SPECIFIC\r\n    ------------------------------------------\r\n    if (device.bridgeType == \"binary_sensor\" or device.bridgeType == \"sensor\") then\r\n        if (PrototypeDevice.bridgeSubtype ~= device.bridgeSubtype) then\r\n            msg.device_class = device.bridgeSubtype\r\n        end\r\n        if (PrototypeDevice.bridgeUnitOfMeasurement ~= device.bridgeUnitOfMeasurement) then\r\n            msg.unit_of_measurement = device.bridgeUnitOfMeasurement\r\n        end\r\n\r\n        -- Energy meter requires extra properties\r\n        if (device.bridgeSubtype == \"energy\") then\r\n            msg.state_class = \"total_increasing\"\r\n            --msg.state_class = \"measurement\"\r\n            --msg.last_reset_topic = self:getterTopic(device, \"lastReset\")\r\n            --msg.last_reset_value_template = \"{{ value_json.value }}\"\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- THERMOSTAT SPECIFIC\r\n    ------------------------------------------\r\n    if (device.bridgeType == \"climate\") then\r\n        msg.modes = device.properties.supportedThermostatModes\r\n \r\n        msg.temperature_unit = device.properties.unit\r\n        msg.temp_step = device.properties.heatingThermostatSetpointStep[msg.temperature_unit]\r\n\r\n        -- MODE \r\n        msg.mode_state_topic = self:getterTopic(device, \"thermostatMode\")\r\n        msg.mode_command_topic = self:setterTopic(device, \"thermostatMode\")\r\n\r\n        -- MIX/MAX TEMPERATURE\r\n        msg.min_temp = device.properties.heatingThermostatSetpointCapabilitiesMin\r\n        msg.max_temp = device.properties.heatingThermostatSetpointCapabilitiesMax\r\n\r\n        -- TARGET TEMPERATURE\r\n        msg.temperature_state_topic = self:getterTopic(device, \"heatingThermostatSetpoint\")\r\n        msg.temperature_command_topic = self:setterTopic(device, \"heatingThermostatSetpoint\")\r\n        \r\n        -- CURRENT TEMPERATURE\r\n        local temperatureSensorDevice = device:getTemperatureSensor(self.devices)\r\n        if temperatureSensorDevice then \r\n            msg.current_temperature_topic = self:getterTopic(temperatureSensorDevice, \"value\")\r\n        end\r\n    end\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"config\", json.encode(msg), {retain = true})\r\n    \r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"config_json_attributes\", json.encode(device.fibaroDevice), {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceRemoved(device)\r\n    self.mqtt:publish(\r\n        self:getDeviceTopic(device) .. \"config\", \r\n        \"\" \r\n    )\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onPropertyUpdated(device, event)\r\n    local propertyName = event.data.property\r\n\r\n    local value = event.data.newValue\r\n\r\n    if device.bridgeType == \"cover\" then \r\n        if propertyName == \"value\" then\r\n            -- Fibaro doesn't use \"state\" attribute for covers, so we'll trigger it on behalf of Fibaro based on \"value\" attribute\r\n            local state\r\n            if value < 20 then\r\n                state = \"closed\"\r\n            elseif value > 80 then\r\n                state = \"open\"\r\n            else\r\n                state = \"unknown\"\r\n            end\r\n\r\n            if state then\r\n                local payload = {\r\n                    id = device.id,\r\n                    deviceName = device.name,\r\n                    created = event.created,\r\n                    timestamp = os.date(),\r\n                    roomName = device.roomName,\r\n                    value = state\r\n                }\r\n                formattedState = json.encode(payload)\r\n                --formattedState = state\r\n                self.mqtt:publish(self:getterTopic(device, \"state\"), formattedState, {retain = true})\r\n            end\r\n        elseif propertyName == \"state\" then\r\n            if (value == \"unknown\") then\r\n                -- drop event as Fibaro has \"Uknnown\" value constantly assigned to the \"state\" attribute \r\n                return\r\n            end\r\n        end\r\n    end\r\n\r\n    value = string.lower(value)\r\n\r\n    local formattedPayload\r\n    if (propertyName == \"dead\") then\r\n        formattedPayload = tostring(value)\r\n    else\r\n        local payload = {\r\n            id = device.id,\r\n            deviceName = device.name,\r\n            created = event.created,\r\n            timestamp = os.date(),\r\n            roomName = device.roomName,\r\n            value = value\r\n        }\r\n        formattedPayload = json.encode(payload)\r\n    end\r\n\r\n    self.mqtt:publish(self:getterTopic(device, propertyName), formattedPayload, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onCommand(event)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        -- Home Assistant command detected\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[3])\r\n        local propertyName = topicElements[5]\r\n\r\n        local device = self.devices[deviceId]\r\n\r\n        local value = event.payload\r\n\r\n        if (device.bridgeType == \"climate\") then\r\n            -- Fibaro HC3 uses first letter in upper case, and HA relies on lower case\r\n            local firstPart = string.upper(string.sub(value, 1, 1))\r\n            local secondPart = string.sub(value, 2, string.len(value))\r\n            value = firstPart .. secondPart\r\n        end\r\n\r\n        device:setProperty(propertyName, value)\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- HOMIE\r\n-----------------------------------\r\nMqttConventionHomie = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomie.type = \"Homie\"\r\nMqttConventionHomie.rootTopic = \"homie/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomie:getDeviceTopic(device)\r\n    return self.rootTopic .. device.id .. \"/\"\r\nend\r\nfunction MqttConventionHomie:getGenericEventTopic(device, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomie:getterTopic(device, propertyName)\r\n    return self:getGenericEventTopic(device, \"DevicePropertyUpdatedEvent\", propertyName)     \r\nend\r\nfunction MqttConventionHomie:getGenericCommandTopic(device, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(device) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomie:getSetterTopic(device, propertyName)\r\n    return self:getGenericCommandTopic(device, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomie:getLastWillMessage() \r\n    return {\r\n        topic = self.rootTopic .. \"hc3-dead\",\r\n        payload = \"true\",\r\n        lastWill = true\r\n    }    \r\nend\r\n\r\nfunction MqttConventionHomie:onConnected()\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/+/set\")\r\nend\r\n\r\nfunction MqttConventionHomie:onDisconnected()\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceCreated(device)\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$homie\", \"2.1.0\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$name\", device.name .. \" (\" .. device.roomName .. \")\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$implementation\", \"Fibaro HC3 to MQTT bridge\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$nodes\", \"node\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$name\", device.name, {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$type\", \"\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$extensions\", \"\", {retain = true})\r\n\r\n    local properties = { }\r\n\r\n    if (device.bridgeRead) then\r\n        local propertyName = device.bridgeType\r\n        if (PrototypeDevice.bridgeSubtype ~= device.bridgeSubtype) then\r\n            propertyName = propertyName .. \" - \" .. device.bridgeSubtype\r\n        end\r\n\r\n        if (device.bridgeBinary) then\r\n            properties[\"state\"] = {\r\n                name = device.bridgeType,\r\n                datatype = \"boolean\",\r\n                settable = device.bridgeWrite, \r\n                retained = true,\r\n            }\r\n        end\r\n\r\n        if (device.bridgeMultilevel) then\r\n            properties[\"value\"] = {\r\n                name = device.bridgeType,\r\n                datatype = \"integer\",\r\n                settable = device.bridgeWrite,\r\n                retained = true,\r\n                unit = device.bridgeUnitOfMeasurement\r\n            }\r\n        end\r\n    end\r\n\r\n    local propertiesStr = \"\"\r\n    local firstParameter = true\r\n    for i, j in pairs(properties) do\r\n        if (not firstParameter) then\r\n            propertiesStr = propertiesStr .. \",\"\r\n        end\r\n        propertiesStr = propertiesStr .. i\r\n        firstParameter = false\r\n    end\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$properties\", propertiesStr, {retain = true})\r\n\r\n    for i, j in pairs(properties) do\r\n        local propertyTopic = self:getDeviceTopic(device) .. \"node/\" .. i .. \"/$\"\r\n        for m, n in pairs(j) do\r\n            self.mqtt:publish(propertyTopic .. m, tostring(n), {retain = true})\r\n        end\r\n    end\r\n\r\n    local homieState\r\n    if (device.dead) then\r\n        homieState = \"lost\"\r\n    else\r\n        homieState = \"ready\"\r\n    end\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$state\", homieState, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceRemoved(device)\r\nend\r\n\r\nfunction MqttConventionHomie:onPropertyUpdated(device, event)\r\n    local propertyName = event.data.property\r\n\r\n    local value = event.data.newValue\r\n\r\n    value = string.lower(value)\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/\" .. propertyName, value, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onCommand(event)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[2])\r\n        local device = self.devices[deviceId]\r\n\r\n        local propertyName = topicElements[4]\r\n        local value = event.payload\r\n\r\n        device:setProperty(propertyName, value)\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- FOR EXTENDED DEBUG PURPOSES\r\n-----------------------------------\r\n\r\nMqttConventionDebug = inheritFrom(MqttConventionPrototype) \r\nMqttConventionDebug.type = \"Debug\"\r\nfunction MqttConventionDebug:getLastWillMessage() \r\nend\r\nfunction MqttConventionDebug:onDeviceCreated(device)\r\nend\r\nfunction MqttConventionDebug:onDeviceRemoved(device)\r\nend\r\nfunction MqttConventionDebug:onPropertyUpdated(device, event)\r\nend\r\nfunction MqttConventionDebug:onConnected()\r\nend\r\nfunction MqttConventionDebug:onCommand(event)\r\nend\r\nfunction MqttConventionDebug:onDisconnected()\r\nend\r\n\r\n-----------------------------------\r\n-- MQTT CONVENTION MAPPINGS\r\n-----------------------------------\r\n\r\nmqttConventionMappings = {\r\n    [\"home-assistant\"] = MqttConventionHomeAssistant,\r\n    [\"homie\"] = MqttConventionHomie,\r\n    [\"debug\"] = MqttConventionDebug\r\n} \r\n"},{"name":"device_api","isMain":false,"isOpen":true,"content":"----------------------------------- \r\n-- PROTOTYPE OBJECT \r\n-----------------------------------\r\n\r\nPrototypeDevice = {\r\n    bridgeType = \"'bridgeType' needs to be set\",\r\n    bridgeSubtype = \"'bridgeSubtype' needs to be set\",\r\n    bridgeBinary = \"'bridgeBinary' needs to be set\",\r\n    bridgeBinaryProperty = \"value\",\r\n    bridgeMultilevel = \"'bridgeMultilevel' needs to be set\",\r\n    bridgeRead = \"'bridgeRead' needs to be set\",\r\n    bridgeWrite = \"'bridgeWrite' needs to be set\",\r\n    bridgeModes = \"'bridgeWrite' needs to be set to an array of modes, e.g. 'heat', 'cool'\",\r\n    customPropertySetters = nil -- could be optionally set by child class\r\n}\r\n\r\nfunction PrototypeDevice:new(fibaroDevice)\r\n    -- clone self, and copy fibaroDevice\r\n    local status, device = pcall(clone, self)\r\n    shallowCopyTo(fibaroDevice, device)\r\n\r\n    device.fibaroDevice = fibaroDevice\r\n    \r\n    if (not device.roomName) then\r\n        device.roomName = tostring(fibaro.getRoomNameByDeviceID(device.id))\r\n    end\r\n\r\n    self:init(device)\r\n\r\n    return device\r\nend\r\n\r\nfunction PrototypeDevice:init(device)\r\n    -- needs to be overriden by subclasses if need to initialize custom parameters\r\nend \r\n\r\nfunction PrototypeDevice:setProperty(propertyName, value)\r\n    if isEmptyString(value) then\r\n        return\r\n    end\r\n\r\n    local customPropertySetter\r\n    if (self.customPropertySetters ~= nil) then\r\n        customPropertySetter = self.customPropertySetters[propertyName]\r\n    end\r\n\r\n    if (customPropertySetter == nil) then\r\n        -- DEFAULT PROPERTY SETTER\r\n        if (propertyName == \"state\") then\r\n            if (value == \"true\") then\r\n                print(\"Turn ON for device #\" .. self.id)\r\n                fibaro.call(self.id, \"turnOn\")\r\n            elseif (value == \"false\") then\r\n                print(\"Turn OFF for device #\" .. self.id)\r\n                fibaro.call(self.id, \"turnOff\")\r\n            else\r\n                print(\"Unexpected value: \" .. json.encode(event))\r\n            end\r\n\r\n        else\r\n            local firstPart = string.upper(string.sub(propertyName, 1, 1))\r\n            local secondPart = string.sub(propertyName, 2, string.len(propertyName))\r\n\r\n            local functionName = \"set\" .. firstPart .. secondPart\r\n            print(\"CALL \\\"\" .. functionName .. \"\\\", with VALUE \\\"\" .. value .. \"\\\" for device #\" .. self.id)\r\n            fibaro.call(self.id, functionName, value)\r\n        end\r\n    else\r\n        -- CUSTOM PROPERTY SETTER\r\n        print(\"SET \\\"\" .. propertyName .. \"\\\" to \\\"\" .. value .. \"\\\" for device #\" .. self.id)\r\n        customPropertySetter(propertyName, value)\r\n    end\r\nend\r\n\r\nfunction PrototypeDevice.isSupported(fibaroDevice)\r\n    print(\"'isSupported' function is mandatory for implementation\")\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY SWITCH\r\n-----------------------------------\r\n\r\nSwitch = inheritFrom(PrototypeDevice)\r\nSwitch.bridgeType = \"switch\"\r\nSwitch.bridgeBinary = true\r\nSwitch.bridgeMultilevel = false\r\nSwitch.bridgeRead = true\r\nSwitch.bridgeWrite = true\r\n\r\nfunction Switch.isSupported(fibaroDevice)\r\n    if ((fibaroDevice.baseType == \"com.fibaro.binarySwitch\") or (fibaroDevice.type == \"com.fibaro.binarySwitch\")) and not table_contains_value(fibaroDevice.interfaces, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY LIGHT\r\n-----------------------------------\r\n\r\nLight = inheritFrom(PrototypeDevice)\r\nLight.bridgeType = \"light\"\r\nLight.bridgeBinary = true\r\nLight.bridgeMultilevel = false\r\nLight.bridgeRead = true\r\nLight.bridgeWrite = true\r\n\r\nfunction Light.isSupported(fibaroDevice)\r\n    if ((fibaroDevice.baseType == \"com.fibaro.binarySwitch\") or (fibaroDevice.type == \"com.fibaro.binarySwitch\")) and table_contains_value(fibaroDevice.interfaces, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL LIGHT (DIMMERS)\r\n-----------------------------------\r\n\r\nDimmer = inheritFrom(PrototypeDevice)\r\nDimmer.bridgeType = \"light\"\r\nDimmer.bridgeBinary = true\r\nDimmer.bridgeMultilevel = true\r\nDimmer.bridgeRead = true\r\nDimmer.bridgeWrite = true\r\n\r\nfunction Dimmer.isSupported(fibaroDevice)\r\n    if (fibaroDevice.baseType == \"com.fibaro.multilevelSwitch\") and table_contains_value(fibaroDevice.interfaces, \"light\")      then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY SENSOR (DOOR, MOTION, WATER LEAK, FIRE, SMORE SENSORSMULTILEVEL FOR TEMPERATURE, ETC)\r\n-----------------------------------\r\n\r\nBinarySensor = inheritFrom(PrototypeDevice)\r\nBinarySensor.bridgeType = \"binary_sensor\"\r\nBinarySensor.bridgeBinary = true\r\nBinarySensor.bridgeMultilevel = false\r\nBinarySensor.bridgeRead = true \r\nBinarySensor.bridgeWrite = false\r\n\r\nfunction BinarySensor.isSupported(fibaroDevice)\r\n    if (string.find(fibaroDevice.baseType, \"Sensor\")) or (string.find(fibaroDevice.baseType, \"sensor\")) then\r\n        if (fibaroDevice.baseType ~= \"com.fibaro.multilevelSensor\") and (fibaroDevice.type ~= \"com.fibaro.multilevelSensor\") then\r\n            return true \r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction BinarySensor:init(device)\r\n    -- set unit of measurement\r\n    device.bridgeUnitOfMeasurement = device.properties.unit\r\n\r\n    -- ToDo: refactor with mappings\r\n    if (device.type == \"com.fibaro.motionSensor\") or (device.baseType == \"com.fibaro.motionSensor\") then\r\n        device.bridgeSubtype = \"motion\"\r\n    elseif (device.baseType == \"com.fibaro.floodSensor\") then\r\n        device.bridgeSubtype = \"moisture\" \r\n    elseif (device.baseType == \"com.fibaro.doorWindowSensor\") then\r\n        if (device.type == \"com.fibaro.doorSensor\") then\r\n            device.bridgeSubtype = \"door\"\r\n        else\r\n            print(\"[BinarySensor.init] Uknown doow/window sensor \" .. device.id .. \" \" .. device.name)\r\n        end\r\n    elseif (device.baseType == \"com.fibaro.lifeDangerSensor\") then\r\n        device.bridgeSubtype = \"safety\"\r\n    elseif (device.baseType == \"com.fibaro.smokeSensor\") or (device.type == \"com.fibaro.smokeSensor\") then\r\n        device.bridgeSubtype = \"smoke\"\r\n    else\r\n        print(\"[BinarySensor.init] Unknown binary sensor\")\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL SENSOR (TEMPERATURE, HUMIDITY, VOLTAGE, ETC) \r\n-----------------------------------\r\n\r\nMultilevelSensor = inheritFrom(PrototypeDevice)\r\nMultilevelSensor.bridgeType = \"sensor\"\r\nMultilevelSensor.bridgeBinary = false\r\nMultilevelSensor.bridgeMultilevel = true\r\nMultilevelSensor.bridgeUnitOfMeasurement = \"'unit of measurement' needs to be initialized\"\r\nMultilevelSensor.bridgeRead = true\r\nMultilevelSensor.bridgeWrite = false\r\n\r\nfunction MultilevelSensor.isSupported(fibaroDevice)\r\n    if (string.find(fibaroDevice.baseType, \"Sensor\")) or (string.find(fibaroDevice.baseType, \"sensor\")) then\r\n        if (fibaroDevice.baseType == \"com.fibaro.multilevelSensor\") or (fibaroDevice.type == \"com.fibaro.multilevelSensor\") then\r\n            return true \r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction MultilevelSensor:init(device)\r\n    -- initialize unit of measurement\r\n    device.bridgeUnitOfMeasurement = device.properties.unit\r\n\r\n    -- initialize subtype \r\n    -- ToDo: refactor with mappings\r\n    if (device.type == \"com.fibaro.temperatureSensor\") then\r\n        device.bridgeSubtype = \"temperature\"\r\n        device.bridgeUnitOfMeasurement = \"°\" .. device.properties.unit\r\n    elseif (device.type == \"com.fibaro.lightSensor\") then\r\n        device.bridgeSubtype = \"illuminance\"\r\n    elseif (device.type == \"com.fibaro.humiditySensor\") then \r\n        device.bridgeSubtype = \"humidity\"\r\n    elseif (device.type == \"com.fibaro.energySensor\") then \r\n        device.bridgeSubtype = \"energy\"\r\n    elseif (device.type == \"com.fibaro.powerSensor\") then \r\n        device.bridgeSubtype = \"power\"\r\n    elseif (device.properties.unit == \"V\") then\r\n        device.bridgeSubtype = \"voltage\"\r\n    elseif (device.properties.unit == \"A\") then\r\n        device.bridgeSubtype = \"current\"\r\n    elseif (device.properties.unit == \"W\" or device.properties.unit == \"kW\" or device.properties.unit == \"kVA\") then\r\n        device.bridgeSubtype = \"power\"\r\n    elseif (device.properties.unit == \"min(s)\") then\r\n        device.bridgeSubtype = \"battery\"\r\n    else\r\n        print(\"[MultilevelSensor.init] Unknown multilevel sensor \" .. tostring(device.id) .. \" \" .. tostring(device.name) .. \" \" .. device.properties.unit)\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL SWITCH (COVER)\r\n-----------------------------------\r\n\r\nCover = inheritFrom(PrototypeDevice)\r\nCover.bridgeType = \"cover\"\r\nCover.bridgeBinary = true\r\nCover.bridgeMultilevel = true\r\nCover.bridgeRead = true\r\nCover.bridgeWrite = true\r\n\r\nfunction Cover.isSupported(fibaroDevice)\r\n    if (fibaroDevice.baseType == \"com.fibaro.baseShutter\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction Cover:init(device) \r\n    device.customPropertySetters = { }\r\n    device.customPropertySetters[\"state\"] = function (propertyName, value) \r\n        if (value == \"open\") then\r\n            fibaro.call(device.id, \"setValue\", 99)\r\n        elseif (value == \"close\") then\r\n            fibaro.call(device.id, \"setValue\", 0)\r\n        elseif (value == \"stop\") then\r\n            fibaro.call(device.id, \"stop\")\r\n        else\r\n            print(\"Unsupported state\")\r\n        end\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- THERMOSTAT (MULTILEVEL SWITCH)\r\n-----------------------------------\r\n\r\nThermostat = inheritFrom(PrototypeDevice)\r\nThermostat.bridgeType = \"climate\"\r\nThermostat.bridgeBinary = false\r\nThermostat.bridgeMultilevel = true\r\nThermostat.bridgeRead = true\r\nThermostat.bridgeWrite = true \r\n\r\nfunction Thermostat.isSupported(fibaroDevice)\r\n    if (fibaroDevice.type == \"com.fibaro.hvacSystem\") then \r\n        return true \r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction Thermostat:init(device) \r\n    for i, mode in ipairs(device.properties.supportedThermostatModes) do\r\n        device.properties.supportedThermostatModes[i] = string.lower(mode)\r\n    end\r\nend\r\n\r\nfunction Thermostat:setMode(mode)\r\n    fibaro.call(self.id, \"setThermostatMode\", mode)\r\nend\r\n\r\nfunction Thermostat:setHeatingThermostatSetpoint(targetTemperature)\r\n    fibaro.call(self.id, \"setHeatingThermostatSetpoint\", targetTemperature)\r\nend\r\n\r\nfunction Thermostat:getTemperatureSensor(allDevices)\r\n    local device = allDevices[self.id + 1]\r\n    if (not Thermostat.isTemperatureSensor(device)) then\r\n        -- *** no laughs, to be refactored :)\r\n        device = allDevices[self.id + 2]\r\n    end\r\n\r\n    if (Thermostat.isTemperatureSensor(device)) then\r\n        return device\r\n    else\r\n        return nil\r\n    end\r\nend\r\n\r\nfunction Thermostat.isTemperatureSensor(device)\r\n    if ((device ~= nil) and (MultilevelSensor.isSupported(device)) and (device.bridgeSubtype == \"temperature\")) then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- HELPER FUNCTIONS - OVERRIDE \"WRONG\" DEVICE TYPES FROM FIBARO DEVICE API\r\n-----------------------------------\r\n\r\nlocal fibaroBaseTypeOverride = {\r\n    [\"com.fibaro.FGR\"] = \"com.fibaro.baseShutter\",\r\n    [\"com.fibaro.FGMS001\"] = \"com.fibaro.motionSensor\",\r\n    [\"com.fibaro.FGWP\"] = \"com.fibaro.binarySwitch\"\r\n}\r\n\r\nlocal fibaroTypeOverride = { \r\n    [\"com.fibaro.FGKF601\"] = \"com.fibaro.keyFob\",\r\n    [\"com.fibaro.FGD212\"] = \"com.fibaro.dimmer\",\r\n    [\"com.fibaro.FGMS001v2\"] = \"com.fibaro.motionSensor\",\r\n    [\"com.fibaro.FGFS101\"] = \"com.fibaro.floodSensor\",\r\n    [\"com.fibaro.FGWP102\"] = \"com.fibaro.binarySwitch\"\r\n}\r\n\r\nfunction getFibaroDevicesByFilter(filter)\r\n    local filterStr = \"\"\r\n\r\n    local firstParameter = true\r\n    for i, j in pairs(filter) do\r\n        if (not firstParameter) then\r\n            filterStr = filterStr .. \"&\"\r\n        end\r\n        filterStr = filterStr .. i .. \"=\" .. tostring(j)\r\n        firstParameter = false\r\n    end\r\n\r\n    print(\"Device filter URI '\" .. \"/devices?\" .. filterStr .. \"'\")\r\n\r\n    local allDevices = api.get(\"/devices?\" .. filterStr)\r\n\r\n    for i, j in ipairs(allDevices) do\r\n        overrideFibaroDeviceType(j)\r\n    end\r\n\r\n    return allDevices\r\nend\r\n\r\nfunction getFibaroDeviceById(id)\r\n    local fibaroDevice = api.get(\"/devices/\" .. id)\r\n\r\n    return getFibaroDeviceByInfo(fibaroDevice)\r\nend\r\n\r\nfunction getFibaroDeviceByInfo(info)\r\n    local fibaroDevice = info\r\n\r\n    overrideFibaroDeviceType(fibaroDevice) \r\n\r\n    return fibaroDevice\r\nend\r\n\r\nfunction overrideFibaroDeviceType(fibaroDevice)\r\n    if (not fibaroDevice) or (not fibaroDevice.type) then\r\n        return\r\n    end\r\n    local overrideType = fibaroTypeOverride[fibaroDevice.type]\r\n    if overrideType then \r\n        fibaroDevice.type = overrideType\r\n    end\r\n    \r\n    local overrideBaseType = fibaroBaseTypeOverride[fibaroDevice.baseType]\r\n    if overrideBaseType then \r\n        fibaroDevice.baseType = overrideBaseType\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- HELPER FUNCTIONS - IDENTIFY DEVICE BRIDGE TYPE BY LOOKING AT FIBARO DEVICE TYPE\r\n-----------------------------------\r\n\r\ndeviceTypeMappings = {\r\n    Switch, -- binary switch\r\n    Cover, -- multilevel switch\r\n    Light, -- binary light\r\n    Dimmer, -- multilevel light \r\n    BinarySensor,\r\n    MultilevelSensor,\r\n    Thermostat\r\n}  \r\n\r\nfunction identifyDevice(fibaroDevice)\r\n    for i, j in ipairs(deviceTypeMappings) do\r\n        if (j.isSupported(fibaroDevice)) then\r\n            local device = j:new(fibaroDevice)\r\n            if (device.parentId and device.parentId ~= 0) then\r\n                device.bridgeParent = getFibaroDeviceById(device.parentId)\r\n            end\r\n\r\n            return device\r\n        end\r\n    end\r\n\r\n    return nil\r\nend\r\n"}]}