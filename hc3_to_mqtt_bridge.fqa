{"name":"HC3 <-> MQTT Bridge","type":"com.fibaro.binarySwitch","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_51"},"sections":{"items":[{"components":[{"name":"totalFibaroDevices","style":{"weight":"1.2"},"text":"Total Fibaro devices: -","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"filteredFibaroDevices","style":{"weight":"1.2"},"text":"Filtered Fibaro devices: -","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"haEntities","style":{"weight":"1.2"},"text":"Home Assistant entities: -","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"bootTime","style":{"weight":"1.2"},"text":"Boot time: -","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_51"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"mqttUrl","type":"string","value":"mqtt://<host>:1883"},{"name":"mqttKeepAlive","type":"string","value":"60"},{"name":"mqttUsername","type":"string","value":"your_mqtt_username"},{"name":"mqttPassword","type":"string","value":"your_mqtt_password"},{"name":"mqttConvention","type":"string","value":"home-assistant"},{"name":"developmentMode","type":"string","value":"false"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"--[[ RELEASE NOTES FOR 1.0.221\nSummary: Broader support for energy meter devices\n\nDescription:\n- Support for AEON Labs energy meters, and for other sensors that has \"com.fibaro.energyMeter\" or \"com.fibaro.electricMeter\" types\n- Further codebase maintainability and logging improvements, like for Binary vs Multilevel sensors detection algorithm\n]]--\n\nfunction QuickApp:onInit()\n    self:debug(\"\")\n    self:debug(\"------- HC3 <-> MQTT BRIDGE\")\n    self:debug(\"Version: 1.0.221\")\n    self:debug(\"(!) IMPORTANT NOTE FOR THOSE USERS WHO USED THE QUICKAPP PRIOR TO 1.0.191 VERSION: Your Home Assistant dashboards and automations need to be reconfigured with new enity ids. This is a one-time effort that introduces a relatively \\\"small\\\" inconvenience for the greater good (a) introduce long-term stability so Home Assistant entity duplicates will not happen in certain scenarios (b) entity id namespaces are now syncronized between Fibaro and Home Assistant ecosystems\")\n\n    self:turnOn()\nend\n\nfunction QuickApp:turnOn() \n    self:establishMqttConnection()\nend\n\nfunction QuickApp:turnOff()\n    self:disconnectFromMqttAndHc3()\nend\n\nfunction QuickApp:establishMqttConnection() \n    -- IDENTIFY WHICH MQTT CONVENTIONS TO BE USED (e.g. Home Assistant, Homio, etc)\n    self.mqttConventions = { }\n    local mqttConventionStr = self:getVariable(\"mqttConvention\")\n    if (isEmptyString(mqttConventionStr)) then\n        self.mqttConventions[0] = MqttConventionHomeAssistant\n    else\n        local arr = splitString(mqttConventionStr, \",\")\n        for i, j in ipairs(arr) do\n            local convention = mqttConventionMappings[j]\n            if (convention) then\n                self.mqttConventions[i] = clone(convention)\n            end\n        end\n    end\n\n    local mqttConnectionParameters = self:getMqttConnectionParameters()\n\n    -- Anonymize MQTT username and password before being printed to log\n    local status, anonymizedMqttConnectionParameters = pcall(clone, mqttConnectionParameters)\n    if (anonymizedMqttConnectionParameters.username) then\n        anonymizedMqttConnectionParameters.username = \"anonymized-username\"\n    end\n    if (anonymizedMqttConnectionParameters.password) then\n        anonymizedMqttConnectionParameters.password = \"anonymized-password\"\n    end\n    self:trace(\"MQTT Connection Parameters: \" .. json.encode(anonymizedMqttConnectionParameters))\n\n    local mqttClient = mqtt.Client.connect(\n                                    self:getVariable(\"mqttUrl\"),\n                                    mqttConnectionParameters) \n\n    mqttClient:addEventListener('connected', function(event) self:onConnected(event) end)\n    mqttClient:addEventListener('closed', function(event) self:onClosed(event) end)\n    mqttClient:addEventListener('message', function(event) self:onMessage(event) end)\n    mqttClient:addEventListener('error', function(event) self:onError(event) end)    \n    \n    self.mqtt = mqttClient\nend\n\nfunction QuickApp:getMqttConnectionParameters()\n    local mqttConnectionParameters = {\n        -- pickup last will from primary MQTT Convention provider\n        lastWill = self.mqttConventions[1]:getLastWillMessage()\n    }\n\n    -- MQTT CLIENT ID (OPTIONAL)\n    local mqttClientId = self:getVariable(\"mqttClientId\")\n    if (isEmptyString(mqttClientId)) then\n        local autogeneratedMqttClientId = \"HC3-\" .. plugin.mainDeviceId .. \"-\" .. tostring(os.time())\n        self:debug(\"All is good - mqttClientId has been generated for you automatically \\\"\" .. autogeneratedMqttClientId .. \"\\\"\")\n        mqttConnectionParameters.clientId = autogeneratedMqttClientId\n    else\n        mqttConnectionParameters.clientId = mqttClientId\n    end\n\n    -- MQTT KEEP ALIVE PERIOD\n    local mqttKeepAlivePeriod = self:getVariable(\"mqttKeepAlive\")\n    if (mqttKeepAlivePeriod) then\n        mqttConnectionParameters.keepAlivePeriod = tonumber(mqttKeepAlivePeriod)\n    else\n        mqttConnectionParameters.keepAlivePeriod = 60\n    end\n\n    -- MQTT AUTH (USERNAME/PASSWORD)\n    local mqttUsername = self:getVariable(\"mqttUsername\")\n    local mqttPassword = self:getVariable(\"mqttPassword\")\n\n    if (mqttUsername) then\n        mqttConnectionParameters.username = mqttUsername\n    end\n    if (mqttPassword) then\n        mqttConnectionParameters.password = mqttPassword\n    end\n\n    return mqttConnectionParameters\nend\n\nfunction QuickApp:disconnectFromMqttAndHc3()\n    self.hc3ConnectionEnabled = false\n    self:closeMqttConnection()\nend\n\nfunction QuickApp:closeMqttConnection()\n    for i, j in ipairs(self.mqttConventions) do\n        if (j.mqtt ~= MqttConventionPrototype.mqtt) then\n            j:onDisconnected()\n        end\n    end\n\n    self.mqtt:disconnect()\nend\n\nfunction QuickApp:disconnectFromMqttAndHc3()\n    self.hc3ConnectionEnabled = false\n    self:closeMqttConnection()\nend\n\n\nfunction QuickApp:onClosed(event)\n    self:updateProperty(\"value\", false)\n    self:debug(\"\")\n    self:debug(\"------- Disconnected from MQTT/Home Assistant\")\nend\n\nfunction QuickApp:onError(event)\n    self:error(\"MQTT ERROR: \" .. json.encode(event))\n    if event.code == 2 then\n        self:warning(\"MQTT username and/or password is possibly indicated wrongly\")\n    end\n    self:turnOff()\n    self:scheduleReconnectToMqtt();\nend\n\nfunction QuickApp:scheduleReconnectToMqtt()\n    fibaro.setTimeout(10000, function() \n        self:debug(\"Attempt to reconnect to MQTT...\")\n        self:establishMqttConnection()\n    end)\nend\n\nfunction QuickApp:onMessage(event)\n    for i, j in ipairs(self.mqttConventions) do\n        j:onCommand(event)\n    end\nend\n\nfunction QuickApp:onConnected(event) \n    self:debug(\"\")\n    self:debug(\"------- Connected to MQTT/Home Assistant\")\n\n    for _, mqttConvention in ipairs(self.mqttConventions) do\n        mqttConvention.mqtt = self.mqtt\n        mqttConvention:onConnected()\n    end\n\n    self:discoverDevicesAndPublishToMqtt()\n\n    self.hc3ConnectionEnabled = true\n    self:scheduleHc3EventsFetcher()\n\n    self:updateProperty(\"value\", true)\nend\n\nfunction QuickApp:discoverDevicesAndPublishToMqtt()\n    local startTime = os.time()\n    local phaseStartTime = startTime\n    \n    local deviceHierarchyRootNode = self:discoverDeviceHierarchy()\n    local phaseEndTime = os.time()\n    \n    self:debug(\"\")\n    self:debug(\"-------- Fibaro device discovery has been complete in \" .. (phaseEndTime - phaseStartTime) .. \" second(s)\")\n    self:debug(\"Total Fibaro devices                 : \" .. allFibaroDevicesAmount)\n    self:debug(\"Filtered Fibaro devices to           : \" .. filteredFibaroDevicesAmount)\n    self:debug(\"Number of Home Assistant entities    : \" .. identifiedHaEntitiesAmount .. \" => number of supported Fibaro devices + automatically generated entities for power, energy and battery sensors (when found appropriate interfaces for a Fibaro device) + automatically generated  remote controllers, where cartesian join is applied for each key and press types\")\n    self:debug(\"\")\n    printDeviceNode(deviceHierarchyRootNode, 0)\n\n    phaseStartTime = os.time()\n    self:publishDeviceNodeToMqtt(deviceHierarchyRootNode)\n    phaseEndTime = os.time()    \n\n    self:debug(\"\")\n    self:debug(\"------- Fibaro device configuration and states have been distributed to MQTT/Home Assistant in \" .. (phaseEndTime - phaseStartTime) .. \" second(s)\")\n\n    local diff = os.time() - startTime\n\n    self:updateView(\"totalFibaroDevices\", \"text\", \"Total Fibaro devices: \" .. allFibaroDevicesAmount)\n    self:updateView(\"filteredFibaroDevices\", \"text\", \"Filtered Fibaro devices: \" .. filteredFibaroDevicesAmount)\n    self:updateView(\"haEntities\", \"text\", \"Home Assistant entities: \" .. identifiedHaEntitiesAmount)\n \n    self:updateView(\"bootTime\" , \"text\", \"Boot time: \" .. diff .. \"s\")\nend\n\nfunction QuickApp:discoverDeviceHierarchy()\n    local developmentModeStr = self:getVariable(\"developmentMode\")\n    if ((not developmentModeStr) or (developmentModeStr ~= \"true\")) then\n        self:debug(\"Bridge mode: PRODUCTION\")\n\n        local customDeviceFilterJsonStr = getCompositeQuickAppVariable(self, \"deviceFilter\")\n        if (isEmptyString(customDeviceFilterJsonStr)) then\n            self:debug(\"All is good - default filter applied, where only enabled and visible devices are used\")\n        end\n\n        fibaroDevices = getDeviceHierarchyByFilter(customDeviceFilterJsonStr)\n    else\n        -- smaller number of devices for development and testing purposes\n        self:debug(\"Bridge mode: DEVELOPMENT (temporary unsupported)\")\n        --[[\n        fibaroDevices = {\n            enrichFibaroDeviceWithMetaInfo(\n                json.decode(\n                    \"{  }\"\n                )\n            ) \n        }\n        ]]--\n    end\n\n    return fibaroDevices\nend\n\n-- *** rename to \"*AndItsChildren\"\nfunction QuickApp:publishDeviceNodeToMqtt(deviceNode)\n    if (deviceNode.identifiedHaEntity) then\n        self:__publishDeviceNodeToMqtt(deviceNode)\n    end\n\n    for _, fibaroDeviceChildNode in pairs(deviceNode.childNodeList) do\n        self:publishDeviceNodeToMqtt(fibaroDeviceChildNode)\n    end\nend\n\nfunction QuickApp:discoverDevicesByFilter()\n    local fibaroDevices\n\n    local developmentModeStr = self:getVariable(\"developmentMode\")\n    if ((not developmentModeStr) or (developmentModeStr ~= \"true\")) then\n        self:debug(\"Bridge mode: PRODUCTION\")\n\n        local customDeviceFilterJsonStr = self:getVariable(\"deviceFilter\")\n        if (isEmptyString(mqttClientId)) then\n            self:debug(\"All is good - default filter applied, where only enabled and visible devices are used\")\n        end\n\n        fibaroDevices = getFibaroDevicesByFilter(customDeviceFilterJsonStr)\n    else\n        --smaller number of devices for development and testing purposes\n        self:debug(\"Bridge mode: DEVELOPMENT\")\n\n        fibaroDevices = {\n            enrichFibaroDeviceWithMetaInfo(\n                json.decode(\n                    \"{  }\"\n                )\n            ) \n        }\n    end\n\n    return fibaroDevices\nend\n\nfunction QuickApp:__publishDeviceNodeToMqtt(deviceNode)\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE EXISTANCE\n    ------------------------------------------------------------------\n    for i, j in ipairs(self.mqttConventions) do\n        j:onDeviceNodeCreated(deviceNode)\n    end\n\n    ------------------------------------------------------------------\n    ------- ANNOUNCE DEVICE CURRENT STATE => BY SIMULATING HC3 EVENTS\n    ------------------------------------------------------------------\n    self:__publishDeviceProperties(deviceNode.fibaroDevice)\nend\n\nfunction QuickApp:__publishDeviceProperties(fibaroDevice)\n    self:simulatePropertyUpdate(fibaroDevice, \"dead\", fibaroDevice.properties.dead)\n    self:simulatePropertyUpdate(fibaroDevice, \"state\", fibaroDevice.properties.state)\n    self:simulatePropertyUpdate(fibaroDevice, \"value\", fibaroDevice.properties.value)\n    self:simulatePropertyUpdate(fibaroDevice, \"heatingThermostatSetpoint\", fibaroDevice.properties.heatingThermostatSetpoint)\n    self:simulatePropertyUpdate(fibaroDevice, \"thermostatMode\", fibaroDevice.properties.thermostatMode)\n    self:simulatePropertyUpdate(fibaroDevice, \"energy\", fibaroDevice.properties.energy)\n    self:simulatePropertyUpdate(fibaroDevice, \"power\", fibaroDevice.properties.power)\n    self:simulatePropertyUpdate(fibaroDevice, \"batteryLevel\", fibaroDevice.properties.batteryLevel)\n    self:simulatePropertyUpdate(fibaroDevice, \"color\", fibaroDevice.properties.color)\nend\n\nfunction QuickApp:onPublished(event)\n    -- do nothing, for now\nend\n\n-- FETCH HC3 EVENTS\nlocal lastRefresh = 0\nlocal http = net.HTTPClient()\n\nfunction QuickApp:scheduleHc3EventsFetcher()\n    self.errorCacheMap = { }\n    self.errorCacheTimeout = 60\n    self.gotWarning = false\n    \n    self.eventProcessorIsActive = false\n\n    self:scheduleAnotherPollingForHc3()\n\n    self:debug(\"\")\n    self:debug(\"------- Connected to Fibaro Home Center 3 events feed\")\nend\n\nfunction QuickApp:scheduleAnotherPollingForHc3()\n    if (self.hc3ConnectionEnabled) then\n        local delay\n        if self.gotWarning then\n            -- avoid hitting errors with a \"speed of light\"\n            delay = 1000\n        else\n            -- provide fast events distribution to Home Assistant when no errors present\n            delay = 50\n        end\n\n        fibaro.setTimeout(delay, function()\n            self:readHc3EventAndScheduleFetcher()\n        end)\n    else\n        self:debug(\"\")\n        self:debug(\"------- Disconnected from Fibaro HC3\")\n    end\nend\n\nfunction QuickApp:readHc3EventAndScheduleFetcher()\n    -- This a reliable and high-performance method to get events from Fibaro HC3, by using non-blocking HTTP calls\n\n    -- no 2+ jobs to be executed twice\n    self.eventProcessorIsActive = true\n\n    local requestUrl = \"http://127.0.0.1:11111/api/refreshStates?last=\" .. lastRefresh\n\n    local stat, res = http:request(\n        requestUrl,\n        {\n        options = { },\n        success=function(res)\n            local data\n            if (res and not isEmptyString(res.data)) then\n                self:processFibaroHc3Events(json.decode(res.data))\n                self:scheduleAnotherPollingForHc3()\n            else\n                self:error(\"Error while fetching events from Fibaro HC3. Response status code is \" .. res.status .. \". HTTP response body is '\" .. json.encode(res) .. \"'\")\n                self:turnOff()\n            end\n        end,\n        error=function(res) \n            self:error(\"Error while fetching Fibaro HC3 events \" .. json.encode(res))\n            self:turnOff()\n        end\n    })\nend\n\nfunction QuickApp:processFibaroHc3Events(data)\n    self.gotWarning = false\n\n    --if not self.hc3ConnectionEnabled then\n    --    return\n    --end\n\n    -- Simulate repeatable broken status\n    --data.status = \"STARTING_SERVICES\"\n\n    if (data.status ~= 200 and data.status ~= \"IDLE\") then\n        self.gotWarning = true\n        if (not data.status) then\n            data.status = \"<unknown>\"\n        end\n\n        -- filter out repeatable errors\n        local lastErrorReceivedTimestamp = self.errorCacheMap[data.status]\n        local currentTimestamp = os.time()\n        if ((not lastErrorReceivedTimestamp) or (lastErrorReceivedTimestamp < (currentTimestamp - self.errorCacheTimeout))) then\n            self:warning(\"Unexpected response status \\\"\" .. tostring(data.status) .. \"\\\", muting any repeated warnings for \" .. self.errorCacheTimeout .. \" seconds\")\n            self:trace(\"Full response body: \" .. json.encode(data))\n\n            -- mute repeatable warnings temporary (avoid spamming to logs)\n            self.errorCacheMap[data.status] = currentTimestamp\n        end\n    end\n\n    local events = data.events\n\n    if (data.last) then\n        lastRefresh = data.last\n    end\n\n    if events and #events>0 then \n        for i, v in ipairs(events) do\n            -- *** rename dispatch to \"PROCESS\" / ename onDeviceCreated and so on => \"dispatchToMqtt\"\n            self:dispatchFibaroEventToMqtt(v)\n        end\n    end\nend\n\nfunction QuickApp:simulatePropertyUpdate(fibaroDevice, propertyName, value)\n    if value ~= nil then\n        local event = createFibaroEventPayload(fibaroDevice, propertyName, value)\n        event.simulation = true\n        self:dispatchFibaroEventToMqtt(event)\n    end\nend\n\ndeviceModifiedEventTimestamps = {}\ndeviceCreatedEventTimestamps = {}\nfunction QuickApp:dispatchFibaroEventToMqtt(event)\n    if (not event) then\n        self:error(\"No event found\")\n        return\n    end\n\n    if (not event.data) then\n        self:error(\"No event data found\")\n        return\n    end\n\n    local fibaroDeviceId = event.data.id or event.data.deviceId\n\n    -- *** add origin event source id\n\n    if not fibaroDeviceId then\n        -- This is a system level event, which is not bound to a particular device => ignore\n        return\n    end \n\n    local eventType = event.type\n    if (not eventType) then\n        eventType = \"<unknown>\"\n    end\n\n    local deviceNode = getDeviceNodeById(fibaroDeviceId)\n\n    if (deviceNode) then\n        -- process events for devices that are required to be known to the QuickApp\n        if deviceNode.included then\n            -- process events for devices that are included by user filter criteria\n            local haEntity = deviceNode.identifiedHaEntity\n            if haEntity then\n                if (eventType == \"DevicePropertyUpdatedEvent\") then\n                    return self:dispatchDevicePropertyUpdatedEvent(deviceNode, event) \n                elseif (eventType == \"CentralSceneEvent\") then\n                    -- convert to DevicePropertyUpdatedEvent event, so we reuse the existing value dispatch mechanism rather than reinventing a wheel\n                    local keyValueMapAsString = event.data.keyId .. \",\" .. string.lower(event.data.keyAttribute)\n                    self:trace(\"Action => \" .. event.data.keyId .. \"-\" .. string.lower(event.data.keyAttribute))\n                    return self:simulatePropertyUpdate(deviceNode, \"value\", keyValueMapAsString)\n                elseif (eventType == \"DeviceModifiedEvent\") then\n                    -- Fibaro generates \"DeviceModifiedEvent\" event after \"DeviceCreatedEvent\" => filter out the reduntant event \n                    \n                    local deviceLastCreationTimestamp = deviceCreatedEventTimestamps[fibaroDeviceId]\n                    local deviceLastModificationTimestamp = deviceModifiedEventTimestamps[fibaroDeviceId]\n                    if ((deviceLastCreationTimestamp) and (deviceLastCreationTimestamp == event.created)) then\n                        self:debug(\"Ignore duplicate event for 'DeviceModifiedEvent' as it's called right after 'DeviceCreatedEvent'\")\n                        return\n                    elseif ((deviceLastModificationTimestamp) and (deviceLastModificationTimestamp == event.created)) then\n                        self:debug(\"Ignore duplicate event for 'DeviceModifiedEvent' as it's called right after another 'DeviceModifiedEvent'\")\n                        return\n                    else\n                        return self:dispatchDeviceModifiedEvent(deviceNode)\n                    end\n                elseif (eventType == \"DeviceRemovedEvent\") then \n                    return self:dispatchDeviceRemovedEvent(deviceNode)\n                else\n                    -- unsupported event type => ignore\n                    return\n                end\n            else\n                -- event for unsupported device => ignore\n                return\n            end\n        \n        else\n            -- event for a device excluded by user filter criteria => ignore\n            return\n        end\n\n    else \n        -- process events for devices that are NOT REQUIRED to be known to the QuickApp \n        if (eventType == \"DeviceCreatedEvent\") then\n            deviceCreatedEventTimestamps[fibaroDeviceId] = event.created\n            return self:dispatchDeviceCreatedEvent(fibaroDeviceId)\n        else\n            -- ignore unknown devices\n            return\n        end\n    end\n\n    -- Ignore and show no redundant warnings for unsupported event types\n    if (unsupportedFibaroEventTypes[eventType]) then\n        -- Ignore and show no redundant warnings\n        return\n    end\n\n    self:debug(\"Couldn't process event \\\"\" .. eventType .. \"\\\" for \" .. getDeviceDescriptionById(fibaroDeviceId))\n    self:debug(json.encode(event))\nend\n\nfunction QuickApp:dispatchDevicePropertyUpdatedEvent(deviceNode, event)\n    -- *** OVERRIDE FIBARO PROPERTY NAMES, FOR BEING MORE CONSISTENT AND THUS EASIER TO HANDLE \n    local haEntity = deviceNode.identifiedHaEntity\n    local propertyName = event.data.property\n    if not propertyName then\n        propertyName = \"unknown\"\n    end\n\n    if (haEntity.type == \"binary_sensor\") and (propertyName == \"value\") then\n        -- Fibaro uses state/value fields inconsistently for binary sensor. Replace value --> state field\n        event.data.property = \"state\"\n    end\n\n    local value = event.data.newValue\n    if (isNumber(value)) then\n        value = round(value, 2)\n    end\n\n    event.data.newValue = (type(value) == \"number\" and value or tostring(value))\n    \n    for i, j in ipairs(self.mqttConventions) do\n        j:onPropertyUpdated(deviceNode, event)\n    end\nend\n\nfunction QuickApp:rememberLastMqttCommandTime(deviceId)\n    self.lastMqttCommandTime[deviceId] = os.time()\nend\n\nfunction QuickApp:dispatchDeviceCreatedEvent(fibaroDeviceId)\n    local newDeviceNode = createAndAddDeviceNodeToHierarchyById(fibaroDeviceId)\n\n    if (newDeviceNode.included and newDeviceNode.identifiedHaEntity) then\n        self:debug(\"Fibaro device \" .. newDeviceNode.id .. \" added\")\n        for i, j in ipairs(self.mqttConventions) do\n            j:onDeviceNodeCreated(newDeviceNode)\n        end\n        \n        self:__publishDeviceProperties(newDeviceNode.fibaroDevice)\n\n        printDeviceNode(newDeviceNode, 1)\n    else\n        self:debug(\"New device \" .. newDeviceNode.id .. \" will not be added\")\n    end\nend\n\nfunction QuickApp:dispatchDeviceModifiedEvent(deviceNode)\n    self:debug(\"Fibaro device \" .. deviceNode.id .. \" got modified => its old configuration to be removed, and then the new one added by the QuickApp\")\n\n    self:dispatchDeviceRemovedEvent(deviceNode)\n\n    self:dispatchDeviceCreatedEvent(deviceNode.id)\nend\n\nfunction QuickApp:dispatchDeviceRemovedEvent(deviceNode)\n    removeDeviceNodeFromHierarchyById(deviceNode.id)\n\n    for _, mqttConvention in ipairs(self.mqttConventions) do\n        mqttConvention:onDeviceNodeRemoved(deviceNode)\n\n        for _, childNode in ipairs(deviceNode.childNodeList) do\n            self:dispatchDeviceRemovedEvent(childNode)\n        end\n\n    end\n    self:debug(\"Fibaro device removed \" .. deviceNode.id)\nend\n\nfunction QuickApp:logDeviceNode(id)\n    local deviceNode = getDeviceNodeById(id)\n    print(\"------- DEVICE NODE INFO FOR #\" .. id)\n    print(\"Matched filter criteria: \" ..tostring(deviceNode.included))\n    print(\"Fibaro device: \" ..json.encode(deviceNode.fibaroDevice))\n\n    local haDeviceStr\n    if deviceNode.identifiedHaDevice then\n        haDeviceStr = json.encode(deviceNode.identifiedHaDevice)\n    else \n        haDeviceStr = \"not found => not supported by the Quick App\"\n    end\n    print(\"Home Assistant physical device: \" .. haDeviceStr)\n\n    local haEntityStr\n    if deviceNode.identifiedHaEntity then\n        local haEntity = deviceNode.identifiedHaEntity\n        local haEntityCopy = { \n            id = haEntity.id,\n            name = haEntity.name,\n            roomName = haEntity.roomName,\n            type = haEntity.type,\n            subtype = haEntity.subtype,\n            icon = haEntity.icon\n        } \n        if (haEntityCopy.linkedEntity) then\n            haEntityCopy.linkedEntity = getDeviceDescriptionById(haEntityCopy.linkedEntity.id)\n        end\n\n        if (haEntityCopy.type == \"climate\") then\n            local sensor =  haEntity:getTemperatureSensor()\n            if sensor then\n                haEntityCopy.temperatureSensor = getDeviceDescriptionById(haEntity:getTemperatureSensor().id)\n            else\n                haEntityCopy.temperatureSensor = \"no temperature sensor attached\"\n            end\n        end\n\n        haEntityStr = json.encode(haEntityCopy)\n    else \n        haEntityStr = \"not found => not supported by the Quick App\"\n    end\n    print(\"Home Assistant logical entity: \" .. haEntityStr)\n\n    print(\"Children count : \" .. tostring(#deviceNode.childNodeList))\nend\n\nunsupportedFibaroEventTypes = {\n    DeviceActionRanEvent = true,\n    DeviceChangedRoomEvent = true,\n    QuickAppFilesChangedEvent = true, \n    PluginChangedViewEvent = true\n}\n\n-- *** FORMATTED LOG %d\n"},{"name":"tools","isMain":false,"isOpen":true,"content":"local alphabet = {\r\n    [\"А\"] = \"A\",\r\n    [\"Б\"] = \"B\",\r\n    [\"В\"] = \"V\",\r\n    [\"Г\"] = \"G\",\r\n    [\"Д\"] = \"D\",\r\n    [\"Е\"] = \"E\",\r\n    [\"Ж\"] = \"Zh\",\r\n    [\"З\"] = \"Z\",\r\n    [\"И\"] = \"I\",\r\n    [\"І\"] = \"I\",\r\n    [\"Ї\"] = \"I\",\r\n    [\"Й\"] = \"I\",\r\n    [\"К\"] = \"K\",\r\n    [\"Л\"] = \"L\",\r\n    [\"М\"] = \"M\",\r\n    [\"Н\"] = \"N\",\r\n    [\"О\"] = \"O\",\r\n    [\"П\"] = \"P\",\r\n    [\"Р\"] = \"R\",\r\n    [\"С\"] = \"S\",\r\n    [\"Т\"] = \"T\",\r\n    [\"У\"] = \"U\",\r\n    [\"Ф\"] = \"F\",\r\n    [\"Х\"] = \"H\",\r\n    [\"Ч\"] = \"Ch\",\r\n    [\"Ц\"] = \"C\",\r\n    [\"Ш\"] = \"Sh\",\r\n    [\"Щ\"] = \"Shch\",\r\n    [\"И\"] = \"I\",\r\n    [\"Є\"] = \"E\",\r\n    [\"Э\"] = \"E\",\r\n    [\"Ю\"] = \"Ju\",\r\n    [\"Я\"] = \"Ja\",\r\n    [\"а\"] = \"a\",\r\n    [\"б\"] = \"b\",\r\n    [\"в\"] = \"v\",\r\n    [\"г\"] = \"g\",\r\n    [\"д\"] = \"d\",\r\n    [\"е\"] = \"e\",\r\n    [\"~\"] = \"e\",\r\n    [\"ж\"] = \"zh\",\r\n    [\"з\"] = \"z\",\r\n    [\"и\"] = \"i\",\r\n    [\"і\"] = \"i\",\r\n    [\"ї\"] = \"i\",\r\n    [\"й\"] = \"i\",\r\n    [\"к\"] = \"k\",\r\n    [\"л\"] = \"l\",\r\n    [\"м\"] = \"m\",\r\n    [\"н\"] = \"n\",\r\n    [\"о\"] = \"o\",\r\n    [\"п\"] = \"p\",\r\n    [\"р\"] = \"r\",\r\n    [\"с\"] = \"s\",\r\n    [\"т\"] = \"t\",\r\n    [\"у\"] = \"u\",\r\n    [\"ф\"] = \"f\",\r\n    [\"х\"] = \"h\",\r\n    [\"ч\"] = \"ch\",\r\n    [\"ц\"] = \"c\",\r\n    [\"ш\"] = \"sh\",\r\n    [\"щ\"] = \"shch\",\r\n    [\"ы\"] = \"i\",\r\n    [\"ь\"] = \"'\",\r\n    [\"є\"] = \"e\",\r\n    [\"э\"] = \"e\",\r\n    [\"ю\"] = \"ju\",\r\n    [\"я\"] = \"ja\"\r\n}\r\n\r\nfunction transliterate(input)\r\n    if (not input) then\r\n        return \"unknown_input_for_transliteration\"\r\n    end\r\n\r\n    local output = {}\r\n    local i = 1\r\n\r\n    for p, c in utf8.codes(input) do  \r\n        local char = utf8.char(c)\r\n        local outputCharacter = alphabet[char]\r\n\r\n        if not outputCharacter then\r\n        if (string.find(char, \"%a\") or string.find(char, \"%d\")) then\r\n            outputCharacter = char\r\n        else\r\n            outputCharacter = \"-\"\r\n        end\r\n\r\n        end\r\n        output[i] = outputCharacter\r\n        i = i + 1\r\n    end\r\n\r\n    --print(\"RESULT \" .. table.concat(output) ) \r\n\r\n    return table.concat(output) \r\nend\r\n\r\nfunction extractMetaInfoFromDeviceName(deviceName)\r\n    local metaInfo = {\r\n        pureName = deviceName,\r\n        autoPower = true,\r\n        turnOffTimeout = 10 * 60,\r\n        segmentId = -1,\r\n    }\r\n    \r\n    local s, e = string.find(deviceName, \"%[.+%]\")\r\n    if s and e then\r\n        local pureName = string.gsub(string.sub(deviceName, 1, s-1), \"%s+$\", \"\")\r\n        local metaStr = string.sub(deviceName, s+1, e-1)\r\n\r\n        metaInfo.pureName = pureName\r\n \r\n        local attrs = splitStringToNumbers(metaStr, \"%.\")\r\n        if attrs[1] == \"1\" then\r\n            metaInfo.autoPower = true\r\n        else\r\n            metaInfo.autoPower = false\r\n        end\r\n\r\n        if attrs[2] and attrs[2] ~= \"-\" then \r\n            metaInfo.turnOffTimeout = math.ceil(attrs[2] * 60)\r\n        end\r\n\r\n        if attrs[3] and attrs[3] ~= \"-\" then \r\n            metaInfo.segmentId = tonumber(attrs[3])\r\n            metaInfo.rooms = {}\r\n\r\n            local segmentIdsStr = fibaro.getGlobalVariable(\"segment_\" .. metaInfo.segmentId)\r\n            if segmentIdsStr then\r\n                local roomIds = splitStringToNumbers(segmentIdsStr, \",\")\r\n                for i,roomIdStr in ipairs(roomIds) do\r\n                    metaInfo.rooms[i] = roomIdStr\r\n                end\r\n            end\r\n        end\r\n    else\r\n        metaInfo.name = deviceName\r\n    end\r\n\r\n    return metaInfo\r\nend\r\n\r\nfunction splitString(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c:gsub(\"^%s*(.-)%s*$\", \"%1\") end)\r\n  return fields\r\nend\r\n\r\n\r\nfunction splitStringToNumbers(str, sep)\r\n  local fields = {}\r\n  str:gsub(\"([^\" .. sep ..\"]+)\",function(c) fields[#fields+1]=c end)\r\n  return fields\r\nend\r\n\r\nfunction table_contains_value(tab, val)\r\n    if not tab then\r\n        return false\r\n    end\r\n    \r\n    for index, value in ipairs(tab) do\r\n        if value == val then\r\n            return true\r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction createFibaroEventPayload(device, propertyName, newValue) \r\n    -- THIS IS FIBARO EVENT FORMAT => DO NOT CHANGE VARIABLE NAMES\r\n    local payload = {\r\n        data = {\r\n            id = device.id,\r\n            property = propertyName,\r\n            newValue = newValue\r\n        },\r\n        type = \"DevicePropertyUpdatedEvent\",\r\n        created = os.time()\r\n    }\r\n\r\n    return payload\r\nend\r\n\r\nfunction isEmptyString(s)\r\n  return s == nil or s == \"\"\r\nend\r\n\r\nfunction isNotEmptyString(s)\r\n    return not isEmptyString(s)\r\nend\r\n\r\nfunction base64Encode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    return ((data:gsub('.', function(x) \r\n        local r,b='',x:byte()\r\n        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\r\n        if (#x < 6) then return '' end\r\n        local c=0\r\n        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\r\n        return b:sub(c+1,c+1)\r\n    end)..({ '', '==', '=' })[#data%3+1])\r\nend\r\n\r\nfunction base64Decode(data)\r\n    local b ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\n    data = string.gsub(data, '[^'..b..'=]', '')\r\n    return (data:gsub('.', function(x)\r\n        if (x == '=') then return '' end\r\n        local r,f='',(b:find(x)-1)\r\n        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\r\n        return r;\r\n    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\r\n        if (#x ~= 8) then return '' end\r\n        local c=0\r\n        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\r\n        return string.char(c)\r\n    end))\r\nend\r\n\r\nfunction decodeBase64Auth(encoded)\r\n    local decoded = base64Decode(encoded)\r\n    \r\n    local i = string.find(decoded, \":\")\r\n\r\n    if i then\r\n        return string.sub(decoded, 0, i-1), string.sub(decoded, i+1, string.len(decoded))\r\n    else\r\n        return nil\r\n    end\r\nend\r\n\r\nfunction shallowInsertTo(from, to)\r\n    local orig_type = type(from)\r\n    if orig_type == 'table' then\r\n        for orig_key, orig_value in pairs(from) do\r\n            table.insert(to, orig_value)\r\n        end\r\n    else -- number, string, boolean, etc\r\n        copy = from\r\n    end\r\nend\r\n\r\nfunction shallowCopyTo(from, to)\r\n    local orig_type = type(from)\r\n    if orig_type == 'table' then\r\n        for orig_key, orig_value in pairs(from) do\r\n            to[orig_key] = orig_value\r\n        end\r\n    else -- number, string, boolean, etc\r\n        copy = from\r\n    end\r\nend\r\n\r\n\r\nfunction clone(orig)\r\n    local orig_type = type(orig)\r\n    local copy\r\n    if orig_type == 'table' then\r\n        copy = {}\r\n        for orig_key, orig_value in next, orig, nil do\r\n            copy[clone(orig_key)] = clone(orig_value)\r\n        end\r\n        --setmetatable(copy, clone(getmetatable(orig)))\r\n    else -- number, string, boolean, etc\r\n        copy = orig\r\n    end\r\n    return copy\r\nend\r\n\r\nfunction inheritFrom(orig)\r\n    return clone(orig)\r\nend\r\n\r\nfunction isNumber(value)\r\n    if type(value) == \"number\" then return true end\r\n\r\n    if value == tostring(tonumber(value)) then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\nfunction round(number, dec)\r\n    local k = 10^dec\r\n\r\n    local result = math.floor(number * k + 0.5) / k\r\n\r\n    local resultWithoutTrailingZero = math.floor(result)\r\n    if (resultWithoutTrailingZero ~= result) then\r\n        return result\r\n    else\r\n        return resultWithoutTrailingZero\r\n    end\r\n\r\n    return result\r\nend\r\n\r\nfunction identifyLocalIpAddressForHc3()\r\n    local networkInterfaces = api.get(\"/proxy?url=http://127.0.0.1:11112/api/settings/network\")\r\n    for i, j in pairs(networkInterfaces.networkConfig) do\r\n        if (j.enabled) then\r\n            return j.ipConfig.ip\r\n        end\r\n    end\r\n\r\n    print(\"[WARNING] Cannot identify HC3 local ip address\")\r\n    \r\n    return \"unknown\"\r\nend\r\n\r\ntable.indexOf = function( t, object )\r\n\tlocal result\r\n\r\n    for i=1,#t do\r\n        if object == t[i] then\r\n            result = i\r\n            break\r\n        end\r\n    end\r\n\r\n\treturn result\r\nend\r\n\r\nfunction getCompositeQuickAppVariable(quickApp, variableName)\r\n    local compositeValue\r\n    compositeValue = quickApp:getVariable(variableName)\r\n\r\n    if isNotEmptyString(compositeValue) then\r\n        for i=2, 10 do\r\n            local value = quickApp:getVariable(variableName .. i)\r\n            if isNotEmptyString(value) then\r\n                compositeValue = compositeValue .. value\r\n            else\r\n                break\r\n            end\r\n        end\r\n    end\r\n\r\n    return compositeValue\r\nend"},{"name":"mqtt_convention_api","isMain":false,"isOpen":true,"content":"MqttConventionPrototype = {\r\n    type = \"'type' needs to be overriden\", \r\n    mqtt = \"MQTT connection must be established first\"\r\n}\r\n \r\nfunction MqttConventionPrototype:getLastWillMessage() \r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onConnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceNodeCreated(deviceNode)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDeviceNodeRemoved(deviceNode)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onPropertyUpdated(deviceNode, event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onCommand(event)\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\nfunction MqttConventionPrototype:onDisconnected()\r\n    error(\"function is mandatory for implementation\")\r\nend\r\n\r\n-----------------------------------\r\n-- HOME ASSISTANT \r\n-----------------------------------\r\nMqttConventionHomeAssistant = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomeAssistant.type = \"Home Assistant\"\r\nMqttConventionHomeAssistant.rootTopic = \"homeassistant/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomeAssistant:getDeviceTopic(haEntity)\r\n    return self.rootTopic .. tostring(haEntity.type) .. \"/\" .. haEntity.id .. \"/\"\r\nend\r\nfunction MqttConventionHomeAssistant:getGenericEventTopic(haEntity, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(haEntity) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(haEntity) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomeAssistant:getterTopic(haEntity, propertyName)\r\n    if (haEntity.linkedEntity and propertyName == \"value\") then\r\n        local result = self:getGenericEventTopic(haEntity.linkedEntity, \"DevicePropertyUpdatedEvent\", haEntity.linkedProperty)\r\n        return result\r\n    elseif (haEntity.linkedEntity and propertyName == \"dead\") then \r\n        local result = self:getGenericEventTopic(haEntity.linkedEntity, \"DevicePropertyUpdatedEvent\", \"dead\")\r\n        return result\r\n    else\r\n        return self:getGenericEventTopic(haEntity, \"DevicePropertyUpdatedEvent\", propertyName)\r\n    end\r\nend\r\nfunction MqttConventionHomeAssistant:getGenericCommandTopic(haEntity, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(haEntity) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(haEntity) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:setterTopic(haEntity, propertyName)\r\n    return self:getGenericCommandTopic(haEntity, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getLastWillAvailabilityTopic()\r\n    return self.rootTopic .. \"hc3-status\"\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:getLastWillMessage()\r\n    return {\r\n        topic = self:getLastWillAvailabilityTopic(),\r\n        payload = \"offline\",\r\n        {\r\n            retain = true\r\n        }\r\n    }\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onConnected()\r\n    self.mqtt:publish(self:getLastWillAvailabilityTopic(), \"online\", {retain = true})\r\n\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/set/+\")\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDisconnected()\r\n    self.mqtt:publish(self:getLastWillAvailabilityTopic(), \"offline\", {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceNodeCreated(deviceNode)\r\n    local haEntity = deviceNode.identifiedHaEntity\r\n    if (haEntity.type == RemoteControllerKey.type) then\r\n        -- Home Assistant pretty unique spec for \"device_automation/trigger\" devices\r\n        -- so better use another factory type for MQTT Discovery Message\r\n        MqttConventionHomeAssistant:onRemoteControllerKeyCreated(deviceNode, self.mqtt)\r\n        return\r\n    end\r\n\r\n    ------------------------------------------\r\n    --- AVAILABILITY\r\n    ------------------------------------------\r\n    local msg = {\r\n        unique_id = tostring(haEntity.id),\r\n        object_id = tostring(haEntity.id),\r\n        name = haEntity.name .. \" (\" .. haEntity.roomName .. \")\",\r\n\r\n        availability_mode = \"all\",\r\n        availability = {\r\n            {\r\n                topic = self:getLastWillAvailabilityTopic(),\r\n                payload_available = \"online\",\r\n                payload_not_available = \"offline\"\r\n            }\r\n            ,\r\n            {\r\n                topic = self:getterTopic(haEntity, \"dead\"),\r\n                payload_available = \"false\",\r\n                payload_not_available = \"true\",\r\n                value_template = \"{{ value_json.value }}\"\r\n            }\r\n        },\r\n\r\n        json_attributes_topic = self:getDeviceTopic(haEntity) .. \"config_json_attributes\" \r\n    }\r\n\r\n    ------------------------------------------\r\n    --- PARENT DEVICE INFO\r\n    ------------------------------------------\r\n    msg.device = deviceNode.identifiedHaDevice\r\n\r\n    ------------------------------------------\r\n    --- USE \"TRUE\"/\"FALSE\" VALUE PAYLOAD, instead of \"ON\"/\"OFF\"\r\n    ------------------------------------------\r\n    if (haEntity.supportsRead) then\r\n        if (haEntity.supportsBinary and haEntity.type ~= \"cover\") then \r\n            msg.payload_on = \"true\"\r\n            msg.payload_off = \"false\"\r\n        end\r\n    end\r\n    \r\n    ------------------------------------------\r\n    ---- READ\r\n    ------------------------------------------\r\n    -- Does device have binary state to share?\r\n    if (haEntity.supportsRead and haEntity.supportsBinary) then\r\n        msg.state_topic = self:getterTopic(haEntity, \"state\")\r\n        \r\n        if (haEntity.type == \"light\") then\r\n            msg.state_value_template = \"{{ value_json.value }}\"\r\n        else\r\n            -- wish Home Assistant spec was consistent for all device types and \"state_value_template\" was used for all the devices with \"state\" property\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        end\r\n    end\r\n    -- Does device have multilevel state to share?\r\n    if (haEntity.supportsRead and haEntity.supportsMultilevel) then\r\n        if (haEntity.type == \"light\") then\r\n            msg.brightness_state_topic = self:getterTopic(haEntity, \"value\")\r\n            msg.brightness_value_template = \"{{ value_json.value }}\"\r\n        elseif (haEntity.type == \"cover\") then\r\n            -- Home Assistant to interpret state from \"position_topic\"\r\n            msg.state_topic = nil\r\n\r\n            msg.position_topic = self:getterTopic(haEntity, \"value\")\r\n        elseif (haEntity.type == \"sensor\") then\r\n            msg.state_topic = self:getterTopic(haEntity, \"value\")\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        else\r\n            msg.value_template = \"{{ value_json.value }}\"\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- WRITE\r\n    ------------------------------------------\r\n    -- Does haEntity support binary write operations?\r\n    if (haEntity.supportsWrite and haEntity.supportsBinary) then\r\n        msg.command_topic = self:setterTopic(haEntity, \"state\")\r\n    end\r\n    -- Does haEntity support multilevel write operations?\r\n    if (haEntity.supportsWrite) and (haEntity.supportsMultilevel) then\r\n        if (haEntity.type == \"light\") then\r\n            msg.brightness_command_topic = self:setterTopic(haEntity, \"value\")\r\n            msg.brightness_scale = 99\r\n            msg.on_command_type = \"first\"\r\n        elseif (haEntity.type == \"cover\") then\r\n            msg.set_position_topic = self:setterTopic(haEntity, \"value\")\r\n            msg.position_template = \"{{ value_json.value }}\"\r\n            -- value_template is deprecated since Home Assistant Core 2021.6. \r\n            msg.value_template = nil\r\n            msg.position_open = 100\r\n            msg.position_closed = 0\r\n\r\n            msg.payload_open = \"open\"\r\n            msg.payload_close = \"close\"\r\n            msg.payload_stop = \"stop\"\r\n\r\n            --[[\r\n            msg.state_closed = \"closed\"\r\n            msg.state_closing = \"closing\"\r\n            msg.state_open = \"open\"\r\n            msg.state_opening = \"opening\"\r\n            ]]--\r\n\r\n            msg.state_topic = self:setterTopic(haEntity, \"state\")\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- SENSOR SPECIFIC\r\n    ------------------------------------------\r\n    if (haEntity.type == \"binary_sensor\" or haEntity.type == \"sensor\") then\r\n        -- *** refactor, but keep device_class 'None' when default sensor is used by the QuickApp\r\n        if (PrototypeEntity.subtype ~= haEntity.subtype) then\r\n            msg.device_class = haEntity.subtype\r\n        end\r\n        -- *** refactor?\r\n        if (PrototypeEntity.bridgeUnitOfMeasurement ~= haEntity.bridgeUnitOfMeasurement) then\r\n            msg.unit_of_measurement = haEntity.bridgeUnitOfMeasurement\r\n        end\r\n\r\n        -- Energy meter requires extra properties\r\n        if (haEntity.subtype == \"energy\") then\r\n            msg.state_class = \"total_increasing\"\r\n        end\r\n\r\n        if (haEntity.subtype == RemoteController.subtype) then\r\n            -- Remote controller sensor is not natively supported by Home Assistant, thus need to replace \"remoteController\" subtype with \"None\" haEntity class\r\n            msg.device_class = nil\r\n            -- Add \"remote\" icon\r\n            msg.icon = \"mdi:remote\"\r\n        end\r\n\r\n        if (haEntity.type == RemoteController.type) and (haEntity.subtype == RemoteController.subtype) then\r\n            msg.expire_after = 10\r\n        end\r\n    end\r\n\r\n    ------------------------------------------ \r\n    ---- THERMOSTAT SPECIFIC (HEATING)\r\n    ------------------------------------------\r\n    -- *** ADD SUPPORT FOR COOLING MODE IN THE FUTURE\r\n    if (haEntity.type == \"climate\") then\r\n        -- **** refactor\r\n        msg.modes = deviceNode.identifiedHaEntity.properties.supportedThermostatModes\r\n        --msg.modes = deviceNode.fibaroDevice.properties.supportedThermostatModes\r\n \r\n        msg.temperature_unit = deviceNode.fibaroDevice.properties.unit\r\n        msg.temp_step = deviceNode.fibaroDevice.properties.heatingThermostatSetpointStep[msg.temperature_unit]\r\n\r\n        -- MODE \r\n        msg.mode_state_topic = self:getterTopic(haEntity, \"thermostatMode\")\r\n        msg.mode_command_topic = self:setterTopic(haEntity, \"thermostatMode\")\r\n\r\n        -- *** \r\n        -- MIX/MAX TEMPERATURE\r\n        msg.min_temp = deviceNode.fibaroDevice.properties.heatingThermostatSetpointCapabilitiesMin\r\n        msg.max_temp = deviceNode.fibaroDevice.properties.heatingThermostatSetpointCapabilitiesMax\r\n\r\n        -- TARGET TEMPERATURE\r\n        msg.temperature_state_topic = self:getterTopic(haEntity, \"heatingThermostatSetpoint\")\r\n        msg.temperature_command_topic = self:setterTopic(haEntity, \"heatingThermostatSetpoint\")\r\n        \r\n        -- CURRENT TEMPERATURE\r\n        local temperatureSensorEntity = haEntity:getTemperatureSensor()\r\n        if temperatureSensorEntity then \r\n            msg.current_temperature_topic = self:getterTopic(temperatureSensorEntity, \"value\")\r\n        end\r\n    end\r\n\r\n    ------------------------------------------\r\n    ---- RGBW\r\n    ------------------------------------------\r\n    if (haEntity.type == \"light\" and haEntity.subtype == \"rgbw\") then\r\n        msg.rgbw_state_topic = self:getterTopic(haEntity, \"color\")\r\n        msg.rgbw_value_template = \"{{ value_json.value.split(',')[:4] | join(',') }}\"\r\n        msg.rgbw_command_topic = self:setterTopic(haEntity, \"color\")\r\n    end\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(haEntity) .. \"config\", json.encode(msg), {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(haEntity) .. \"config_json_attributes\", json.encode(deviceNode.fibaroDevice), {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onRemoteControllerKeyCreated(deviceNode, mqtt)\r\n    local haEntity = deviceNode.identifiedHaEntity\r\n    \r\n    local keyId = deviceNode.fibaroDevice.keyId\r\n    local keyType = self:convertKeyAttributeToType(deviceNode.fibaroDevice.keyAttribute)\r\n    \r\n    local msg = {\r\n        automation_type = \"trigger\",\r\n\r\n        topic = self:getterTopic(haEntity, \"value\"),\r\n        value_template = \"{{ value_json.value }}\", \r\n\r\n        type = keyType, \r\n        subtype = \"button_\" .. keyId,\r\n        payload = keyId .. \"-\" .. keyType\r\n    }\r\n\r\n    ------------------------------------------\r\n    --- PARENT DEVICE INFO\r\n    ------------------------------------------\r\n    msg.device = deviceNode.identifiedHaDevice\r\n\r\n    mqtt:publish(self:getDeviceTopic(haEntity) .. \"config\", json.encode(msg), {retain = true})\r\nend\r\n\r\nlocal keyAttributeToTypeMap = {\r\n    [\"pressed\"] = \"button_short_press\",\r\n    [\"pressed2\"] = \"button_double_press\",\r\n    [\"pressed3\"] = \"button_triple_press\",\r\n    [\"helddown\"] = \"button_long_press\",\r\n    [\"released\"] = \"button_long_release\"\r\n}\r\nfunction MqttConventionHomeAssistant:convertKeyAttributeToType(keyAttribute)\r\n    local type = keyAttributeToTypeMap[keyAttribute]\r\n    if not type then\r\n        print(\"Unknown key attribute \\\"\" .. tostring(keyAttribute) .. \"\\\"\")\r\n        type = \"unknown-\" .. keyAttribute\r\n    end\r\n\r\n    return type\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onDeviceNodeRemoved(deviceNode)\r\n    self.mqtt:publish(\r\n        self:getDeviceTopic(deviceNode.identifiedHaEntity) .. \"config\", \r\n        \"\",\r\n        {retain = true} \r\n    )\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onPropertyUpdated(deviceNode, event)\r\n    local haEntity = deviceNode.identifiedHaEntity\r\n\r\n    local propertyName = event.data.property\r\n\r\n    local value = event.data.newValue\r\n\r\n    -------------------------------------------\r\n    -- REMOTE CONTROLLER (SENSOR) SPECIFIC\r\n    -------------------------------------------\r\n    if haEntity.type == RemoteController.type and haEntity.subtype == RemoteController.subtype and propertyName == \"value\" then\r\n        local keyValues = splitString(value, \",\")\r\n\r\n        local keyId = keyValues[1]\r\n        local keyAttribute = keyValues[2]\r\n        local keyType = self:convertKeyAttributeToType(keyAttribute)\r\n        \r\n        value = keyId .. \"-\" .. keyType\r\n    end\r\n    \r\n    value = string.lower(value)\r\n\r\n    local payload = {\r\n        id = haEntity.id,\r\n        deviceName = haEntity.name,\r\n        created = event.created,\r\n        timestamp = os.date(),\r\n        roomName = haEntity.roomName,\r\n        value = value\r\n    }\r\n\r\n    local payloadString = json.encode(payload)\r\n\r\n    self.mqtt:publish(self:getterTopic(haEntity, propertyName), payloadString, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomeAssistant:onCommand(event)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        -- Home Assistant command detected\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[3])\r\n        local propertyName = topicElements[5]\r\n\r\n        local device = deviceNodeById[deviceId].identifiedHaEntity\r\n\r\n        local value = event.payload\r\n\r\n        if (device.type == \"climate\") then\r\n            -- Fibaro HC3 uses first letter in upper case, and HA relies on lower case\r\n            -- *** rename to firstCharacter\r\n            local firstPart = string.upper(string.sub(value, 1, 1))\r\n            local secondPart = string.sub(value, 2, string.len(value))\r\n            value = firstPart .. secondPart\r\n        end\r\n\r\n        device:setProperty(propertyName, value)\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- HOMIE\r\n-----------------------------------\r\nMqttConventionHomie = inheritFrom(MqttConventionPrototype) \r\nMqttConventionHomie.type = \"Homie\"\r\nMqttConventionHomie.rootTopic = \"homie/\"\r\n\r\n-- TOPICS \r\nfunction MqttConventionHomie:getDeviceTopic(device)\r\n    return self.rootTopic .. device.id .. \"/\"\r\nend\r\nfunction MqttConventionHomie:getGenericEventTopic(device, eventType, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType .. \"/\" .. propertyName \r\n    else\r\n        return self:getDeviceTopic(device) .. \"events/\" .. eventType\r\n    end\r\nend\r\nfunction MqttConventionHomie:getterTopic(device, propertyName)\r\n    return self:getGenericEventTopic(device, \"DevicePropertyUpdatedEvent\", propertyName)     \r\nend\r\nfunction MqttConventionHomie:getGenericCommandTopic(device, command, propertyName) \r\n    if (propertyName) then\r\n        return self:getDeviceTopic(device) .. command ..  \"/\" .. propertyName\r\n    else\r\n        return self:getDeviceTopic(device) .. command\r\n    end\r\nend\r\n\r\nfunction MqttConventionHomie:getSetterTopic(device, propertyName)\r\n    return self:getGenericCommandTopic(device, \"set\", propertyName)\r\nend\r\n\r\nfunction MqttConventionHomie:getLastWillMessage() \r\n    return {\r\n        topic = self.rootTopic .. \"hc3-dead\",\r\n        payload = \"true\",\r\n        lastWill = true\r\n    }    \r\nend\r\n\r\nfunction MqttConventionHomie:onConnected()\r\n    self.mqtt:subscribe(self.rootTopic .. \"+/+/+/set\")\r\nend\r\n\r\nfunction MqttConventionHomie:onDisconnected()\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceNodeCreated(deviceNode)\r\n    local device = deviceNode.identifiedHaEntity\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$homie\", \"2.1.0\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$name\", device.name .. \" (\" .. deviceNode.fibaroDevice.roomName .. \")\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$implementation\", \"Fibaro HC3 to MQTT bridge\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$nodes\", \"node\", {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$name\", device.name, {retain = true})\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$type\", \"\", {retain = true})\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$extensions\", \"\", {retain = true})\r\n\r\n    local properties = { }\r\n\r\n    if (device.supportsRead) then\r\n        local propertyName = device.type\r\n        -- *** get rid of this check\r\n        --if (PrototypeEntity.subtype ~= device.subtype) then\r\n            propertyName = propertyName .. \" - \" .. tostring(device.subtype)\r\n        --end\r\n\r\n        if (device.supportsBinary) then\r\n            properties[\"state\"] = {\r\n                name = device.type,\r\n                datatype = \"boolean\",\r\n                settable = device.supportsWrite, \r\n                retained = true,\r\n            }\r\n        end\r\n\r\n        if (device.supportsMultilevel) then\r\n            properties[\"value\"] = {\r\n                name = device.type,\r\n                datatype = \"integer\",\r\n                settable = device.supportsWrite,\r\n                retained = true,\r\n                unit = device.bridgeUnitOfMeasurement\r\n            }\r\n        end\r\n    end\r\n\r\n    local propertiesStr = \"\"\r\n    local firstParameter = true\r\n    for i, j in pairs(properties) do\r\n        if (not firstParameter) then\r\n            propertiesStr = propertiesStr .. \",\"\r\n        end\r\n        propertiesStr = propertiesStr .. i\r\n        firstParameter = false\r\n    end\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/$properties\", propertiesStr, {retain = true})\r\n\r\n    for i, j in pairs(properties) do\r\n        local propertyTopic = self:getDeviceTopic(device) .. \"node/\" .. i .. \"/$\"\r\n        for m, n in pairs(j) do\r\n            self.mqtt:publish(propertyTopic .. m, tostring(n), {retain = true})\r\n        end\r\n    end\r\n\r\n    local homieState\r\n    if (deviceNode.fibaroDevice.dead) then\r\n        homieState = \"lost\"\r\n    else\r\n        homieState = \"ready\"\r\n    end\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"$state\", homieState, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onDeviceNodeRemoved(deviceNode)\r\nend\r\n\r\nfunction MqttConventionHomie:onPropertyUpdated(deviceNode, event)\r\n    local propertyName = event.data.property\r\n\r\n    local value = event.data.newValue\r\n\r\n    -- *** rename device to haEntity\r\n    local device = deviceNode.identifiedHaEntity\r\n\r\n    value = string.lower(value)\r\n\r\n    self.mqtt:publish(self:getDeviceTopic(device) .. \"node/\" .. propertyName, value, {retain = true})\r\nend\r\n\r\nfunction MqttConventionHomie:onCommand(event)\r\n    if (string.find(event.topic, self.rootTopic) == 1) then\r\n        local topicElements = splitString(event.topic, \"/\")\r\n        local deviceId = tonumber(topicElements[2])\r\n        local device = deviceNodeById[deviceId].identifiedHaEntity\r\n\r\n        local propertyName = topicElements[4]\r\n        local value = event.payload\r\n\r\n        device:setProperty(propertyName, value)\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- RESERVED FOR EXTENDED DEBUG PURPOSES\r\n-----------------------------------\r\n\r\nMqttConventionDebug = inheritFrom(MqttConventionPrototype) \r\nMqttConventionDebug.type = \"Debug\"\r\nfunction MqttConventionDebug:getLastWillMessage() \r\nend\r\nfunction MqttConventionDebug:onDeviceNodeCreated(deviceNode)\r\nend\r\nfunction MqttConventionDebug:onDeviceNodeRemoved(deviceNode)\r\nend\r\nfunction MqttConventionDebug:onPropertyUpdated(deviceNode, event)\r\nend\r\nfunction MqttConventionDebug:onConnected()\r\nend\r\nfunction MqttConventionDebug:onCommand(event)\r\nend\r\nfunction MqttConventionDebug:onDisconnected()\r\nend\r\n\r\n-----------------------------------\r\n-- MQTT CONVENTION MAPPINGS\r\n-----------------------------------\r\n\r\nmqttConventionMappings = {\r\n    [\"home-assistant\"] = MqttConventionHomeAssistant,\r\n    [\"homie\"] = MqttConventionHomie,\r\n    [\"debug\"] = MqttConventionDebug\r\n} \r\n\r\n\r\nlocalIpAddress = identifyLocalIpAddressForHc3()\r\n"},{"name":"device_api","isMain":false,"isOpen":true,"content":"----------------------------------- \r\n-- PROTOTYPE OBJECT \r\n-----------------------------------\r\nPrototypeEntity = {\r\n    -- mandatory\r\n    type = \"'type' needs to be initialized\",\r\n    supportsBinary = \"'supportsBinary' needs to be initialized\",\r\n    binaryProperty = \"value\",\r\n    supportsMultilevel = \"'supportsMultilevel' needs to be initialized\",\r\n    supportsRead = \"'supportsRead' needs to be initialized\",\r\n    supportsWrite = \"'supportsWrite' needs to be initialized\",\r\n\r\n    -- optional\r\n    subtype = \"default\",\r\n    modes = \"'modes' needs to be initialized to an array of modes, e.g. 'heat', 'cool'\",\r\n    icon = \"&#128230;\", -- 📦\r\n    properties = { },\r\n    customPropertySetters = nil -- could be optionally set by a child class\r\n} \r\n\r\nfunction PrototypeEntity.isSupported(fibaroDevice)\r\n    print(\"'isSupported' function is mandatory for implementation\")\r\nend\r\n\r\n-- *** MERGE \"INIT\" WITH \"NEW\"?\r\nfunction PrototypeEntity:new(deviceNode)\r\n    local status, haEntity = pcall(clone, self)\r\n\r\n    local fibaroDevice = deviceNode.fibaroDevice\r\n    haEntity.sourceDeviceNode = deviceNode\r\n\r\n    haEntity.id = fibaroDevice.id\r\n    haEntity.name = fibaroDevice.name\r\n    haEntity.roomName = fibaroDevice.roomName\r\n\r\n    local linkedFibaroDevice = fibaroDevice.linkedDevice\r\n    if linkedFibaroDevice then\r\n        haEntity.linkedEntity = deviceNodeById[linkedFibaroDevice.id].identifiedHaEntity\r\n        haEntity.linkedProperty = fibaroDevice.linkedProperty\r\n    end\r\n\r\n    haEntity:init(fibaroDevice)\r\n\r\n    return haEntity\r\nend\r\n\r\nfunction PrototypeEntity:init(fibaroDevice)\r\n    -- \"init\" function could be optionally overriden by subclasses implementation\r\nend \r\n\r\nfunction PrototypeEntity:setProperty(propertyName, value)\r\n    if isEmptyString(value) then\r\n        return\r\n    end\r\n\r\n    local customPropertySetter\r\n    if (self.customPropertySetters ~= nil) then\r\n        customPropertySetter = self.customPropertySetters[propertyName]\r\n    end\r\n\r\n    if (customPropertySetter == nil) then\r\n        -- DEFAULT PROPERTY SETTER\r\n        if (propertyName == \"state\") then\r\n            if (value == \"true\") then\r\n                --print(\"Turn ON for device #\" .. self.id)\r\n                fibaro.call(self.id, \"turnOn\")\r\n            elseif (value == \"false\") then\r\n                --print(\"Turn OFF for device #\" .. self.id)\r\n                fibaro.call(self.id, \"turnOff\")\r\n            else\r\n                print(\"Unexpected value: \" .. json.encode(event))\r\n            end\r\n        else\r\n            -- *** rename to firstCharacter\r\n            local firstPart = string.upper(string.sub(propertyName, 1, 1))\r\n            local secondPart = string.sub(propertyName, 2, string.len(propertyName))\r\n\r\n            local functionName = \"set\" .. firstPart .. secondPart\r\n            print(\"FUNCTION CALL: \\\"\" .. functionName .. \"\\\", with VALUE \\\"\" .. value .. \"\\\" for device #\" .. self.id)\r\n\r\n            if (propertyName == \"color\") then\r\n                local newRgbw = splitStringToNumbers(value, \",\")\r\n                fibaro.call(self.id, functionName, newRgbw[1], newRgbw[2], newRgbw[3], newRgbw[4])\r\n            else\r\n                fibaro.call(self.id, functionName, value)\r\n            end\r\n        end\r\n    else\r\n        -- CUSTOM PROPERTY SETTER\r\n        print(\"[CUSTOM PROPERTY] SET \\\"\" .. propertyName .. \"\\\" to \\\"\" .. value .. \"\\\" for device #\" .. self.id)\r\n        customPropertySetter(propertyName, value)\r\n    end\r\nend\r\n\r\nfunction PrototypeEntity:fibaroDeviceTypeContains(type)\r\n    return fibaroDeviceTypeContains(self.sourceDeviceNode.fibaroDevice, type)\r\nend\r\nfunction PrototypeEntity:fibaroDeviceTypeMatchesWith(type)\r\n    return fibaroDeviceTypeMatchesWith(self.sourceDeviceNode.fibaroDevice, type)\r\nend\r\nfunction PrototypeEntity:fibaroDeviceHasInterface(interface)\r\n    return table_contains_value(self.sourceDeviceNode.fibaroDevice, interface)\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY SWITCH\r\n-----------------------------------\r\nSwitch = inheritFrom(PrototypeEntity)\r\nSwitch.type = \"switch\"\r\nSwitch.subtype = \"binary\"\r\nSwitch.supportsBinary = true\r\nSwitch.supportsMultilevel = false\r\nSwitch.supportsRead = true\r\nSwitch.supportsWrite = true\r\nSwitch.icon = \"&#128268;\" -- 🔌\r\n\r\nfunction Switch.isSupported(fibaroDevice)\r\n    if fibaroDeviceTypeMatchesWith(fibaroDevice, \"com.fibaro.binarySwitch\") and (not fibaroDeviceHasInterface(fibaroDevice, \"light\")) then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- BINARY LIGHT\r\n-----------------------------------\r\nLight = inheritFrom(PrototypeEntity)\r\nLight.type = \"light\"\r\nLight.subtype = \"binary\"\r\nLight.supportsBinary = true\r\nLight.supportsMultilevel = false\r\nLight.supportsRead = true\r\nLight.supportsWrite = true\r\nLight.icon = \"&#128161;\" -- 💡\r\n\r\nfunction Light.isSupported(fibaroDevice)\r\n    if fibaroDeviceTypeMatchesWith(fibaroDevice, \"com.fibaro.binarySwitch\") and fibaroDeviceHasInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL LIGHT (DIMMERS)\r\n-----------------------------------\r\nDimmer = inheritFrom(PrototypeEntity)\r\nDimmer.type = \"light\"\r\nDimmer.subtype = \"dimmer\"\r\nDimmer.supportsBinary = true\r\nDimmer.supportsMultilevel = true\r\nDimmer.supportsRead = true\r\nDimmer.supportsWrite = true\r\nDimmer.icon = \"&#128161;\"\r\n\r\nfunction Dimmer.isSupported(fibaroDevice)\r\n    if fibaroDeviceTypeMatchesWith(fibaroDevice, \"com.fibaro.multilevelSwitch\") and fibaroDeviceHasInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL LIGHT (RGBW)\r\n-----------------------------------\r\nRgbw = inheritFrom(PrototypeEntity)\r\nRgbw.type = \"light\"\r\nRgbw.subtype = \"rgbw\" \r\nRgbw.supportsBinary = true\r\nRgbw.supportsMultilevel = true\r\nRgbw.supportsRead = true\r\nRgbw.supportsWrite = true\r\nRgbw.icon = \"&#127752;\" -- 🌈\r\n\r\nfunction Rgbw.isSupported(fibaroDevice)\r\n    if fibaroDeviceTypeMatchesWith(fibaroDevice, \"com.fibaro.colorController\") and fibaroDeviceHasInterface(fibaroDevice, \"light\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- GENERIC SENSOR\r\n-----------------------------------\r\nGenericSensor = inheritFrom(PrototypeEntity)\r\nGenericSensor.supportsRead = true \r\nGenericSensor.supportsWrite = false\r\nGenericSensor.icon = \"&#128065;&#65039;\" -- 👁️\r\n\r\nfunction GenericSensor.isGenericSensor(fibaroDevice)\r\n    if fibaroDeviceTypeContains(fibaroDevice, \"Sensor\") or fibaroDeviceTypeContains(fibaroDevice, \"sensor\") or fibaroDeviceTypeContains(fibaroDevice, \"Detector\") or fibaroDeviceTypeContains(fibaroDevice, \"detector\") or fibaroDeviceTypeContains(fibaroDevice, \"Meter\") or fibaroDeviceTypeContains(fibaroDevice, \"meter\") then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\n\r\n-----------------------------------\r\n-- BINARY SENSOR (DOOR, MOTION, WATER LEAK, FIRE, SMORE SENSORSMULTILEVEL FOR TEMPERATURE, ETC)\r\n-----------------------------------\r\nBinarySensor = inheritFrom(GenericSensor)\r\nBinarySensor.type = \"binary_sensor\"\r\nBinarySensor.supportsBinary = true\r\nBinarySensor.supportsMultilevel = false\r\n\r\nfunction BinarySensor.isSupported(fibaroDevice)\r\n    if GenericSensor.isGenericSensor(fibaroDevice) and (not fibaroDevice.properties.unit) then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\nfunction BinarySensor:init(fibaroDevice)\r\n    -- ToDo *** refactor with mappings for a bit higher performance?\r\n    if self:fibaroDeviceTypeMatchesWith(\"com.fibaro.motionSensor\") then\r\n        self.subtype = \"motion\"\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.floodSensor\") then\r\n        self.subtype = \"moisture\" \r\n        self.icon = \"&#128166;\" -- 💦\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.doorWindowSensor\") then\r\n        if self:fibaroDeviceTypeMatchesWith(\"com.fibaro.doorSensor\") then\r\n            self.subtype = \"door\"\r\n            self.icon = \"&#128682;\" -- 🚪\r\n        elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.windowSensor\") then\r\n            self.subtype = \"window\"\r\n            self.icon = \"&#129003;\" -- 🟫\r\n        else\r\n            print(\"[BinarySensor.init] Uknown doow/window sensor \" .. self.id .. \" \" .. self.name)\r\n        end\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.fireDetector\") or self:fibaroDeviceTypeMatchesWith(\"com.fibaro.fireSensor\") then\r\n        self.subtype = \"heat\"\r\n        self.icon = \"&#128293;\" -- 🔥\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.coDetector\") then\r\n        self.subtype = \"carbon_monoxide\"\r\n        self.icon = \"&#128168;\" -- 💨\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.smokeSensor\") then\r\n        self.subtype = \"smoke\"\r\n        self.icon = \"&#128684;\" -- 🚬\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.gasDetector\") then\r\n        self.subtype = \"gas\" \r\n        self.icon = \"&#128168;\" -- 💨\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.lifeDangerSensor\") then\r\n        self.subtype = \"safety\"\r\n    else\r\n        -- use generic sensor \r\n\r\n        -- DEBUG: print(\"[BinarySensor.init] No sensor specialization for #\" .. tostring(self.id) .. \" \\\"\" .. tostring(self.name) .. \"\\\" that has type \" .. fibaroDevice.baseType .. \"-\" .. fibaroDevice.type .. \", thus using default sensor class\")\r\n    end\r\nend\r\n\r\n----------------------------------------------------------\r\n-- MULTILEVEL SENSOR (TEMPERATURE, HUMIDITY, VOLTAGE, ETC) \r\n----------------------------------------------------------\r\nMultilevelSensor = inheritFrom(GenericSensor)\r\nMultilevelSensor.type = \"sensor\"\r\nMultilevelSensor.supportsBinary = false\r\nMultilevelSensor.supportsMultilevel = true\r\nMultilevelSensor.bridgeUnitOfMeasurement = \"'unit of measurement' needs to be initialized\"\r\n\r\nfunction MultilevelSensor.isSupported(fibaroDevice)\r\n    if GenericSensor.isGenericSensor(fibaroDevice) and fibaroDevice.properties.unit then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\nfunction MultilevelSensor:init(fibaroDevice)\r\n    self.bridgeUnitOfMeasurement = fibaroDevice.properties.unit\r\n\r\n    -- identify subtype \r\n    -- ToDo *** refactor with mappings for a bit higher performance?\r\n    if self:fibaroDeviceTypeMatchesWith(\"com.fibaro.temperatureSensor\") then\r\n        self.subtype = \"temperature\"\r\n        self.bridgeUnitOfMeasurement = \"°\" .. fibaroDevice.properties.unit\r\n        self.icon = \"&#127777;&#65039;\" -- 🌡️\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.lightSensor\") then\r\n        self.subtype = \"illuminance\"\r\n        self.icon = \"&#9728;&#65039;\" -- ☀️\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.humiditySensor\") then \r\n        self.subtype = \"humidity\"\r\n        self.icon = \"&#128167;\" -- 💧\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.batteryLevelSensor\") then \r\n        self.subtype = \"battery\"\r\n        self.icon = \"&#128267;\" -- 🔋\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.energySensor\") or self:fibaroDeviceTypeMatchesWith(\"com.fibaro.energyMeter\") or self:fibaroDeviceTypeMatchesWith(\"com.fibaro.electricMeter\") then \r\n        self.subtype = \"energy\"\r\n        self.icon = \"&#9889;\" -- ⚡\r\n    elseif self:fibaroDeviceTypeMatchesWith(\"com.fibaro.powerMeter\") then \r\n        self.subtype = \"power\"\r\n        self.icon = \"&#9889;\" -- ⚡\r\n    elseif (fibaroDevice.properties.unit == \"V\") then\r\n        self.subtype = \"voltage\"\r\n        self.icon = \"&#9889;\" -- ⚡\r\n    elseif (fibaroDevice.properties.unit == \"A\") then\r\n        self.subtype = \"current\"\r\n        self.icon = \"&#9889;\" -- ⚡\r\n    elseif (fibaroDevice.properties.unit == \"W\" or fibaroDevice.properties.unit == \"kW\" or fibaroDevice.properties.unit == \"kVA\") then\r\n        self.subtype = \"power\"\r\n        self.icon = \"&#9889;\" -- ⚡\r\n    elseif (fibaroDevice.properties.unit == \"Hz\") then\r\n        self.subtype = \"frequency\"\r\n        self.icon = \"&#8767;\" -- ∿\r\n    else\r\n        -- use generic sensor \r\n\r\n        -- DEBUG: print(\"[MultilevelSensor.init] No sensor specialization for #\" .. tostring(self.id) .. \" \\\"\" .. tostring(self.name) .. \"\\\" that has type \" .. fibaroDevice.baseType .. \"-\" .. fibaroDevice.type .. \" and measured in '\" .. tostring(fibaroDevice.properties.unit) .. \"' unit, thus using default sensor class\")\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- MULTILEVEL SWITCH (COVER)\r\n-----------------------------------\r\nCover = inheritFrom(PrototypeEntity)\r\nCover.type = \"cover\"\r\nCover.supportsBinary = true\r\nCover.supportsMultilevel = true\r\nCover.supportsRead = true\r\nCover.supportsWrite = true\r\n\r\nfunction Cover.isSupported(fibaroDevice)\r\n    if fibaroDeviceTypeMatchesWith(fibaroDevice, \"com.fibaro.baseShutter\") or fibaroDeviceTypeMatchesWith(fibaroDevice, \"com.fibaro.remoteBaseShutter\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction Cover:init(fibaroDevice) \r\n    self.customPropertySetters = { }\r\n    self.customPropertySetters[\"state\"] = function (propertyName, value) \r\n        if (value == \"open\") then\r\n            fibaro.call(self.id, \"setValue\", 100)\r\n        elseif (value == \"close\") then\r\n            fibaro.call(self.id, \"setValue\", 0)\r\n        elseif (value == \"stop\") then\r\n            fibaro.call(self.id, \"stop\")\r\n        else\r\n            print(\"Unsupported command\")\r\n        end\r\n    end\r\nend\r\n\r\n-----------------------------------\r\n-- THERMOSTAT (MULTILEVEL SWITCH)\r\n-----------------------------------\r\nThermostat = inheritFrom(PrototypeEntity)\r\nThermostat.type = \"climate\"\r\nThermostat.supportsBinary = false\r\nThermostat.supportsMultilevel = true\r\nThermostat.supportsRead = true\r\nThermostat.supportsWrite = true \r\nThermostat.icon = \"&#127965;&#65039;\" -- 🏝️\r\n\r\nfunction Thermostat.isSupported(fibaroDevice)\r\n    if fibaroDevice.baseType == \"com.fibaro.hvacSystem\" or fibaroDevice.type == \"com.fibaro.hvacSystem\" then \r\n        return true \r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction Thermostat:init(fibaroDevice) \r\n    local fibaroDeviceProperties = self.sourceDeviceNode.fibaroDevice.properties\r\n    \r\n    self.properties.supportedThermostatModes = { }\r\n    for i, mode in ipairs(fibaroDeviceProperties.supportedThermostatModes) do\r\n        self.properties.supportedThermostatModes[i] = string.lower(mode)\r\n    end\r\nend\r\n\r\nfunction Thermostat:setMode(mode)\r\n    fibaro.call(self.id, \"setThermostatMode\", mode)\r\nend\r\n\r\nfunction Thermostat:setHeatingThermostatSetpoint(targetTemperature)\r\n    fibaro.call(self.id, \"setHeatingThermostatSetpoint\", targetTemperature)\r\nend\r\n\r\nfunction Thermostat:getTemperatureSensor()\r\n    local sourceDeviceNode = self.sourceDeviceNode\r\n    local parentNode = sourceDeviceNode.parentNode\r\n\r\n    local relatedNodeList = {}\r\n    if (parentNode) then\r\n        shallowInsertTo(parentNode.childNodeList, relatedNodeList)    \r\n    end\r\n    shallowInsertTo(sourceDeviceNode.childNodeList, relatedNodeList)\r\n\r\n    for _, siblingNode in ipairs(relatedNodeList) do\r\n        if (siblingNode.included and siblingNode.identifiedHaEntity and siblingNode.identifiedHaEntity.type == \"sensor\" and siblingNode.identifiedHaEntity.subtype == \"temperature\") then\r\n            return siblingNode.identifiedHaEntity\r\n        end\r\n    end\r\n\r\n    return nil\r\nend\r\n\r\n-----------------------------------\r\n-- REMOTE CONTROLLER\r\n-----------------------------------\r\nRemoteController = inheritFrom(MultilevelSensor)\r\nRemoteController.subtype = \"remoteController\"\r\n\r\nfunction RemoteController.isSupported(fibaroDevice)\r\n    if ((fibaroDevice.baseType == \"com.fibaro.remoteController\") or ( fibaroDevice.baseType == \"com.fibaro.remoteSceneController\") or ( fibaroDevice.type == \"com.fibaro.remoteController\") or (fibaroDevice.type == \"com.fibaro.remoteSceneController\"))      then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\n------------------------------------\r\n-- REMOTE CONTROLLER - BUTTON ACTION\r\n------------------------------------\r\nRemoteControllerKey = inheritFrom(PrototypeEntity)\r\nRemoteControllerKey.type = \"device_automation\"\r\nRemoteControllerKey.subtype = \"trigger\"\r\nRemoteControllerKey.supportsBinary = true\r\nRemoteControllerKey.supportsMultilevel = false\r\nRemoteControllerKey.supportsRead = true\r\nRemoteControllerKey.supportsWrite = false\r\nRemoteControllerKey.icon = \"&#9654;&#65039;\" -- ▶️\r\n--RemoteControllerKey.icon = \"&#128377;&#65039;\" -- 🕹️\r\n\r\nfunction RemoteControllerKey.isSupported(fibaroDevice)\r\n    if (fibaroDevice.baseType == \"com.alexander_vitishchenko.remoteKey\") then\r\n        return true\r\n    else \r\n        return false\r\n    end\r\nend\r\n\r\nfunction RemoteControllerKey.init(fibaroDevice)\r\n    -- not needed for now\r\nend\r\n\r\n----------------------------------- \r\n-- SUPPORTED DEVICE MAPPINGS\r\n-----------------------------------\r\nhaEntityTypeMappings = {\r\n    -- Switches\r\n    Switch, -- binary\r\n    Cover, -- multilevel\r\n\r\n    -- Lights\r\n    Dimmer, -- multilevel light; Dimmer detection has a priority over binary light\r\n    Light, -- binary\r\n    Rgbw, -- multichannel\r\n\r\n    -- Sensors\r\n    BinarySensor,\r\n    MultilevelSensor,\r\n   \r\n    Thermostat,\r\n\r\n    RemoteController,\r\n    RemoteControllerKey\r\n}  "},{"name":"device_helper","isMain":false,"isOpen":true,"content":"----------------------------------- \r\n-- CACHE FOR QUICKAPP PERFORMANCE BOOST \r\n-----------------------------------\r\ndeviceHierarchyRootNode = nil\r\ndeviceNodeById = { }\r\ndeviceFilter = { }\r\n\r\nallFibaroDevicesAmount = 0\r\nfilteredFibaroDevicesAmount = 0\r\nidentifiedHaEntitiesAmount = 0\r\n\r\n__allFibaroDevices = nil\r\n__filteredFibaroDeviceIds = nil\r\n\r\n-----------------------------------\r\n--  FIBARO DEVICE TYPE CUSTOM MAPPINGS \r\n-----------------------------------\r\nlocal fibaroBaseTypeOverride = {\r\n    [\"com.fibaro.FGR\"] = \"com.fibaro.baseShutter\",\r\n    [\"com.fibaro.FGMS001\"] = \"com.fibaro.motionSensor\",\r\n    [\"com.fibaro.FGWP\"] = \"com.fibaro.binarySwitch\"\r\n}\r\n\r\nlocal fibaroTypeOverride = { \r\n    [\"com.fibaro.FGKF601\"] = \"com.fibaro.keyFob\",\r\n    [\"com.fibaro.FGD212\"] = \"com.fibaro.dimmer\",\r\n    [\"com.fibaro.FGMS001v2\"] = \"com.fibaro.motionSensor\",\r\n    [\"com.fibaro.FGFS101\"] = \"com.fibaro.floodSensor\",\r\n    [\"com.fibaro.FGWP102\"] = \"com.fibaro.binarySwitch\"\r\n}\r\n\r\nfunction cleanDeviceCache()\r\n    deviceHierarchyRootNode = nil\r\n    deviceNodeById = { }\r\n\r\n    allFibaroDevicesAmount = 0\r\n    filteredFibaroDevicesAmount = 0\r\n    identifiedHaEntitiesAmount = 0\r\nend\r\n\r\nfunction getDeviceHierarchyByFilter(customDeviceFilterJsonStr)\r\n    cleanDeviceCache()\r\n\r\n    deviceFilter = \r\n        {\r\n            filters = {\r\n                {\r\n                    filter = \"enabled\",\r\n                    value = { true }\r\n                },\r\n                {\r\n                    filter = \"visible\",\r\n                    value = { true }\r\n                }\r\n            }, \r\n            attributes = {\r\n                -- define the list of Fibaro device attributes we are interested in\r\n                main = {\r\n                    \"id\"\r\n                }\r\n            }\r\n        }\r\n\r\n    if (not isEmptyString(customDeviceFilterJsonStr)) then\r\n        print(\"\")\r\n        print(\"(!) Apply custom device filter: \" .. tostring(customDeviceFilterJsonStr))\r\n        print(\"--> Supported JSON format: \" .. \"{\\\"filter\\\":\\\"baseType\\\", \\\"value\\\":[\\\"com.fibaro.actor\\\"]},   {\\\"filter\\\":\\\"deviceID\\\", \\\"value\\\":[41,42]},   { MORE FILTERS MAY GO HERE }\")\r\n        print(\"--> See the list of Fibaro API filter types at https://manuals.fibaro.com/content/other/FIBARO_System_Lua_API.pdf => \\\"fibaro:getDevicesId(filters)\\\"\")\r\n        print(\"\")\r\n\r\n        local customDeviceFilterJson = json.decode(\"{ filters: [ \" .. customDeviceFilterJsonStr .. \"] }\") \r\n\r\n        shallowInsertTo(customDeviceFilterJson.filters, deviceFilter.filters)\r\n    else\r\n        print(\"Default device filter is used: \" .. json.encode(deviceFilter))\r\n    end\r\n\r\n\r\n    __allFibaroDevices = api.get(\"/devices\")\r\n    allFibaroDevicesAmount = #__allFibaroDevices\r\n\r\n    __filteredFibaroDeviceIds = api.post( \r\n        \"/devices/filter\", \r\n        deviceFilter\r\n    )\r\n    filteredFibaroDevicesAmount = #__filteredFibaroDeviceIds\r\n\r\n    ----------- SIMULATED ZIGBEE RGBW DEVICE\r\n    --addSimulatedDevice(\"{\\n  \\\"id\\\": 35,\\n  \\\"name\\\": \\\"Levá\\\",\\n  \\\"roomID\\\": 223,\\n  \\\"view\\\": [\\n    {\\n      \\\"assetsPath\\\": \\\"dynamic-plugins/com.fibaro.baseShutter\\\",\\n      \\\"name\\\": \\\"com.fibaro.baseShutter\\\",\\n      \\\"translatesPath\\\": \\\"/assets/i18n/com.fibaro.baseShutter\\\",\\n      \\\"type\\\": \\\"ts\\\"\\n    },\\n    {\\n      \\\"assetsPath\\\": \\\"\\\",\\n      \\\"name\\\": \\\"base-slats\\\",\\n      \\\"translatesPath\\\": \\\"/assets/i18n/base-slats\\\",\\n      \\\"type\\\": \\\"ts\\\"\\n    },\\n    {\\n      \\\"assetsPath\\\": \\\"dynamic-plugins/favorite-positions\\\",\\n      \\\"name\\\": \\\"favorite-positions\\\",\\n      \\\"translatesPath\\\": \\\"/assets/i18n/favorite-positions\\\",\\n      \\\"type\\\": \\\"ts\\\"\\n    }\\n  ],\\n  \\\"type\\\": \\\"com.fibaro.baseShutter\\\",\\n  \\\"baseType\\\": \\\"com.fibaro.actor\\\",\\n  \\\"enabled\\\": true,\\n  \\\"visible\\\": true,\\n  \\\"isPlugin\\\": false,\\n  \\\"parentId\\\": 34,\\n  \\\"viewXml\\\": false,\\n  \\\"hasUIView\\\": true,\\n  \\\"configXml\\\": false,\\n  \\\"interfaces\\\": [\\n    \\\"baseSlats\\\",\\n    \\\"elero\\\",\\n    \\\"eleroBidi\\\",\\n    \\\"favoritePosition\\\",\\n    \\\"notification\\\"\\n  ],\\n  \\\"properties\\\": {\\n    \\\"categories\\\": [\\n      \\\"blinds\\\"\\n    ],\\n    \\\"configuration\\\": true,\\n    \\\"dead\\\": false,\\n    \\\"deadReason\\\": \\\"\\\",\\n    \\\"deviceControlType\\\": 55,\\n    \\\"deviceIcon\\\": 237,\\n    \\\"deviceRole\\\": \\\"VenetianBlinds\\\",\\n    \\\"deviceState\\\": \\\"Configured\\\",\\n    \\\"favoritePositions\\\": [\\n      {\\n        \\\"label\\\": \\\"stínění\\\",\\n        \\\"name\\\": \\\"FavoritePosition1\\\",\\n        \\\"value\\\": 50\\n      },\\n      {\\n        \\\"label\\\": \\\"naklopení\\\",\\n        \\\"name\\\": \\\"FavoritePosition2\\\",\\n        \\\"value\\\": 50\\n      }\\n    ],\\n    \\\"favoritePositionsNativeSupport\\\": true,\\n    \\\"icon\\\": {\\n      \\\"path\\\": \\\"/assets/icon/fibaro/shutter_dark/shutter_darkClosed.png\\\",\\n      \\\"source\\\": \\\"HC\\\"\\n    },\\n    \\\"log\\\": \\\"\\\",\\n    \\\"logTemp\\\": \\\"\\\",\\n    \\\"macAddress\\\": 7256875,\\n    \\\"manufacturer\\\": \\\"ELERO\\\",\\n    \\\"markAsDead\\\": true,\\n    \\\"model\\\": \\\"JA Comfort 868\\\",\\n    \\\"niceId\\\": 8,\\n    \\\"niceProtocol\\\": \\\"EleroBidiPln2\\\",\\n    \\\"saveLogs\\\": true,\\n    \\\"state\\\": \\\"Closed\\\",\\n    \\\"supportedDeviceRoles\\\": [\\n      \\\"VenetianBlinds\\\"\\n    ],\\n    \\\"supportedNotifications\\\": {\\n      \\\"1\\\": {\\n        \\\"eventValues\\\": {\\n          \\\"1\\\": {\\n            \\\"key\\\": \\\"ETX_ALERT_OVERTEMPERATURE\\\",\\n            \\\"saveToPanel\\\": true\\n          },\\n          \\\"2\\\": {\\n            \\\"key\\\": \\\"ETX_ALERT_BLOCKED\\\",\\n            \\\"saveToPanel\\\": true\\n          }\\n        },\\n        \\\"key\\\": \\\"ETX_ALERT\\\"\\n      }\\n    },\\n    \\\"userDescription\\\": \\\"\\\"\\n  },\\n  \\\"actions\\\": {\\n    \\\"close\\\": 0,\\n    \\\"open\\\": 0,\\n    \\\"rotateSlatsDown\\\": 0,\\n    \\\"rotateSlatsUp\\\": 0,\\n    \\\"setFavoritePosition\\\": 1,\\n    \\\"stop\\\": 0,\\n    \\\"stopSlats\\\": 0\\n  },\\n  \\\"created\\\": 1665691054,\\n  \\\"modified\\\": 1677785015,\\n  \\\"sortOrder\\\": 21\\n}\")\r\n\r\n    --addSimulatedDevice(\"{\\n  \\\"id\\\": 237,\\n  \\\"name\\\": \\\"237\\\",\\n  \\\"roomID\\\": 219,\\n  \\\"view\\\": [],\\n  \\\"type\\\": \\\"com.fibaro.zigbeeDevice\\\",\\n  \\\"baseType\\\": \\\"com.fibaro.device\\\",\\n  \\\"enabled\\\": true,\\n  \\\"visible\\\": false,\\n  \\\"isPlugin\\\": false,\\n  \\\"parentId\\\": 8,\\n  \\\"viewXml\\\": false,\\n  \\\"hasUIView\\\": false,\\n  \\\"configXml\\\": false,\\n  \\\"interfaces\\\": [\\n    \\\"zigbee\\\"\\n  ],\\n  \\\"properties\\\": {\\n    \\\"categories\\\": [\\n      \\\"other\\\"\\n    ],\\n    \\\"configured\\\": true,\\n    \\\"dead\\\": true,\\n    \\\"deadReason\\\": \\\"\\\",\\n    \\\"deviceControlType\\\": 1,\\n    \\\"deviceIcon\\\": 28,\\n    \\\"deviceRole\\\": \\\"Other\\\",\\n    \\\"deviceState\\\": \\\"Configured\\\",\\n    \\\"icon\\\": {},\\n    \\\"ieeeAddress\\\": \\\"0x84FD27EEEEEEE05E\\\",\\n    \\\"log\\\": \\\"\\\",\\n    \\\"logTemp\\\": \\\"\\\",\\n    \\\"manufacturer\\\": \\\"Ajax Online\\\",\\n    \\\"model\\\": \\\"AJ_ZB_GU10\\\",\\n    \\\"networkAddress\\\": 12761,\\n    \\\"saveLogs\\\": true,\\n    \\\"supportedDeviceRoles\\\": [\\n      \\\"Other\\\"\\n    ],\\n    \\\"userDescription\\\": \\\"\\\",\\n    \\\"zigbeeDeviceIds\\\": \\\"13,97\\\"\\n  },\\n  \\\"actions\\\": {},\\n  \\\"created\\\": 1656669191,\\n  \\\"modified\\\": 1673281514,\\n  \\\"sortOrder\\\": 110\\n}\")\r\n    --addSimulatedDevice(\"{\\n  \\\"id\\\": 238,\\n  \\\"name\\\": \\\"Nightlight RGB\\\",\\n  \\\"roomID\\\": 230,\\n  \\\"view\\\": [\\n    {\\n      \\\"assetsPath\\\": \\\"\\\",\\n      \\\"name\\\": \\\"com.fibaro.colorController\\\",\\n      \\\"translatesPath\\\": \\\"/assets/i18n/com.fibaro.colorController\\\",\\n      \\\"type\\\": \\\"ts\\\"\\n    }\\n  ],\\n  \\\"type\\\": \\\"com.fibaro.FGRGBW442CC\\\",\\n  \\\"baseType\\\": \\\"com.fibaro.colorController\\\",\\n  \\\"enabled\\\": true,\\n  \\\"visible\\\": true,\\n  \\\"isPlugin\\\": false,\\n  \\\"parentId\\\": 237,\\n  \\\"viewXml\\\": false,\\n  \\\"hasUIView\\\": false,\\n  \\\"configXml\\\": false,\\n  \\\"interfaces\\\": [\\n    \\\"light\\\",\\n    \\\"zigbee\\\"\\n  ],\\n  \\\"properties\\\": {\\n    \\\"categories\\\": [\\n      \\\"lights\\\"\\n    ],\\n    \\\"color\\\": \\\"208.0336600431721,0,254.99999999999997,0\\\",\\n    \\\"colorComponents\\\": {},\\n    \\\"configured\\\": true,\\n    \\\"currentProgram\\\": 0,\\n    \\\"currentProgramID\\\": 0,\\n    \\\"dead\\\": false,\\n    \\\"deadReason\\\": \\\"\\\",\\n    \\\"deviceControlType\\\": 51,\\n    \\\"deviceIcon\\\": 15,\\n    \\\"deviceRole\\\": \\\"Rgb\\\",\\n    \\\"icon\\\": {},\\n    \\\"ieeeAddress\\\": \\\"0x84FD27EEEEEEE05E\\\",\\n    \\\"isLight\\\": true,\\n    \\\"log\\\": \\\"\\\",\\n    \\\"logTemp\\\": \\\"\\\",\\n    \\\"manufacturer\\\": \\\"\\\",\\n    \\\"model\\\": \\\"\\\",\\n    \\\"networkAddress\\\": 12761,\\n    \\\"programsSortOrder\\\": \\\"1,2,3,4,5\\\",\\n    \\\"saveLogs\\\": true,\\n    \\\"state\\\": false,\\n    \\\"supportedDeviceRoles\\\": [\\n      \\\"Rgb\\\"\\n    ],\\n    \\\"userDescription\\\": \\\"\\\",\\n    \\\"value\\\": 0\\n  },\\n  \\\"actions\\\": {\\n    \\\"setColor\\\": 1,\\n    \\\"setColorComponents\\\": 1,\\n    \\\"setValue\\\": 1,\\n    \\\"startColorEnhancement\\\": 1,\\n    \\\"startColorFade\\\": 1,\\n    \\\"startProgram\\\": 1,\\n    \\\"stopColorChange\\\": 1,\\n    \\\"toggle\\\": 0,\\n    \\\"turnOff\\\": 0,\\n    \\\"turnOn\\\": 0\\n  },\\n  \\\"created\\\": 1656669192,\\n  \\\"modified\\\": 1674037508,\\n  \\\"sortOrder\\\": 111\\n}\")\r\n    --addSimulatedDevice\"{\\n  \\\"id\\\": 46,\\n  \\\"name\\\": \\\"VR baie vitrée\\\",\\n  \\\"roomID\\\": 221,\\n  \\\"view\\\": [],\\n  \\\"type\\\": \\\"com.fibaro.device\\\",\\n  \\\"baseType\\\": \\\"\\\",\\n  \\\"enabled\\\": true,\\n  \\\"visible\\\": false,\\n  \\\"isPlugin\\\": false,\\n  \\\"parentId\\\": 7,\\n  \\\"viewXml\\\": false,\\n  \\\"hasUIView\\\": false,\\n  \\\"configXml\\\": false,\\n  \\\"interfaces\\\": [\\n    \\\"nice\\\",\\n    \\\"niceMono\\\"\\n  ],\\n  \\\"properties\\\": {\\n    \\\"buttonHold\\\": 5000,\\n    \\\"categories\\\": [\\n      \\\"other\\\"\\n    ],\\n    \\\"configuration\\\": true,\\n    \\\"dead\\\": false,\\n    \\\"deadReason\\\": \\\"\\\",\\n    \\\"deviceControlType\\\": 1,\\n    \\\"deviceIcon\\\": 28,\\n    \\\"deviceRole\\\": \\\"Other\\\",\\n    \\\"deviceState\\\": \\\"Configured\\\",\\n    \\\"icon\\\": {},\\n    \\\"inputToChannelMap\\\": {},\\n    \\\"log\\\": \\\"\\\",\\n    \\\"logTemp\\\": \\\"\\\",\\n    \\\"manufacturer\\\": \\\"NICE\\\",\\n    \\\"model\\\": \\\"\\\",\\n    \\\"niceId\\\": 13,\\n    \\\"niceProtocol\\\": \\\"Opera0\\\",\\n    \\\"numberOfSupportedButtons\\\": 8,\\n    \\\"saveLogs\\\": true,\\n    \\\"supportedDeviceRoles\\\": [\\n      \\\"Other\\\"\\n    ],\\n    \\\"userDescription\\\": \\\"\\\"\\n  },\\n  \\\"actions\\\": {},\\n  \\\"created\\\": 0,\\n  \\\"modified\\\": 1671310430,\\n  \\\"sortOrder\\\": 23\\n}\")\r\n    --addSimulatedDevice(\"{\\n  \\\"id\\\": 34,\\n  \\\"name\\\": \\\"VR baie vitrée\\\",\\n  \\\"roomID\\\": 221,\\n  \\\"view\\\": [\\n    {\\n      \\\"assetsPath\\\": \\\"dynamic-plugins/com.fibaro.remoteBaseShutter\\\",\\n      \\\"name\\\": \\\"com.fibaro.remoteBaseShutter\\\",\\n      \\\"translatesPath\\\": \\\"/assets/i18n/com.fibaro.remoteBaseShutter\\\",\\n      \\\"type\\\": \\\"ts\\\"\\n    },\\n    {\\n      \\\"assetsPath\\\": \\\"dynamic-plugins/favorite-positions\\\",\\n      \\\"name\\\": \\\"favorite-positions\\\",\\n      \\\"translatesPath\\\": \\\"/assets/i18n/favorite-positions\\\",\\n      \\\"type\\\": \\\"ts\\\"\\n    }\\n  ],\\n  \\\"type\\\": \\\"com.fibaro.remoteBaseShutter\\\",\\n  \\\"baseType\\\": \\\"com.fibaro.remoteController\\\",\\n  \\\"enabled\\\": true,\\n  \\\"visible\\\": true,\\n  \\\"isPlugin\\\": false,\\n  \\\"parentId\\\": 46,\\n  \\\"viewXml\\\": false,\\n  \\\"hasUIView\\\": true,\\n  \\\"configXml\\\": false,\\n  \\\"interfaces\\\": [\\n    \\\"favoritePosition\\\",\\n    \\\"nice\\\",\\n    \\\"niceMono\\\"\\n  ],\\n  \\\"properties\\\": {\\n    \\\"buttonHold\\\": 5000,\\n    \\\"categories\\\": [\\n      \\\"remotes\\\"\\n    ],\\n    \\\"configuration\\\": true,\\n    \\\"dead\\\": false,\\n    \\\"deadReason\\\": \\\"\\\",\\n    \\\"deviceControlType\\\": 53,\\n    \\\"deviceIcon\\\": 218,\\n    \\\"deviceRole\\\": \\\"BlindsWithoutPositioning\\\",\\n    \\\"deviceState\\\": \\\"Configured\\\",\\n    \\\"favoritePositions\\\": [\\n      {\\n        \\\"label\\\": \\\"Favorite position 1\\\",\\n        \\\"name\\\": \\\"FavoritePosition1\\\",\\n        \\\"value\\\": 50\\n      }\\n    ],\\n    \\\"favoritePositionsNativeSupport\\\": true,\\n    \\\"icon\\\": {\\n      \\\"path\\\": \\\"/assets/icon/fibaro/com.fibaro.remoteBaseShutter_garage/com.fibaro.remoteBaseShutter_garage.png\\\",\\n      \\\"source\\\": \\\"HC\\\"\\n    },\\n    \\\"inputToChannelMap\\\": {\\n      \\\"close\\\": [\\n        3\\n      ],\\n      \\\"open\\\": [\\n        1\\n      ],\\n      \\\"partialOpen1\\\": [],\\n      \\\"step\\\": [],\\n      \\\"stop\\\": [\\n        2\\n      ],\\n      \\\"toggleCh1\\\": [],\\n      \\\"toggleCh2\\\": [],\\n      \\\"turnOffCh1\\\": [],\\n      \\\"turnOffCh2\\\": [],\\n      \\\"turnOnCh1\\\": [],\\n      \\\"turnOnCh2\\\": [],\\n      \\\"unsupported\\\": []\\n    },\\n    \\\"log\\\": \\\"\\\",\\n    \\\"logTemp\\\": \\\"\\\",\\n    \\\"manufacturer\\\": \\\"NICE\\\",\\n    \\\"model\\\": \\\"\\\",\\n    \\\"niceId\\\": 13,\\n    \\\"niceProtocol\\\": \\\"Opera0\\\",\\n    \\\"numberOfSupportedButtons\\\": 8,\\n    \\\"saveLogs\\\": true,\\n    \\\"supportedDeviceRoles\\\": [\\n      \\\"BlindsWithoutPositioning\\\",\\n      \\\"VenetianBlinds\\\",\\n      \\\"Awning\\\"\\n    ],\\n    \\\"userDescription\\\": \\\"\\\"\\n  },\\n  \\\"actions\\\": {\\n    \\\"close\\\": 0,\\n    \\\"open\\\": 0,\\n    \\\"setFavoritePosition\\\": 1,\\n    \\\"stop\\\": 0\\n  },\\n  \\\"created\\\": 1649487581,\\n  \\\"modified\\\": 1671310429,\\n  \\\"sortOrder\\\": 15\\n}\")\r\n\r\n    ----------- PREPARE VIRTUAL ROOT NODE\r\n    deviceHierarchyRootNode = createUnidentifiedDeviceNode(\r\n        {\r\n            id = 0,\r\n            name = \"Root device node\",\r\n            parentId = nil,\r\n            roomId = nil,\r\n        }, \r\n        false\r\n    )\r\n\r\n    ----------- BUILD FIBARO DEVICE HIERARCHY\r\n    for i=1, #__allFibaroDevices do\r\n        appendNodeByFibaroDevice(__allFibaroDevices[i], false)\r\n    end\r\n\r\n    -- DO PERFORMANCE HEAVY OPERATIONS ONLY FOR DEVICES THAT ARE IN FILTER SCOPE\r\n    for i=1, #__filteredFibaroDeviceIds do\r\n        local fibaroDeviceId = __filteredFibaroDeviceIds[i].id\r\n        local deviceNode = deviceNodeById[fibaroDeviceId]\r\n\r\n        local fibaroDevice = deviceNode.fibaroDevice\r\n\r\n        ----------- INCLUDE NODE WITH DEVICE MATCHING FILTER CRITERIA\r\n        deviceNode.included = true\r\n\r\n        ----------- CREATE POWER, ENERGY & BATTERLY LEVEL SENSORS INSTEAD OF RELYING ON ATTRIBUTES WITHIN A SINGLE DEVICE\r\n        -- *** refactor \"check\" naming\r\n        __checkAndAppendLinkedDevices(fibaroDevice)\r\n    end\r\n\r\n    __identifyDeviceNode(deviceHierarchyRootNode)\r\n\r\n    return deviceHierarchyRootNode\r\nend\r\n\r\nfunction addSimulatedDevice(fibaroDeviceJsonStr)\r\n    local fibaroDevice = json.decode(fibaroDeviceJsonStr)\r\n    fibaroDevice.id = fibaroDevice.id + 20000\r\n    if fibaroDevice.parentId > 10 then\r\n        fibaroDevice.parentId = fibaroDevice.parentId + 20000\r\n    end\r\n    \r\n    table.insert(__allFibaroDevices, fibaroDevice)\r\n    table.insert(__filteredFibaroDeviceIds, { id = fibaroDevice.id })\r\n\r\n    allFibaroDevicesAmount = #__allFibaroDevices\r\n    filteredFibaroDevicesAmount = #__filteredFibaroDeviceIds\r\nend\r\n\r\n----------- CREATE POWER, ENERGY & BATTERLY LEVEL SENSORS INSTEAD OF RELYING ON ATTRIBUTES WITHIN A SINGLE DEVICE\r\nfunction __checkAndAppendLinkedDevices(fibaroDevice)\r\n\r\n    -- Does device support energy monitoring? Create a dedicated sensor for Home Assistant\r\n    if (table_contains_value(fibaroDevice.interfaces, \"energy\")) then \r\n        local sensor = createLinkedMultilevelSensorDevice(fibaroDevice, \"energy\")\r\n\r\n        appendNodeByFibaroDevice(sensor, true)\r\n    end\r\n\r\n    -- Does device support power monitoring? Create a dedicated sensor for Home Assistant\r\n    if (table_contains_value(fibaroDevice.interfaces, \"power\")) then \r\n        local sensor = createLinkedMultilevelSensorDevice(fibaroDevice, \"power\")\r\n\r\n        appendNodeByFibaroDevice(sensor, true)\r\n    end\r\n\r\n\r\n    -- Battery powered device? Create a dedicated battery sensor for Home Assistant\r\n    if (table_contains_value(fibaroDevice.interfaces, \"battery\")) then\r\n        -- *** check for duplicates and skip if appropriate\r\n        local sensor = createLinkedMultilevelSensorDevice(fibaroDevice, \"batteryLevel\")\r\n        appendNodeByFibaroDevice(sensor, true)\r\n    end\r\n\r\n    -- Is it a \"Remote Control\" device? Created dedicated devices for each combination of Button and Press Type\r\n    --if (device.type == RemoteController.type and device.subtype == RemoteController.subtype) then\r\n    if (RemoteController.isSupported(fibaroDevice)) then\r\n        if fibaroDevice.properties.centralSceneSupport then\r\n            for _, i in ipairs(fibaroDevice.properties.centralSceneSupport) do\r\n                for _, j in ipairs(i.keyAttributes) do\r\n                    local sensor = createLinkedKey(fibaroDevice, i.keyId, j)\r\n\r\n                    appendNodeByFibaroDevice(sensor, true)\r\n                end\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction appendNodeByFibaroDevice(fibaroDevice, included)\r\n    local fibaroDeviceId = fibaroDevice.id\r\n\r\n    local node = createUnidentifiedDeviceNode(fibaroDevice, included)\r\n\r\n    deviceNodeById[fibaroDeviceId] = node\r\n\r\n    -- enrich with room name, base/type fixes, etc\r\n    if (not fibaroDevice.linkedDevice) then\r\n        enrichFibaroDeviceWithMetaInfo(node.fibaroDevice)\r\n    end\r\n\r\n    local parentNode = node.parentNode\r\n    if parentNode then\r\n        table.insert(parentNode.childNodeList, node)\r\n    else\r\n        table.insert(deviceHierarchyRootNode.childNodeList, node)\r\n    end\r\n\r\n    return node\r\nend\r\n\r\n-- *** rename \"included\" to \"includedToFilterCriteria\"\r\nfunction createUnidentifiedDeviceNode(fibaroDevice, included)\r\n    -- lookup parent node from cache\r\n    local parentNode\r\n    if fibaroDevice.parentId then\r\n        parentNode = deviceNodeById[fibaroDevice.parentId]\r\n    else\r\n        parentNode = nil\r\n    end\r\n\r\n    local node = {\r\n        id = fibaroDevice.id,\r\n\r\n        fibaroDevice = fibaroDevice,\r\n        identifiedHaEntity = nil,\r\n        identifiedHaDevice = nil,\r\n\r\n        parentNode = parentNode,\r\n\r\n        childNodeList = { },\r\n\r\n        included = included,\r\n\r\n        -- *** simplify node structure/naming\r\n        isHaDevice = false\r\n    }\r\n\r\n    return node\r\nend\r\n\r\n\r\nfunction getDeviceNodeById(fibaroDeviceId)\r\n    return deviceNodeById[fibaroDeviceId]\r\nend\r\n\r\n\r\nfunction removeDeviceNodeFromHierarchyById(id)\r\n    local deviceNode = deviceNodeById[id]\r\n    \r\n    local parentNode = deviceNode.parentNode\r\n    local sourceListForDeviceNode\r\n    \r\n    if parentNode then\r\n        sourceListForDeviceNode = parentNode.childNodeList\r\n    else\r\n        sourceListForDeviceNode = deviceHierarchy\r\n    end\r\n\r\n    local ind = table.indexOf(sourceListForDeviceNode, deviceNode)\r\n\r\n    if (ind) then\r\n        table.remove(sourceListForDeviceNode, ind)\r\n    else\r\n        print(\"WARNING: Device node \" .. id .. \" was not removed from cache\")\r\n    end\r\n\r\n    deviceNodeById[id] = nil\r\nend\r\n\r\nfunction createAndAddDeviceNodeToHierarchyById(id)\r\n    local fibaroDevice = api.get(\"/devices/\" .. id)\r\n\r\n    local status, deviceFilterById = pcall(clone, deviceFilter)\r\n    local filterOperands = deviceFilterById.filters\r\n    filterOperands[#filterOperands + 1] = {\r\n            filter = \"deviceID\",\r\n            value = { id }\r\n    }\r\n    \r\n    local filteredFibaroDeviceIds = api.post( \r\n        \"/devices/filter\", \r\n        deviceFilterById\r\n    )\r\n\r\n    local newFibaroDevice = api.get(\"/devices/\" .. id)\r\n    local newDeviceNode = appendNodeByFibaroDevice(newFibaroDevice)\r\n\r\n    if #filteredFibaroDeviceIds == 0 then\r\n        print(\"Device \" .. id .. \" doesn't match to filter criteria and thus skipped\") \r\n    else\r\n        newDeviceNode.included = true\r\n\r\n        __checkAndAppendLinkedDevices(newDeviceNode.fibaroDevice)\r\n\r\n        __identifyDeviceNode(newDeviceNode)\r\n    end\r\n\r\n    return newDeviceNode\r\nend\r\n\r\nfunction enrichFibaroDeviceWithMetaInfo(fibaroDevice)\r\n    -- OVERRIDE BASE TYPE IF NECESSARY\r\n    local overrideBaseType = fibaroBaseTypeOverride[fibaroDevice.baseType]\r\n    if overrideBaseType then \r\n        fibaroDevice.baseType = overrideBaseType\r\n    end\r\n\r\n    -- OVERRIDE TYPE IF NECESSARY\r\n    local overrideType = fibaroTypeOverride[fibaroDevice.type]\r\n    if overrideType then \r\n        fibaroDevice.type = overrideType\r\n    end\r\n\r\n    fibaroDevice.roomName = tostring(fibaro.getRoomNameByDeviceID(fibaroDevice.id))\r\n\r\n    return fibaroDevice\r\nend\r\n\r\nfunction fibaroDeviceTypeContains(fibaroDevice, type)\r\n    return string.find(fibaroDevice.baseType, type) or string.find(fibaroDevice.type, type)\r\nend\r\nfunction fibaroDeviceTypeMatchesWith(fibaroDevice, type)\r\n    return (fibaroDevice.baseType == type) or (fibaroDevice.type == type)\r\nend\r\nfunction fibaroDeviceHasInterface(fibaroDevice, interface)\r\n    return table_contains_value(fibaroDevice.interfaces, interface)\r\nend\r\n\r\n-- *** rename to __identifyDeviceNodeAndItsChildren\r\nfunction __identifyDeviceNode(deviceNode)\r\n    -- identify Home Assistant entity\r\n    if (deviceNode.included) then\r\n        local identifiedHaEntity = __identifyHaEntity(deviceNode)\r\n\r\n        if (identifiedHaEntity) then\r\n            deviceNode.identifiedHaEntity = identifiedHaEntity\r\n            identifiedHaEntitiesAmount = identifiedHaEntitiesAmount + 1\r\n        end\r\n    end\r\n\r\n    -- identify Home Assistant device\r\n    local haDevice\r\n    if (deviceNode.parentNode and deviceNode.parentNode.identifiedHaDevice ~= nil) then\r\n        haDevice = deviceNode.parentNode.identifiedHaDevice\r\n    elseif deviceNode.fibaroDevice.baseType == \"com.fibaro.device\" then\r\n        haDevice = __identifyAndAppendHaDevice(deviceNode)\r\n    elseif deviceNode.identifiedHaEntity ~= nil then\r\n        haDevice = __identifyAndAppendHaDevice(deviceNode)\r\n    else\r\n        -- no Home Assistant device association available\r\n    end\r\n    deviceNode.identifiedHaDevice = haDevice\r\n\r\n    -- identify child devices\r\n    for _, deviceChildNode in pairs(deviceNode.childNodeList) do\r\n        __identifyDeviceNode(deviceChildNode)\r\n    end\r\nend\r\n\r\nfunction __identifyHaEntity(deviceNode)\r\n    for i, j in ipairs(haEntityTypeMappings) do\r\n        if (j.isSupported(deviceNode.fibaroDevice)) then\r\n            return j:new(deviceNode)\r\n        end\r\n    end\r\n\r\n    return nul\r\nend\r\n\r\nfunction __identifyAndAppendHaDevice(deviceNode)\r\n    local fibaroDevice = deviceNode.fibaroDevice\r\n\r\n    local haDevice = {\r\n        identifiers = \"hc3-\" .. fibaroDevice.id,\r\n        name = fibaroDevice.name,\r\n        suggested_area = fibaroDevice.roomName,\r\n        manufacturer = nil,\r\n        hw_version = nil,\r\n        sw_version = nil,\r\n        model = fibaroDevice.properties.model, \r\n        configuration_url = \"http://\" .. localIpAddress .. \"/app/settings/devices/list#device-\" .. fibaroDevice.id\r\n    }\r\n\r\n    if fibaroDeviceHasInterface(fibaroDevice, \"quickApp\") then\r\n        haDevice.hw_version = \"QuickApp (virtual device)\"\r\n        haDevice.sw_version = tostring(fibaroDevice.baseType) .. \"-\" .. tostring(fibaroDevice.type)\r\n    elseif fibaroDeviceHasInterface(fibaroDevice, \"zwave\") then\r\n        -- IDENTIFY HARDWARE VERSION\r\n        local zwaveHwVersion = fibaroDevice.properties.zwaveInfo\r\n        if zwaveHwVersion then\r\n            zwaveInfoComponents = splitStringToNumbers(zwaveHwVersion, \",\")\r\n            if (#zwaveInfoComponents == 3) then\r\n                zwaveHwVersion = \"Z-Wave type \" .. zwaveInfoComponents[1] .. \"; Z-Wave version \" .. zwaveInfoComponents[2] .. \".\" .. zwaveInfoComponents[3]\r\n            end\r\n        end\r\n        if zwaveHwVersion then\r\n            haDevice.hw_version = zwaveHwVersion\r\n        else   \r\n            haDevice.hw_version = \"Z-Wave\"\r\n        end\r\n        \r\n        -- IDENTIFY SOFTWARE VERSION\r\n        if fibaroDevice.properties.zwaveCompany then\r\n            haDevice.manufacturer = fibaroDevice.properties.zwaveCompany\r\n            haDevice.sw_version = haDevice.manufacturer .. \" \" .. tostring(fibaroDevice.properties.zwaveVersion)\r\n        else\r\n            haDevice.sw_version = tostring(fibaroDevice.properties.zwaveVersion)\r\n        end\r\n    elseif fibaroDeviceHasInterface(fibaroDevice, \"zigbee\") then\r\n        -- experimental, need hardware for testing\r\n        if fibaroDevice.properties.zigbeeVersion then\r\n            haDevice.hw_version = \"Zigbee\"\r\n        else\r\n            haDevice.hw_version = \"Zigbee \" .. tostring(fibaroDevice.properties.zigbeeVersion)\r\n        end\r\n    elseif fibaroDeviceHasInterface(fibaroDevice, \"nice\") then\r\n        -- experimental, need hardware for testing\r\n        if fibaroDevice.properties.niceProtocol then\r\n            haDevice.hw_version = \"Nice \" .. tostring(fibaroDevice.properties.niceProtocol)\r\n        else\r\n            haDevice.hw_version = \"Nice\"\r\n        end\r\n    end\r\n\r\n    deviceNode.isHaDevice = true\r\n\r\n    return haDevice\r\nend\r\n\r\nfunction createLinkedMultilevelSensorDevice(fromDevice, linkedProperty)\r\n    local linkedUnit\r\n    local sensorTypeSuffix = \"Sensor\"\r\n    if (linkedProperty == \"energy\") then\r\n        linkedUnit = \"kWh\"\r\n        sensorTypeSuffix = \"Meter\"\r\n    elseif (linkedProperty == \"power\") then\r\n        linkedUnit = \"W\"\r\n        sensorTypeSuffix = \"Meter\"\r\n    elseif (linkedProperty == \"batteryLevel\") then\r\n        linkedUnit = \"%\"\r\n    end\r\n\r\n    local newLinkedFibaroSensor = createLinkedFibaroDevice(fromDevice, linkedProperty, linkedUnit)\r\n\r\n    newLinkedFibaroSensor.baseType = \"com.fibaro.multilevelSensor\"\r\n    newLinkedFibaroSensor.type = \"com.fibaro.\" .. linkedProperty .. sensorTypeSuffix\r\n\r\n    return newLinkedFibaroSensor\r\nend\r\n\r\nfunction createLinkedKey(fromDevice, keyId, keyAttribute)\r\n    local keyAttribute = string.lower(keyAttribute)\r\n\r\n    local action = keyId .. \"-\" .. keyAttribute\r\n\r\n    --local newFibaroKey = createLinkedFibaroDevice(fromDevice, \"value\", nil)\r\n    local newFibaroKey = createLinkedFibaroDevice(fromDevice, action, nil)\r\n    newFibaroKey.baseType = \"com.alexander_vitishchenko.remoteKey\"\r\n    newFibaroKey.type = newFibaroKey.baseType\r\n    newFibaroKey.keyId = keyId\r\n    newFibaroKey.keyAttribute = keyAttribute\r\n\r\n    return newFibaroKey\r\nend\r\n\r\nfunction createLinkedFibaroDevice(fromDevice, linkedProperty, linkedUnit)\r\n    local newFibaroLinkedDevice = {\r\n        id = fromDevice.id .. \"_\" .. linkedProperty,\r\n        name = fromDevice.name,  \r\n        roomID = fromDevice.roomID,\r\n        roomName = fromDevice.roomName,\r\n        parentId = fromDevice.id,\r\n        linkedDevice = fromDevice,\r\n        linkedProperty = linkedProperty,\r\n        properties = {\r\n            unit = linkedUnit\r\n        },\r\n        comment = \"This entity has been autogenerated by HC3 <-> Home Assistant bridge to adjust the data model difference between Fibaro HC3 and Home Assistant. Fibaro treats '\" .. linkedProperty .. \"' entity to be an attribute of #\" .. fromDevice.id .. \". And Home Asisstant requires these to be two separate entities\"\r\n    }\r\n\r\n    return newFibaroLinkedDevice\r\nend\r\n\r\nfunction getDeviceDescriptionById(fibaroDeviceId)\r\n    local description = \"#\" .. tostring(fibaroDeviceId)\r\n\r\n    local deviceNode = getDeviceNodeById(fibaroDeviceId)\r\n\r\n    if deviceNode then\r\n        local fibaroDevice = deviceNode.fibaroDevice\r\n        if fibaroDevice then\r\n            description = description .. \" named as \" .. tostring(fibaroDevice.name) .. \" at \\\"\" .. tostring(fibaroDevice.roomName) .. \"\\\"\"\r\n        end\r\n    end\r\n\r\n    return description\r\nend\r\n\r\nfunction printDeviceNode(deviceNode, level)\r\n    local deviceDescription = \"\"\r\n\r\n    local lastSiblingNode\r\n    local lastSiblingNodeOfParent\r\n    local lastSiblingNodeOfParentOfParent\r\n    if (deviceNode.parentNode) then\r\n        local siblingNodes = deviceNode.parentNode.childNodeList\r\n        lastSiblingNode = siblingNodes[#siblingNodes]\r\n\r\n        if (deviceNode.parentNode.parentNode) then\r\n            local siblingNodesOfParent = deviceNode.parentNode.parentNode.childNodeList\r\n            lastSiblingNodeOfParent = siblingNodesOfParent[#siblingNodesOfParent]\r\n\r\n            if (deviceNode.parentNode.parentNode.parentNode) then\r\n                local siblingNodesOfParentOfParent = deviceNode.parentNode.parentNode.parentNode.childNodeList\r\n                lastSiblingNodeOfParentOfParent = siblingNodesOfParentOfParent[#siblingNodesOfParentOfParent]\r\n            end\r\n        end\r\n    end\r\n\r\n    if level > 1 then\r\n        local levelCap = level-1\r\n        for i=1, levelCap do\r\n            deviceDescription = deviceDescription .. \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"\r\n            \r\n            if (i > 1) then\r\n                deviceDescription = deviceDescription .. \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"\r\n            end\r\n            \r\n            -- *** refactor with dynamic parent level number \r\n            if (i < levelCap) then\r\n                if ((i == (levelCap - 2)) and (deviceNode.parentNode ~= lastSiblingNodeOfParentOfParent)) then\r\n                    deviceDescription = deviceDescription .. \"&#x2503;\"\r\n                elseif ((i == (levelCap - 1)) and (deviceNode.parentNode ~= lastSiblingNodeOfParent)) then\r\n                    deviceDescription = deviceDescription .. \"&#x2503;\"\r\n                else\r\n                    deviceDescription = deviceDescription .. \"&nbsp;\"\r\n                end\r\n            end\r\n        end\r\n\r\n        if (deviceNode == lastSiblingNode) then\r\n            -- ┗\r\n            deviceDescription = deviceDescription .. \"&#x2517;\"\r\n        else\r\n            -- ┣\r\n            deviceDescription = deviceDescription .. \"&#9507;\"\r\n        end\r\n\r\n        -- ━━▶\r\n        deviceDescription = deviceDescription .. \"&#9473;&#9473;&#9654; \"\r\n    end\r\n\r\n    local bracketStart\r\n    local bracketEnd\r\n    if (deviceNode.isHaDevice) then\r\n        -- 〚  〛\r\n        --bracketStart = \"&#12310;\"\r\n        --bracketEnd = \"&#12311;\"\r\n        -- < >\r\n        bracketStart = \"<\"\r\n        bracketEnd = \">\"\r\n    else\r\n        bracketStart = \"[\"\r\n        bracketEnd = \"]\"\r\n    end\r\n\r\n    local deviceType\r\n    if (deviceNode.included) then\r\n        local identifiedHaEntity = deviceNode.identifiedHaEntity\r\n\r\n        if (identifiedHaEntity) then\r\n            -- 💡, 🌈, 🔌, etc\r\n            deviceDescription = deviceDescription .. bracketStart .. identifiedHaEntity.icon .. bracketEnd.. \" \"\r\n            deviceType = identifiedHaEntity.type .. \"-\" .. tostring(identifiedHaEntity.subtype)\r\n        else\r\n            -- 🚧\r\n            deviceDescription = deviceDescription .. bracketStart .. \"&#128679;\" .. bracketEnd .. \" \"\r\n        end\r\n    else\r\n        -- 🛇\r\n        deviceDescription = deviceDescription .. bracketStart .. \"&#128711;\" .. bracketEnd .. \" \"\r\n    end\r\n\r\n    local fibaroDevice = deviceNode.fibaroDevice\r\n    \r\n    deviceDescription = deviceDescription .. \"#\" .. fibaroDevice.id .. \" named as \\\"\"  .. tostring(fibaroDevice.name) .. \"\\\"\"\r\n\r\n    if (fibaroDevice.roomName) then\r\n        deviceDescription = deviceDescription .. \" in \\\"\" .. fibaroDevice.roomName .. \"\\\" room\"\r\n    end\r\n\r\n    if (deviceNode.included) then\r\n        if (deviceType) then\r\n            deviceDescription = deviceDescription .. \" identified as \" .. deviceType .. \" type\"\r\n        else\r\n            deviceDescription = deviceDescription .. \" (unsupported device: \" .. fibaroDevice.baseType .. \"-\" .. fibaroDevice.type .. \")\"\r\n        end\r\n    else\r\n        deviceDescription = deviceDescription .. \" (excluded by QuickApp filters)\"\r\n    end\r\n\r\n    if (level > 0) then\r\n        print(deviceDescription)\r\n    end\r\n\r\n    for _, deviceChildNode in pairs(deviceNode.childNodeList) do\r\n        printDeviceNode(deviceChildNode, level + 1)\r\n    end\r\n\r\nend\r\n"}]}

