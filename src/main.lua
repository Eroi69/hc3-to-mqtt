function QuickApp:onInit()
    self:debug("-------------------------")
    self:debug("HC3 <-> MQTT BRIDGE")
    self:debug("-------------------------")

    self:turnOn() 
end

function QuickApp:publish(topic, payload)
    self.mqtt:publish(topic, tostring(payload), {retain = true})
end

function QuickApp:turnOn()
    self:establishMqttConnection()
end

function QuickApp:turnOff()
    self:disconnectFromMqttAndHc3()
    self:updateProperty("value", false)
    self:debug("Device status is set to 'turnOff' at Fibaro GUI")
    self:debug("HC3-to-MQTT bridge shutdown sequence complete")
end

function QuickApp:establishMqttConnection() 
    self.devices = {}

    -- IDENTIFY WHICH MQTT CONVENTIONS TO BE USED (e.g. Home Assistant, Homio, etc)
    self.mqttConventions = { }
    local mqttConventionStr = self:getVariable("mqttConvention")
    if (isEmptyString(mqttConventionStr)) then
        self.mqttConventions[0] = MqttConventionHomeAssistant
    else
        local arr = splitString(mqttConventionStr, ",")
        for i, j in ipairs(arr) do
            local convention = mqttConventionMappings[j]
            if (convention) then
                self.mqttConventions[i] = clone(convention)
            end
        end
    end

    local mqttConnectionParameters = self:getMqttConnectionParameters()
    self:trace("MQTT Connection Parameters: " .. json.encode(mqttConnectionParameters))

    local mqttClient = mqtt.Client.connect(
                                    self:getVariable("mqttUrl"),
                                    mqttConnectionParameters) 

    mqttClient:addEventListener('connected', function(event) self:onConnected(event) end)
    mqttClient:addEventListener('closed', function(event) self:onClosed(event) end)
    mqttClient:addEventListener('message', function(event) self:onMessage(event) end)
    mqttClient:addEventListener('error', function(event) self:onError(event) end)    
    
    -- skip event handlers to aid higher performance
    --mqttClient:addEventListener('subscribed', function(event) self:onSubscribed(event) end)
    --mqttClient:addEventListener('published', function(event) self:onPublished(event) end)

    self.mqtt = mqttClient
end

function QuickApp:getMqttConnectionParameters()
    local mqttConnectionParameters = {
        -- pickup last will from primary MQTT Convention provider
        lastWill = self.mqttConventions[1]:getLastWillMessage()
    }

    -- MQTT CLIENT ID (OPTIONAL)
    local mqttClientId = self:getVariable("mqttClientId")
    if (isEmptyString(mqttClientId)) then
        local autogeneratedMqttClientId = "HC3-" .. plugin.mainDeviceId .. "-" .. tostring(os.time())
        self:warning("All is good - we have just autogenerated mqttClientId for you \"" .. autogeneratedMqttClientId .. "\"")
        mqttConnectionParameters.clientId = autogeneratedMqttClientId
    else
        mqttConnectionParameters.clientId = mqttClientId
    end

    -- MQTT KEEP ALIVE PERIOD
    local mqttKeepAlivePeriod = self:getVariable("mqttKeepAlive")
    if (mqttKeepAlivePeriod) then
        mqttConnectionParameters.keepAlivePeriod = tonumber(mqttKeepAlivePeriod)
    else
        mqttConnectionParameters.keepAlivePeriod = 30
    end

    -- MQTT AUTH (USERNAME/PASSWORD)
    local mqttUsername = self:getVariable("mqttUsername")
    local mqttPassword = self:getVariable("mqttPassword")

    if (mqttUsername) then
        mqttConnectionParameters.username = mqttUsername
    end
    if (mqttPassword) then
        mqttConnectionParameters.password = mqttPassword
    end

    return mqttConnectionParameters
end

function QuickApp:disconnectFromMqttAndHc3()
    self.hc3ConnectionEnabled = false
    self:closeMqttConnection()
    self:debug("Disconnected from MQTT")
end

function QuickApp:closeMqttConnection()
    for i, j in ipairs(self.mqttConventions) do
        if (j.mqtt ~= MqttConventionPrototype.mqtt) then
            j:onDisconnected()
        end
    end

    self.mqtt:disconnect()
end

function QuickApp:onClosed(event)
    self:updateProperty("value", false)
end

function QuickApp:onError(event)
    self:error("MQTT ERROR: " .. json.encode(event))
    self:turnOff()
    self:scheduleReconnectToMqtt();
end

function QuickApp:scheduleReconnectToMqtt()
    fibaro.setTimeout(10000, function() 
        self:debug("Attempt to reconnect to MQTT...")
        self:establishMqttConnection()
    end)
end

function QuickApp:onMessage(event)
    for i, j in ipairs(self.mqttConventions) do
        j:onCommand(event)
    end
end

function QuickApp:onConnected(event)
    self:debug("MQTT connection established")

    for _, mqttConvention in ipairs(self.mqttConventions) do
        mqttConvention.mqtt = self.mqtt
        mqttConvention.devices = self.devices
        mqttConvention:onConnected()
    end

    self:discoverDevicesAndPublishToMqtt()

    self.hc3ConnectionEnabled = true
    self:scheduleHc3EventsFetcher()

    self:updateProperty("value", true)
end

function QuickApp:identifyAndPublishDeviceToMqtt(fibaroDevice)
    local bridgedDevice = identifyDevice(fibaroDevice)
    self:publishDeviceToMqtt(bridgedDevice)
end

function QuickApp:discoverDevicesAndPublishToMqtt()
    local startTime = os.time()

    local fibaroDevices = self:discoverDevices()
    
    self:identifyDevices(fibaroDevices)

    for _, device in pairs(self.devices) do
        self:publishDeviceToMqtt(device)
    end

    local diff = os.time() - startTime   

    local bridgedDevices = 0
    for _, _ in pairs(self.devices) do
        bridgedDevices = bridgedDevices + 1
    end
    
    self:updateView("availableDevices", "text", "Available devices: " .. #fibaroDevices)
    self:updateView("bridgedDevices", "text", "Bridged devices: " .. bridgedDevices) 
    self:updateView("bootTime" , "text", "Boot time: " .. diff .. "s")

    self:debug("----------------------------------")
    self:debug("Device discovery has been complete")
    self:debug("----------------------------------")

    return haDevices
end

function QuickApp:discoverDevices()
    local fibaroDevices

    local developmentModeStr = self:getVariable("developmentMode")
    if ((not developmentModeStr) or (developmentModeStr ~= "true")) then
        self:debug("Bridge mode: PRODUCTION")

        fibaroDevices = getFibaroDevicesByFilter({
            enabled = true,
            visible = true
        })
    else
        --smaller number of devices for development and testing purposes
        self:debug("Bridge mode: DEVELOPMENT")

        fibaroDevices = {
            getFibaroDeviceById(41), -- switch Onyx light,
            getFibaroDeviceById(42), -- switch Fan,
            getFibaroDeviceById(260), -- iPad screen
            getFibaroDeviceById(287), -- door sensor
            getFibaroDeviceById(54), -- motion sensor
            getFibaroDeviceById(92), -- roller shutter
            getFibaroDeviceById(78), -- dimmer
            getFibaroDeviceById(66), -- temperature sensor
            getFibaroDeviceById(56), -- light sensor (lux)
            getFibaroDeviceById(245), -- volts
            getFibaroDeviceById(105), -- on/off thermostat from CH
            getFibaroDeviceById(106), -- temperature sensor
            getFibaroDeviceById(120), -- IR thermostat from CH
            getFibaroDeviceById(122), -- temperature sensor
            getFibaroDeviceById(335), -- on/off thermostat from Qubino
            getFibaroDeviceById(336), -- temperature sensor 
            getFibaroDeviceByInfo(json.decode(""))
        }
    end

    return fibaroDevices 
end

function QuickApp:identifyDevices(fibaroDevices) 
    for _, fibaroDevice in ipairs(fibaroDevices) do
        local device = identifyDevice(fibaroDevice)
        if (device) then
            self:debug("Device " .. self:getDeviceDescription(device) .. " identified as " .. device.bridgeType)
            self.devices[device.id] = device

            -- ***** ToDo: move to identifyDevice function, aiming support deviceRemoved and deviceModified and deviceCreated events
            -- Does device support energy monitoring? Create a dedicated sensor for Home Assistant
            if (table_contains_value(fibaroDevice.interfaces, "energy")) then 
                local energyDevice = self:createLinkedSensorDevice(device, "energy")
                self.devices[energyDevice.id] = energyDevice
            end

            -- Does device support power monitoring? Create a dedicated sensor for Home Assistant
            if (table_contains_value(fibaroDevice.interfaces, "power")) then 
                local powerDevice = self:createLinkedSensorDevice(device, "power")
                self.devices[powerDevice.id] = powerDevice
            end
        else
            self:debug("Couldn't recognize device #" .. fibaroDevice.id .. " - " .. fibaroDevice.name .. " - " .. fibaroDevice.baseType .. " - " .. fibaroDevice.type)
        end
    end
end

function QuickApp:createLinkedSensorDevice(fromDevice, linkedProperty)
    local linkedUnit
    local last_reset
    if (linkedProperty == "energy") then
        linkedUnit = "kWh"
        lastReset = "1970-01-03T00:00:00+00:00"
    elseif (linkedProperty == "power") then
        linkedUnit = "W"
    end

    local newFibaroLinkedSensor = {
        id = fromDevice.id .. "_" .. linkedProperty,
        baseType = "com.fibaro.multilevelSensor",
        type = "com.fibaro." .. linkedProperty .. "Sensor",
        name = fromDevice.name,  
        roomID = fromDevice.roomID,
        roomName = fromDevice.roomName,
        parentId = fromDevice.parentId,
        linkedDevice = fromDevice,
        linkedProperty = linkedProperty,
        properties = {
            unit = linkedUnit,
            dead = false,
            lastReset = lastReset
        },
        comment = "This device has been autogenerated by HC3 <-> Home Assistant bridge to adjust the data model difference between Fibaro HC3 and Home Assistant. Fibaro considers this device and the '" .. linkedProperty .. "' meter to be the single entity. And Home Asisstant requires these to be separate devices"
    }

    local newLinkedSensor = identifyDevice(newFibaroLinkedSensor)
    newLinkedSensor.fibaroDevice.linkedDevice = nil

    return newLinkedSensor
end

function QuickApp:publishDeviceToMqtt(device)
    ------------------------------------------------------------------
    ------- ANNOUNCE DEVICE EXISTANCE
    ------------------------------------------------------------------
    for i, j in ipairs(self.mqttConventions) do
        j:onDeviceCreated(device)
    end

    ------------------------------------------------------------------
    ------- ANNOUNCE DEVICE CURRENT STATE => BY SIMULATING HC3 EVENTS
    ------------------------------------------------------------------
    self:simulatePropertyUpdate(device, "dead", device.properties.dead)
    self:simulatePropertyUpdate(device, "state", device.properties.state)
    self:simulatePropertyUpdate(device, "value", device.properties.value)
    self:simulatePropertyUpdate(device, "heatingThermostatSetpoint", device.properties.heatingThermostatSetpoint)
    self:simulatePropertyUpdate(device, "thermostatMode", device.properties.thermostatMode)
    self:simulatePropertyUpdate(device, "energy", device.properties.energy)
    self:simulatePropertyUpdate(device, "power", device.properties.power)
    self:simulatePropertyUpdate(device, "lastReset", device.properties.lastReset)
end

function QuickApp:onPublished(event)
    -- do nothing, for now
end

-- FETCH HC3 EVENTS
local lastRefresh = 0
local http = net.HTTPClient()

function QuickApp:scheduleHc3EventsFetcher()
    -- hc3Auth variable is deprecated as being overcomplex for QuickApp users
    local hc3Auth = nil
    --local hc3Auth = self:getVariable("hc3Auth")
    if (isEmptyString(hc3Auth)) then
        local hc3Username = self:getVariable("hc3Username")
        local hc3Password = self:getVariable("hc3Password")
        if (isEmptyString(hc3Username) or isEmptyString(hc3Password)) then
            self:warning("You have not provided Fibaro HC3 username and password, as result you have experimental 'passwordless' mode enabled")
            --error("You need to provide username/password for your Fibaro HC3")
        end
        hc3Auth = base64Encode(hc3Username .. ":" .. hc3Password)
    end

    self.hc3Auth = hc3Auth

    self:readHc3EventAndScheduleFetcher()
    self:debug("---------------------------------------------------")
    self:debug("Started monitoring events from Fibaro Home Center 3")
    self:debug("---------------------------------------------------")
end

function QuickApp:readHc3EventAndScheduleFetcher()

    if self.hc3Auth then
        -- This a reliable and high-performance method to get events from Fibaro HC3, by using non-blocking HTTP calls. Where 'passwordles' api.get() has a rick of blocking calls => peformance isues

        local requestUrl = "http://localhost:11111/api/refreshStates?last=" .. lastRefresh
        --self:debug("Try fetch events from " .. requestUrl .. " | " .. tostring(self.hc3ConnectionEnabled))

        local stat, res = http:request(
            requestUrl,
            {
            options = {
                headers = {
                    ["Authorization"] = "Basic " .. self.hc3Auth,
                }
            },
            success=function(res)
                if (res and res.data) then
                    self:processFibaroHc3Events(json.decode(res.data))
                else
                    self:error("Error while reading data with events from HC3" .. json.encode(res))
                    self:turnOff()
                end
            end,
            error=function(res) 
                self:error("Error while trying to request HC3 events " .. json.encode(res))
                self:turnOff()
            end
        })

    else
        -- Experimental 'passwordless' mode for Fibaro HC3
        local res = api.get("/refreshStates?last=" .. lastRefresh)
        self:processFibaroHc3Events(res) 
    end

    if (self.hc3ConnectionEnabled) then
        local delay
        if self.gotError then
            self:warning("Got error - retry in 1s")
            delay = 1000
        else
            delay = 1000
        end

        fibaro.setTimeout(delay, function()
            self:readHc3EventAndScheduleFetcher()
        end)
    else
        self:debug("Disconnected from HC3 (got flagged to stop reading HC3 events)")
    end

end

function QuickApp:processFibaroHc3Events(data)
    -- Debug for "paswordless" mode. Doesn't work well for now due to blocking api-calls. Significantly reducing performance

    if not self.hc3ConnectionEnabled then
        return
    end

    local events = data.events --= data.status == 200 and json.decode(data.data)
    self.gotError = false

    
    if (data.status ~= 200 and data.status ~= "IDLE") then
        self:error("Unexpected response status " .. tostring(data.status))
        self.gotError = true
    end

    if (data.last) then
        lastRefresh = data.last
    end

    if events and #events>0 then 
        -- self:debug(json.encode(events))
        for i, v in ipairs(events) do
            self:dispatchFibaroEventToMqtt(v)
        end
    end
end

function QuickApp:simulatePropertyUpdate(device, propertyName, value)
    if value ~= nil then
        local event = createFibaroEventPayload(device, propertyName, value)
        event.simulation = true
        self:dispatchFibaroEventToMqtt(event)
    end
end

function QuickApp:dispatchFibaroEventToMqtt(event)
    --self:debug("Event: " .. json.encode(event))
    if (not event) then
        self:error("No event found")
        return
    end

    if (not event.data) then
        self:error("No event data found")
        return
    end

    local deviceId = event.data.id or event.data.deviceId

    if not deviceId then
        -- deviceId is must have for processing logic
        self:warning("No device id for " .. json.encode(event))
        return
    end 
    
    local propertyName = event.data.property
    if not propertyName then
        propertyName = "unknown"
    end

    if (not event.type) then
        event.type = "unknown"
    end

    local device = self.devices[deviceId]

    if (device) then

        if (event.type == "DevicePropertyUpdatedEvent") then

            -- *** OVERRIDE FIBARO PROPERTY NAMES, FOR BEING MORE CONSISTENT AND THUS EASIER TO HANDLE 
            if (device.bridgeType == "binary_sensor") and (propertyName == "value") then
                -- Fibaro uses state/value fields inconsistently for binary sensor. Replace value --> state field
                event.data.property = "state"
            end

            local value = event.data.newValue
            if (isNumber(value)) then
                value = round(value, 2)
            end
            event.data.newValue = (type(value) == "number" and value or tostring(value))

            for i, j in ipairs(self.mqttConventions) do
                j:onPropertyUpdated(device, event)
            end
        elseif (event.type == "DeviceModifiedEvent") then
            self:dispatchDeviceModifiedEvent(device)
        elseif (event.type == "DeviceCreatedEvent") then
            self:dispatchDeviceCreatedEvent(device)
        elseif (event.type == "DeviceRemovedEvent") then 
            self:dispatchDeviceRemovedEvent(device)
        elseif (event.type == "DeviceActionRanEvent") then
            if (event.data.actionName == "turnOn" or event.data.actionName == "turnOff") then
                --self:rememberLastHc3CommandTime(deviceId, event.sourceType)
            end
        else
            self:debug("Unsupported event type received \"" .. tostring(event.type) .. "\". All is good - feel free contact this QuickApp developer to get it supported")
        end

    end
end

function QuickApp:rememberLastMqttCommandTime(deviceId)
    self.lastMqttCommandTime[deviceId] = os.time()
end

function QuickApp:dispatchDeviceCreatedEvent(device)
    local fibaroDevice = api.get("/devices/" .. device.id)

    if (fibaroDevice.visible and fibaroDevice.enabled) then
        self:debug("Device created " .. json.encode(fibaroDevice))
        self:identifyAndPublishDeviceToMqtt(fibaroDevice)
    end
end

function QuickApp:dispatchDeviceModifiedEvent(device)
    self:debug("Device modified " .. device.id)

    self:dispatchDeviceRemovedEvent(device)

    self:dispatchDeviceCreatedEvent(device)
end

function QuickApp:dispatchDeviceRemovedEvent(device)
    self:debug("Device removed " .. device.id)
    for i, j in ipairs(self.mqttConventions) do
        j:onDeviceRemoved(device)
    end
    --self:removeDeviceFromMqtt(device)
end

function QuickApp:dispatchCentralSceneEvent(device, event, payload)
    -- PUBLISH DEVICE STATUS TO HOME ASSISTANT
    local topic = createGenericEventTopicName(device, "CentralSceneEvent", "key" .. event.data.keyAttribute)

    createGenericEventTopicName(device, event.type)

    self:publish(
        topic,
        event.data.keyId
    )
end

function QuickApp:getDeviceDescription(device)
    if device and device.name and device.id and device.roomName then
        return device.name .. " #" .. device.id .. " (" .. tostring(device.roomName) .. ")"
    else
        return device.id
    end
end
